<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-java/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-java";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>03 | 档案类：怎么精简地表达不可变数据？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/深入剖析java新特性/02.提升编码效率/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a aria-current="page" class="active" href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a aria-current="page" class="active" href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入剖析java新特性/01.开篇词">01.开篇词</a><ul><li><a href="/blog-java/深入剖析java新特性/01.开篇词/01"><span>开篇词 | 拥抱Java新特性，像设计者一样工作和思考</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-java/深入剖析java新特性/02.提升编码效率">02.提升编码效率</a><ul><li><a href="/blog-java/深入剖析java新特性/02.提升编码效率/01"><span>01 | JShell：怎么快速验证简单的小问题？</span></a></li><li><a href="/blog-java/深入剖析java新特性/02.提升编码效率/02"><span>02 | 文字块：怎么编写所见即所得的字符串？</span></a></li><li><a aria-current="page" class="active" href="/blog-java/深入剖析java新特性/02.提升编码效率/03"><span>03 | 档案类：怎么精简地表达不可变数据？</span></a></li><li><a href="/blog-java/深入剖析java新特性/02.提升编码效率/04"><span>04 | 封闭类：怎么刹住失控的扩展性？</span></a></li><li><a href="/blog-java/深入剖析java新特性/02.提升编码效率/05"><span>05 | 类型匹配：怎么切除臃肿的强制转换？</span></a></li><li><a href="/blog-java/深入剖析java新特性/02.提升编码效率/06"><span>06 | switch表达式：怎么简化多情景操作？</span></a></li><li><a href="/blog-java/深入剖析java新特性/02.提升编码效率/07"><span>07 | switch匹配：能不能适配不同的类型？</span></a></li></ul></li><li><a href="/blog-java/深入剖析java新特性/03.提升代码性能">03.提升代码性能</a><ul><li><a href="/blog-java/深入剖析java新特性/03.提升代码性能/01"><span>08 | 抛出异常，是不是错误处理的第一选择？</span></a></li><li><a href="/blog-java/深入剖析java新特性/03.提升代码性能/02"><span>09 | 异常恢复，付出的代价能不能少一点？</span></a></li><li><a href="/blog-java/深入剖析java新特性/03.提升代码性能/03"><span>10 | Flow，是异步编程的终极选择吗？</span></a></li><li><a href="/blog-java/深入剖析java新特性/03.提升代码性能/04"><span>11 | 矢量运算：Java的机器学习要来了吗？</span></a></li><li><a href="/blog-java/深入剖析java新特性/03.提升代码性能/05"><span>12 | 外部内存接口：零拷贝的障碍还有多少？</span></a></li><li><a href="/blog-java/深入剖析java新特性/03.提升代码性能/06"><span>13 | 外部函数接口，能不能取代Java本地接口？</span></a></li></ul></li><li><a href="/blog-java/深入剖析java新特性/04.降低维护难度">04.降低维护难度</a><ul><li><a href="/blog-java/深入剖析java新特性/04.降低维护难度/01"><span>14 | 禁止空指针，该怎么避免崩溃的空指针？</span></a></li><li><a href="/blog-java/深入剖析java新特性/04.降低维护难度/02"><span>15 | 现代密码：你用的加密算法过时了吗？</span></a></li><li><a href="/blog-java/深入剖析java新特性/04.降低维护难度/03"><span>16 | 改进的废弃，怎么避免使用废弃的特性？</span></a></li><li><a href="/blog-java/深入剖析java新特性/04.降低维护难度/04"><span>17 | 模块系统：为什么Java需要模块化？</span></a></li><li><a href="/blog-java/深入剖析java新特性/04.降低维护难度/05"><span>18 | 模块系统：怎么模块化你的应用程序？</span></a></li></ul></li><li><a href="/blog-java/深入剖析java新特性/05.结束语">05.结束语</a><ul><li><a href="/blog-java/深入剖析java新特性/05.结束语/01"><span>期末测试｜来赴一场满分之约！</span></a></li><li><a href="/blog-java/深入剖析java新特性/05.结束语/02"><span>结束语 | Java的未来，依然是星辰大海</span></a></li></ul></li><li><a href="/blog-java/深入剖析java新特性/06.特别放送">06.特别放送</a><ul><li><a href="/blog-java/深入剖析java新特性/06.特别放送/01"><span>用户故事 | 保持好奇心，积极拥抱变化</span></a></li><li><a href="/blog-java/深入剖析java新特性/06.特别放送/02"><span>用户故事 | 与新特性开发者对话</span></a></li></ul></li><li><a href="/blog-java/深入剖析java新特性/summary">深入剖析java新特性</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="阅读案例" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/03#阅读案例"><span>阅读案例</span></a></li><li title="案例分析" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/03#案例分析"><span>案例分析</span></a></li><li title="进一步的简化" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/03#进一步的简化"><span>进一步的简化</span></a></li><li title="怎么声明档案类" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/03#怎么声明档案类"><span>怎么声明档案类</span></a></li><li title="意料之外的改进" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/03#意料之外的改进"><span>意料之外的改进</span></a></li><li title="不可变的数据" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/03#不可变的数据"><span>不可变的数据</span></a></li><li title="透明的载体" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/03#透明的载体"><span>透明的载体</span></a></li><li title="重写构造方法" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/03#重写构造方法"><span>重写构造方法</span></a></li><li title="重写equals方法" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/03#重写equals方法"><span>重写equals方法</span></a></li><li title="不推荐的重写" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/03#不推荐的重写"><span>不推荐的重写</span></a></li><li title="总结" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/03#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="03--档案类怎么精简地表达不可变数据"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/03#03--档案类怎么精简地表达不可变数据"><span class="icon icon-link"></span></a>03 | 档案类：怎么精简地表达不可变数据？</h1><p>你好，我是范学雷。今天，我们聊一聊Java的档案类。</p><p>档案类这个特性，首先在JDK 14中以<a target="_blank" rel="noopener noreferrer" href="https://openjdk.java.net/jeps/359">预览版<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的形式发布。在JDK 15中，改进的档案类再次以<a target="_blank" rel="noopener noreferrer" href="https://openjdk.java.net/jeps/384">预览版<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的形式发布。最后，档案类在JDK 16<a target="_blank" rel="noopener noreferrer" href="https://openjdk.java.net/jeps/395">正式发布<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>那么，什么是档案类呢？档案类的英文，使用的词汇是“record”。官方的说法，Java档案类是用来表示不可变数据的透明载体。这样的表述，有两个关键词，一个是不可变的数据，另一个是透明的载体。</p><p>该怎么理解“不可变的数据”和“透明的载体”呢？我们还是通过案例和代码，一步一步地来拆解、理解这些概念。</p><h2 id="阅读案例"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/03#阅读案例"><span class="icon icon-link"></span></a>阅读案例</h2><p>在面向对象的编程语言中，研究表示形状的类是一个常用的教学案例。今天的评审案例，我们从形状的子类圆形开始，来看一看面向对象编程实践中，这个类的设计和演化。</p><p>下面的这段代码，就是一个简单的、典型的圆形类的定义。这个抽象类的名字是<strong>Circle</strong>。它有一个私有的变量<strong>radius</strong>，用来表示圆的半径。有一个构造方法，用来生成圆形的实例。有一个设置半径的方法<strong>setRadius</strong>，一个读取半径的方法<strong>getRadius</strong>。还有一个重写的方法<strong>getArea</strong>，用来计算圆形的面积。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package co.ivi.jus.record.former;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public final class Circle implements Shape {</span></div><div class="token-line"><span class="token plain">        private double radius;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public Circle(double radius) {</span></div><div class="token-line"><span class="token plain">            this.radius = radius;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public double getArea() {</span></div><div class="token-line"><span class="token plain">            return Math.PI * radius * radius;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public double getRadius() {</span></div><div class="token-line"><span class="token plain">            return radius;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public void setRadius(double radius) {</span></div><div class="token-line"><span class="token plain">            this.radius = radius;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个圆形类之所以典型，是因为它交代了面向对象设计的关键思想，包括面向对象编程的三大支柱性原则：封装、继承和多态。</p><p>封装的原则是隐藏具体实现细节，实现的修改不会影响接口的使用。<strong>Circle</strong>类中，表示半径的变量被定义成私有的变量。我们可以改变半径这个变量的名字，或者不使用半径而是使用直径来表示圆形。这样的实现细节的变化，并不会影响公开方法的调用。</p><p>由于需要隐藏内部实现细节，所以需要设计公开接口来访问类的相关特征，比如例子中的圆形的半径。所以上面的例子中，设置半径的方法<strong>setRadius</strong>和读取半径的方法<strong>getRadius</strong>，就显得显而易见，并且顺理成章。在面向对象编程的教科书里，以及Java的标准类库里，我们可以看到很多类似的设计。</p><p>可是，这样的设计有哪些严重的缺陷呢？花点时间想想你能找到的问题，然后我们接下来再继续分析。</p><h2 id="案例分析"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/03#案例分析"><span class="icon icon-link"></span></a>案例分析</h2><p>上面这个例子，最重要的问题，就是它的接口不是多线程安全的。如果在一个多线程的环境中，有些线程调用了<strong>setRadius</strong>方法，有些线程调用<strong>getRadius</strong>方法，这些调用的最终结果是难以预料的。这也就是我们常说的多线程安全问题。</p><p>在现代计算机架构下，大多数的应用需要多线程的环境。所以，我们通常需要考虑多线程安全的问题。 该怎么解决上面例子中的多线程安全问题呢？如果上述例子的实现源代码不能更改，那么就需要在调用这些接口的程序中，增加线程同步的措施。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">synchronized (circleObject) {</span></div><div class="token-line"><span class="token plain">        double radius = circleObject.getRadius();</span></div><div class="token-line"><span class="token plain">        // do something with the radius.</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>遗憾的是，在调用层面解决线程同步问题的办法，并不总是显而易见的。不论多么资深的程序员，都有可能疏漏、忘记或者没有正确地解决好线程同步的问题。</p><p>所以，通常地，为了更皮实的接口设计，在接口规范设计的时候，就应该考虑解决掉线程同步的问题。比如说，我们可以把上面案例中的代码改成线程安全的代码。对于<strong>Circle</strong>类，只需要把它的公开方法都设置成同步方法，那么这个类就是多线程安全的了。具体的实现，请参考下面的代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package co.ivi.jus.record.former;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public final class Circle implements Shape {</span></div><div class="token-line"><span class="token plain">        private double radius;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public Circle(double radius) {</span></div><div class="token-line"><span class="token plain">            this.radius = radius;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public synchronized double getArea() {</span></div><div class="token-line"><span class="token plain">            return Math.PI * radius * radius;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public synchronized double getRadius() {</span></div><div class="token-line"><span class="token plain">            return radius;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public synchronized void setRadius(double radius) {</span></div><div class="token-line"><span class="token plain">            this.radius = radius;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可是，线程同步并不是免费的午餐。代价有多大呢？我做了一个简单的性能基准测试，哪怕最简单的同步，比如上面代码里同步的<strong>getRadius</strong>方法，它的吞吐量损失也有十数倍。这相当于说，如果没有同步的应用需要一台机器支持的话，加了同步的应用就需要十多台机器来支撑相同的业务量。</p><p>这样的代价就有点大了，我们需要寻找更好的办法来解决多线程安全的问题。最有效的办法，就是在接口设计的时候，争取做到即使不使用线程同步，也能做到多线程安全。这说起来还是有点难以理解的，我们还是来看看代码吧。</p><p>下面的代码，是一个修改过的<strong>Circle</strong>类实现。在这个实现里，圆形的对象一旦实例化，就不能再修改它的半径了。相应地，我们删除了设置半径的方法。也就是说，这个对象是一个只读的对象，不支持修改。通常地，我们称这样的对象为不可变对象。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package co.ivi.jus.record.immute;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public final class Circle implements Shape {</span></div><div class="token-line"><span class="token plain">        public final double radius;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public Circle(double radius) {</span></div><div class="token-line"><span class="token plain">            this.radius = radius;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public double area() {</span></div><div class="token-line"><span class="token plain">            return Math.PI * radius * radius;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>对于只读的圆形类的设计，我们可以看到两个好处。</p><p>第一个好处，就是天生的多线程安全。因为这个类的对象，一旦实例化就不能再修改，所以即便在多线程环境下使用，也不需要同步。而不可变对象所承载的数据，比如上面例子中圆形的半径，就是我们前面所说的不可变的数据。这个不可变，是有一个界定范围的。这个界定范围，就是它所在对象的生命周期。如果跳出了对象的生命周期，我们可以重新生成新对象，从而实现数据的变化。</p><p>第二个好处，就是简化的代码。只读对象的设计，使得我们可以重新考虑代码的设计，这是代码简化的来源。你可能已经注意到了，在这个实现里，我们还删除了读取半径的方法。取而代之的，是公开的半径这个变量。这就是一个最直接的简化。</p><p>应用程序可以直接读取这个变量，而不是通过一个类似于getRadius的方法。由于半径这个变量被声明为final变量，所以它只可以被读取，不能被修改。这并没有破坏对象的只读性。</p><p>不过，乍看之下，这样的设计似乎破坏了面向对象编程的封装原则。公开半径变量radius，相当于公开的实现细节。如果我们改变主意，想使用直径来表示一个圆形，那么实现的修改就会显得很丑陋。</p><p>可是，如果我们认真思考一下几个简单的问题，对于封装的顾虑可能就降低很多了。比如说，使用直径来表示一个圆，这是一个真实的需求吗？ 这是一个必需的表达方式吗？未来的圆，会不会变得没法使用半径来表达？其实不是的，未来的圆，还是可以用半径来表达的。使用其他的办法，比如直径，来表达一个圆，其实并没有必要。</p><p>所以，公开半径这个只读变量，并没有带来违反封装原则的实质性后果。而且，从另外一个角度来看，我们可以把读取这个只读变量的操作，看成是等价的读取方法的调用。不过，虽然很多人，包括我自己，倾向于这样解读，但是这总归是一个有争议的形式。</p><h2 id="进一步的简化"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/03#进一步的简化"><span class="icon icon-link"></span></a>进一步的简化</h2><p>还有没有进一步简化的空间呢？我们再来看看不可变的正方形<strong>Square</strong>类的设计。具体的实现，请参考下面的代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package co.ivi.jus.record.immute;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public final class Square implements Shape {</span></div><div class="token-line"><span class="token plain">        public final double side;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public Square(double side) {</span></div><div class="token-line"><span class="token plain">            this.side = side;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public double area() {</span></div><div class="token-line"><span class="token plain">            return side * side;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果比较一下不可变的圆形Circle类和正方形Square类的源代码，你有没有发现这两个类的代码有惊人的相似点？</p><p>第一个相似的地方，就是使用公开的只读变量（使用final修饰符来声明只读变量）。Circle类的变量<strong>radius</strong>，和Square类的变量<strong>side</strong>，都是公开的只读的变量。这样的声明，是为了公开变量的只读性。</p><p>第二个相似的地方，就是公开的只读变量，需要在构造方法中赋值，而且只在构造方法中赋值，且这样的构造方法还是公开的方法。Circle类的构造方法给<strong>radius</strong>变量赋值，Square类的构造方法给<strong>side</strong>变量赋值。这样的构造方法，解决了对象的初始化问题。</p><p>第三个相似的地方，就是没有了读取的方法；公开的只读变量，替换了掉了公开的读取方法。这样的变化，使得代码量总体变少了。</p><p>这么多相似的地方，相似的代码，能不能进一步地简化呢？我知道，你可能已经开始思考这样的问题了。</p><p>对于这个问题，Java的答案，就是使用档案类。</p><h2 id="怎么声明档案类"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/03#怎么声明档案类"><span class="icon icon-link"></span></a>怎么声明档案类</h2><p>我们前面说过，Java档案类是用来表示不可变数据的透明载体。那么，怎么使用档案类来表示不可变数据呢？</p><p>我们还是一起先来看看代码吧。咱们试着把上面不可变的圆形Circle普通的类改成档案类，来感受下档案类到底是什么模样的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package co.ivi.jus.record.modern;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public record Circle(double radius) implements Shape {</span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public double area() {</span></div><div class="token-line"><span class="token plain">            return Math.PI * radius * radius;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>看到这样的代码，是不是有点出乎意料？你可以对比一下不可变的Circle类的代码，感受一下这两者之间的差异。</p><p>首先，最常见的class关键字不见了，取而代之的是record关键字。record关键字是class关键字的一种特殊表现形式，用来标识档案类。record关键字可以使用和class关键字差不多一样的类修饰符（比如public、static等；但是也有一些例外，我们后面再说）。</p><p>然后，类标识符Circle后面，有用小括号括起来的参数。类标识符和参数一起看，就像是一个构造方法。事实上，这样的表现方式，的确可以看成是构造方法。而且，这种形式，还就是当作构造方法使用的。比如下面的代码，就是使用构造方法的形式来生成Circle档案类实例的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Circle circle = new Circle(10.0);</span></div></pre></div><p>最后，在大括号里，也就是档案类的实现代码里，变量的声明没有了，构造方法也没有了。前面我们已经知道怎么生成一个档案类实例了，但还有一个问题是，我们能读取这个圆形档案类的半径吗？</p><p>其实，类标识符声明后面的小括号里的参数，就是等价的不可变变量。在档案类里，这样的不可变变量是私有的变量，我们不可以直接使用它们。但是我们可以通过等价的方法来调用它们。变量的标识符就是等价方法的标识符。比如下面的代码，就是一个读取上面圆形档案类半径的代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">double radius = circle.radius();</span></div></pre></div><p>是的，在档案类里，方法调用的形式又回来了。我们前面讨论过打破封装原则的顾虑，你可能还是没有足够的信心去接受不完整的封装形式。那么现在，档案类的调用形式依然保持着良好的封装形式。打破封装原则的顾虑也就不复存在了。</p><p>需要注意的是，由于档案类表示的是不可变数据，除了构造方法之外，并没有给不可变变量赋值的方法。</p><h2 id="意料之外的改进"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/03#意料之外的改进"><span class="icon icon-link"></span></a>意料之外的改进</h2><p>上面，通过传统Circle类和档案Circle类代码的对比，我们可以感受到档案类在简化代码、提高生产力方面的努力。如果说，上面这些简化，还在我的预料之内的话；下面的简化，我刚看到的时候，是很惊喜的：“哇，这真是太奇妙了！”</p><p>我们还是通过代码来体验一下这种感受。如果我们生成两个半径为10厘米的圆形的实例，这两个实例是相等的吗？下面的代码，就是用来验证我们猜想的。你可以试着运行一下，看看和你猜想的结果是不是一样的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package co.ivi.jus.record;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import co.ivi.jus.record.immute.Circle;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class ImmuteUseCases {</span></div><div class="token-line"><span class="token plain">        public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">            Circle c1 = new Circle(10.0);</span></div><div class="token-line"><span class="token plain">            Circle c2 = new Circle(10.0);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;Equals? &quot; + c1.equals(c2));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面的代码里，使用了我们开篇案例分析中的传统Circle类。运行结果告诉我们，两个半径为10厘米的圆形的实例，并不是相等的实例。我想这应该在你的预料之内。</p><p>如果需要比较两个实例是不是相等，我们需要重写equals方法和hashCode方法。如果需要把实例转换成肉眼可以阅读的信息，我们需要重写toString方法。我们上面案例分析的代码中，这些方法都没有重写，因此对应的操作结果也是不可预测的。</p><p>当然，如果没有遗忘，我们可以添加这三个方法的重写实现。然而，这三个方法的重写，尤其是equals方法和hashCode方法的重写实现，一直是代码安全的重灾区。即便是经验丰富的程序员，也可能忘记重写这三个方法；就算没有遗忘，equals方法和hashCode方法也可能没有正确实现，从而带来各种各样的问题。这实在难以让人满意，但是一直以来，我们也没有更好的办法。</p><p>档案类会不一样吗？</p><p>我们再来看看使用档案类的代码，结果会不会不一样呢？ 下面的这段代码，Circle的实现使用的是档案类。这段代码运行的结果告诉我们，两个半径为10厘米的圆形的档案类实例，是相等的实例。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package co.ivi.jus.record;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import co.ivi.jus.record.modern.Circle;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class ModernUseCases {</span></div><div class="token-line"><span class="token plain">        public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">            Circle c1 = new Circle(10.0);</span></div><div class="token-line"><span class="token plain">            Circle c2 = new Circle(10.0);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;Equals? &quot; + c1.equals(c2));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>看到这里，你是不是感觉到：哇！ 这真的是太棒了！我们并没有重写这三个方法，它们居然可以使用。</p><p>为什么会这样呢？</p><p>这是因为，档案类内置了缺省的equals方法、hashCode方法以及toString方法的实现。一般情况下，我们就再也不用担心这三个方法的重写问题了。这不仅减少了代码数量，提高了编码的效率；还减少了编码错误，提高了产品的质量。</p><h2 id="不可变的数据"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/03#不可变的数据"><span class="icon icon-link"></span></a>不可变的数据</h2><p>讨论到这里，我们可以回头再看看Java档案类的定义了：Java档案类是用来表示不可变数据的透明载体。“不可变的数据”和“透明的载体”是两个最重要的关键词。</p><p>我们前面讨论了不可变的数据。如果一个Java类一旦实例化就不能再修改，那么用它表述的数据就是不可变数据。Java档案类就是表述不可变数据的。为了强化“不可变”这一原则，避免面向对象设计的陷阱，Java档案类还做了以下的限制：</p><ol><li>Java档案类不支持扩展子句，用户不能定制它的父类。隐含的，它的父类是java.lang.Record。父类不能定制，也就意味着我们不能通过修改父类来影响Java档案的行为。</li><li>Java档案类是个终极（final）类，不支持子类，也不能是抽象类。没有子类，也就意味着我们不能通过修改子类来改变Java档案的行为。</li><li>Java档案类声明的变量是不可变的变量。这就是我们前面反复强调的，一旦实例化就不能再修改的关键所在。</li><li>Java档案类不能声明可变的变量，也不能支持实例初始化的方法。这就保证了，我们只能使用档案类形式的构造方法，避免额外的初始化对可变性的影响。</li><li>Java档案类不能声明本地（native）方法。如果允许了本地方法，也就意味着打开了修改不可变变量的后门。</li></ol><p>通常地，我们把Java档案类看成是一种特殊形式的Java类。除了上述的限制，Java档案类和普通类的用法是一样的。</p><h2 id="透明的载体"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/03#透明的载体"><span class="icon icon-link"></span></a>透明的载体</h2><p>好了，聊完“不可变的数据”，接下来该聊聊“透明的载体”了。</p><p>陆陆续续地，我们在前面提到过，档案类内置了下面的这些方法缺省实现：</p><ul><li>构造方法</li><li>equals方法</li><li>hashCode方法</li><li>toString方法</li><li>不可变数据的读取方法</li></ul><p>如果你注意到的话，我们使用了“缺省”这样的字眼。换一种说法，我们可以使用缺省的实现，也可以替换掉缺省的实现。下面的代码，就是我们试图替换掉缺省实现的尝试。请注意，除了构造方法，其他的替换方法都可以使用<strong>Override</strong>注解来标注（如果你读过<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/intro/100019601">《代码精进之路》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，你就会倾向于总是使用<strong>Override</strong>注解的）。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package co.ivi.jus.record.explicit;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import java.util.Objects;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public record Circle(double radius) implements Shape {</span></div><div class="token-line"><span class="token plain">        public Circle(double radius) {</span></div><div class="token-line"><span class="token plain">            this.radius = radius;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public double area() {</span></div><div class="token-line"><span class="token plain">            return Math.PI * radius * radius;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public boolean equals(Object o) {</span></div><div class="token-line"><span class="token plain">            if (this == o) {</span></div><div class="token-line"><span class="token plain">                return true;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">            if (o instanceof Circle other) {</span></div><div class="token-line"><span class="token plain">                return other.radius == this.radius;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            return false;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public int hashCode() {</span></div><div class="token-line"><span class="token plain">            return Objects.hash(radius);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public String toString() {</span></div><div class="token-line"><span class="token plain">            return String.format(&quot;Circle[radius=%f]&quot;, radius);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public double radius() {</span></div><div class="token-line"><span class="token plain">            return this.radius;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>到这里，你应该明白了“透明的载体”的意思了。透明载体的意思，通俗地说，就是档案类承载有缺省实现的方法，这些方法可以直接使用，也可以替换掉。</p><p>不过，像上面这样的替换，除了徒增烦恼，是没有实际意义的。那我们什么时候需要替换掉缺省实现呢？</p><h2 id="重写构造方法"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/03#重写构造方法"><span class="icon icon-link"></span></a>重写构造方法</h2><p>最常见的替换，是要在构造方法里对档案类声明的变量添加必要的检查。比如说，我们现实生活中看到的各种各样的圆形，它的半径都不会是负数。如果在这样的场景里来讨论圆形，那么表示圆形的类的半径就不应该是负数。</p><p>你应该已经意识到了，我们上面的代码，在实例化的时候，都没有检查半径的数值，包括档案类缺省的构造方法。那么这时候，我们就要替换掉缺省的构造方法。下面的代码，就是一种替换的方法。如果，构造实例的时候，半径的数值为负，构造就会抛出运行时异常<strong>IllegalArgumentException</strong>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package co.ivi.jus.record.improved;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public record Circle(double radius) implements Shape {</span></div><div class="token-line"><span class="token plain">        public Circle {</span></div><div class="token-line"><span class="token plain">            if (radius &lt; 0) {</span></div><div class="token-line"><span class="token plain">                throw new IllegalArgumentException(</span></div><div class="token-line"><span class="token plain">                    &quot;The radius of a circle cannot be negative [&quot; + radius + &quot;]&quot;);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public double area() {</span></div><div class="token-line"><span class="token plain">            return Math.PI * radius * radius;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果你阅读了上面的代码，应该已经注意到了一点不太常规的形式。构造方法的声明没有参数，也没有给实例变量赋值的语句。这并不是说，构造方法就没有参数，或者实例变量不需要赋值。实际上，为了简化代码，Java编译的时候，已经替我们把这些东西加上去了。所以，不论哪一种编码形式，构造方法的调用都是没有区别的。</p><p>在上一个例子中，我们已经看到了构造方法的常规形式。在下面这张表里，我列出了两种构造方法形式上的差异，你可以看看它们的差异。</p><h1 id=""><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/03"><span class="icon icon-link"></span></a><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage87488709d08e5545bd64b954e1b810603c48.a8db17aa.jpg" alt="图片"/></h1><h2 id="重写equals方法"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/03#重写equals方法"><span class="icon icon-link"></span></a>重写equals方法</h2><p>还有一类常见的替换，如果缺省的equals方法或者hashCode方法不能正常工作或者存在安全的问题，就需要替换掉缺省的方法。</p><p>如果声明的不可变变量没有重写equals方法和hashCode方法，那么这个档案类的equals方法和hashCode方法的行为就可能不是可以预测的。比如，如果不可变的变量是一个数组，通过下面的例子，我们来看看它的equals方法能不能正常工作。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">jshell&gt; record Password(byte[] password) {}；</span></div><div class="token-line"><span class="token plain">    |  modified record Password</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    jshell&gt; Password pA = new Password(&quot;123456&quot;.getBytes());</span></div><div class="token-line"><span class="token plain">    pA ==&gt; Password[password=[B@2ef1e4fa]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    jshell&gt; Password pB = new Password(&quot;123456&quot;.getBytes());</span></div><div class="token-line"><span class="token plain">    pB ==&gt; Password[password=[B@b81eda8]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    jshell&gt; pA.equals(pB);</span></div><div class="token-line"><span class="token plain">    $16 ==&gt; false</span></div></pre></div><p>这个例子里，我们设计了一个口令的档案类，其中的口令使用字节数组来存放。我们使用同样的口令，生成了两个不同的实例。然后，我们调用equals方法，来比较这两个实例。</p><p>运算的结果显示，这两个实例并不相等。这不是我们期望的结果。其中的原因，就是因为数组这个变量的equals方法并不能正常工作（或者换个说法，数组变量没有重写equals方法）。</p><p>如果把变量的类型换成重写了equals方法的字符串String，我们就能看到预期的结果了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">jshell&gt; record Password(String password) {};</span></div><div class="token-line"><span class="token plain">    |  created record Password</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    jshell&gt; Password pA = new Password(&quot;123456&quot;);</span></div><div class="token-line"><span class="token plain">    pA ==&gt; Password[password=123456]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    jshell&gt; Password pB = new Password(&quot;123456&quot;);</span></div><div class="token-line"><span class="token plain">    pB ==&gt; Password[password=123456]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    jshell&gt; pA.equals(pB);</span></div><div class="token-line"><span class="token plain">    $5 ==&gt; true</span></div></pre></div><p>一般情况下，equals方法和hashCode方法是成双成对的，实现逻辑上需要匹配。所以，当我们重写equals方法的时候，一般也需要重写hashCode方法；反之亦然。</p><h2 id="不推荐的重写"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/03#不推荐的重写"><span class="icon icon-link"></span></a>不推荐的重写</h2><p>为了更个性化的显示，我们有时候也需要重写toString方法。但是，我们通常不建议重写不可变数据的读取方法。因为，这样的重写往往意味着需要变更缺省的不可变数值，从而打破实例的状态，进而造成许多无法预料的、让人费解的后果。</p><p>比如说，我们设想定义一个数，如果是负值的话，我们希望读取的是它的相反数。下面的例子，就是一个味道很坏的示范。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">jshell&gt; record Number(int x) {</span></div><div class="token-line"><span class="token plain">       ...&gt;     public int x() {</span></div><div class="token-line"><span class="token plain">       ...&gt;         return x &gt; 0 ? x : (-1) * x;</span></div><div class="token-line"><span class="token plain">       ...&gt;     }</span></div><div class="token-line"><span class="token plain">       ...&gt; }</span></div><div class="token-line"><span class="token plain">    |  created record Number</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    jshell&gt; Number n = new Number(-1);</span></div><div class="token-line"><span class="token plain">    n ==&gt; Number[x=-1]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    jshell&gt; n.x();</span></div><div class="token-line"><span class="token plain">    $9 ==&gt; 1</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    jshell&gt; Number m = new Number(n.x());</span></div><div class="token-line"><span class="token plain">    m ==&gt; Number[x=1]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    jshell&gt; m.equals(n);</span></div><div class="token-line"><span class="token plain">    $11 ==&gt; false</span></div></pre></div><p>在这个例子里，我们重写了读取的方法。如果一个数是负数，重写的读取就返回它的相反数。读取出来的数据，并不是实例化的时候赋于的数据。这让代码变得难以理解，很容易出错。</p><p>更严重的问题是，这样的重写不再能够支持实例的拷贝。比如说，我们把实例n拷贝到另一个实例m。这两个实例按照道理来说应该相等。而由于重写了读取的方法，实际的结果，这两个实例是不相等的。这样的结果，也可能会使代码容易出错，而且难以调试。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/03#总结"><span class="icon icon-link"></span></a>总结</h2><p>好，今天就到这里，我来做个小结。从前面的讨论中，我们了解到，Java档案类是用来表示不可变数据的透明载体，用来简化不可变数据的表达，提高编码效率，降低编码错误。同时，我们也讨论了使用档案类的几个容易忽略的陷阱。</p><p>在我们日常的接口设计和编码实践中，为了最大化的性能，我们应该优先考虑使用不可变的对象（数据）；如果一个类是用来表述不可变的对象（数据），我们应该优先使用Java档案类。</p><p>如果要丰富你的代码评审清单，有了封闭类后，你可以加入下面这一条：</p><blockquote><p>一个类，如果是用来表述不可变的数据，能不能使用Java档案类？</p></blockquote><p>另外，通过今天的讨论，我拎出几个技术要点，这些都可能在你们面试中出现哦，通过学习，你应该能够：</p><ul><li>知道Java支持档案类，并且能够有意识地使用档案类，提高编码效率，降低编码错误；<ul><li>面试问题：你知道档案类吗？会不会使用它？</li></ul></li><li>了解档案类的原理和它要解决的问题，知道使用不可变的对象优势；<ul><li>面试问题：什么情况下可以使用档案类，什么情况下不能使用档案类？</li></ul></li><li>了解档案类的缺省方法，掌握缺省方法的好处和不足，知道什么时候要重写这些方法。<ul><li>面试问题：使用档案类应该注意什么问题？</li></ul></li></ul><p>如果你能够有意识地使用不可变的对象以及档案类，并且有能力规避掉其中的陷阱，你应该能够大幅度提高编码的效率和质量。毫无疑问，在面试的时候，这也是一个能够让你脱颖而出的知识点。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/03#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>在重写equals方法这一小节里，我们讨论了数组类型的不可变数据。我们已经知道了，这样的数据类型，需要重写equals方法和hashCode方法。其实，toString()的方法也需要重写。今天的思考题，就是请你实现这些方法的重写。</p><p>方便起见，我们假设这个数组是字节数组，用来表示社会保障号。我们都知道，社会保障号是高度敏感的信息，不能被泄漏，也不能被盗取。你来想一想，有哪些方法需要重写？为什么？代码看起来是什么样子的？有难以克服的困难吗？</p><p>我开个头，写一个空白的档案类，你来把你想添加的代码补齐。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">record SocialSecurityNumber(byte[] ssn) {</span></div><div class="token-line"><span class="token plain">      // Here is your code.</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>欢迎你在留言区留言、讨论，分享你的阅读体验以及对这些问题的思考。</p><p>注：本文使用的完整的代码可以从<a target="_blank" rel="noopener noreferrer" href="https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/sealed">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>下载，你可以通过修改<a target="_blank" rel="noopener noreferrer" href="https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/sealed">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上<a target="_blank" rel="noopener noreferrer" href="https://github.com/XueleiFan/java-up/blob/main/src/main/java/co/ivi/jus/record/review/xuelei/SocialSecurityNumber.java">review template<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>代码，完成这次的思考题。如果你想要分享你的修改或者想听听评审的意见，请提交一个 GitHub的拉取请求（Pull Request），并把拉取请求的地址贴到留言里。这一小节的拉取请求代码，请在<a target="_blank" rel="noopener noreferrer" href="https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/record/review">档案类专用的代码评审目录<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>下，建一个以你的名字命名的子目录，代码放到你专有的子目录里。比如，我的代码，就放在record/review/xuelei的目录下面。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/深入剖析java新特性/02.提升编码效率/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:06:36</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-java/umi.fde43fdb.js"></script>
  </body>
</html>
