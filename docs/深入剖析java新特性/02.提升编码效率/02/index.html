<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-java/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-java";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>02 | 文字块：怎么编写所见即所得的字符串？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/深入剖析java新特性/02.提升编码效率/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a aria-current="page" class="active" href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a aria-current="page" class="active" href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入剖析java新特性/01.开篇词">01.开篇词</a><ul><li><a href="/blog-java/深入剖析java新特性/01.开篇词/01"><span>开篇词 | 拥抱Java新特性，像设计者一样工作和思考</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-java/深入剖析java新特性/02.提升编码效率">02.提升编码效率</a><ul><li><a href="/blog-java/深入剖析java新特性/02.提升编码效率/01"><span>01 | JShell：怎么快速验证简单的小问题？</span></a></li><li><a aria-current="page" class="active" href="/blog-java/深入剖析java新特性/02.提升编码效率/02"><span>02 | 文字块：怎么编写所见即所得的字符串？</span></a></li><li><a href="/blog-java/深入剖析java新特性/02.提升编码效率/03"><span>03 | 档案类：怎么精简地表达不可变数据？</span></a></li><li><a href="/blog-java/深入剖析java新特性/02.提升编码效率/04"><span>04 | 封闭类：怎么刹住失控的扩展性？</span></a></li><li><a href="/blog-java/深入剖析java新特性/02.提升编码效率/05"><span>05 | 类型匹配：怎么切除臃肿的强制转换？</span></a></li><li><a href="/blog-java/深入剖析java新特性/02.提升编码效率/06"><span>06 | switch表达式：怎么简化多情景操作？</span></a></li><li><a href="/blog-java/深入剖析java新特性/02.提升编码效率/07"><span>07 | switch匹配：能不能适配不同的类型？</span></a></li></ul></li><li><a href="/blog-java/深入剖析java新特性/03.提升代码性能">03.提升代码性能</a><ul><li><a href="/blog-java/深入剖析java新特性/03.提升代码性能/01"><span>08 | 抛出异常，是不是错误处理的第一选择？</span></a></li><li><a href="/blog-java/深入剖析java新特性/03.提升代码性能/02"><span>09 | 异常恢复，付出的代价能不能少一点？</span></a></li><li><a href="/blog-java/深入剖析java新特性/03.提升代码性能/03"><span>10 | Flow，是异步编程的终极选择吗？</span></a></li><li><a href="/blog-java/深入剖析java新特性/03.提升代码性能/04"><span>11 | 矢量运算：Java的机器学习要来了吗？</span></a></li><li><a href="/blog-java/深入剖析java新特性/03.提升代码性能/05"><span>12 | 外部内存接口：零拷贝的障碍还有多少？</span></a></li><li><a href="/blog-java/深入剖析java新特性/03.提升代码性能/06"><span>13 | 外部函数接口，能不能取代Java本地接口？</span></a></li></ul></li><li><a href="/blog-java/深入剖析java新特性/04.降低维护难度">04.降低维护难度</a><ul><li><a href="/blog-java/深入剖析java新特性/04.降低维护难度/01"><span>14 | 禁止空指针，该怎么避免崩溃的空指针？</span></a></li><li><a href="/blog-java/深入剖析java新特性/04.降低维护难度/02"><span>15 | 现代密码：你用的加密算法过时了吗？</span></a></li><li><a href="/blog-java/深入剖析java新特性/04.降低维护难度/03"><span>16 | 改进的废弃，怎么避免使用废弃的特性？</span></a></li><li><a href="/blog-java/深入剖析java新特性/04.降低维护难度/04"><span>17 | 模块系统：为什么Java需要模块化？</span></a></li><li><a href="/blog-java/深入剖析java新特性/04.降低维护难度/05"><span>18 | 模块系统：怎么模块化你的应用程序？</span></a></li></ul></li><li><a href="/blog-java/深入剖析java新特性/05.结束语">05.结束语</a><ul><li><a href="/blog-java/深入剖析java新特性/05.结束语/01"><span>期末测试｜来赴一场满分之约！</span></a></li><li><a href="/blog-java/深入剖析java新特性/05.结束语/02"><span>结束语 | Java的未来，依然是星辰大海</span></a></li></ul></li><li><a href="/blog-java/深入剖析java新特性/06.特别放送">06.特别放送</a><ul><li><a href="/blog-java/深入剖析java新特性/06.特别放送/01"><span>用户故事 | 保持好奇心，积极拥抱变化</span></a></li><li><a href="/blog-java/深入剖析java新特性/06.特别放送/02"><span>用户故事 | 与新特性开发者对话</span></a></li></ul></li><li><a href="/blog-java/深入剖析java新特性/summary">深入剖析java新特性</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="阅读案例" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/02#阅读案例"><span>阅读案例</span></a></li><li title="所见即所得的文字块" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/02#所见即所得的文字块"><span>所见即所得的文字块</span></a></li><li title="文字块的编译过程" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/02#文字块的编译过程"><span>文字块的编译过程</span></a></li><li title="巧妙的结束分隔符" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/02#巧妙的结束分隔符"><span>巧妙的结束分隔符</span></a></li><li title="尾部空格还能回来吗？" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/02#尾部空格还能回来吗"><span>尾部空格还能回来吗？</span></a></li><li title="该怎么表达长段落？" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/02#该怎么表达长段落"><span>该怎么表达长段落？</span></a></li><li title="总结" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/02#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-java/深入剖析java新特性/02.提升编码效率/02#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="02--文字块怎么编写所见即所得的字符串"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/02#02--文字块怎么编写所见即所得的字符串"><span class="icon icon-link"></span></a>02 | 文字块：怎么编写所见即所得的字符串？</h1><p>你好，我是范学雷。今天，我们聊一聊Java的文字块（text blocks）。</p><p>文字块这个特性，首先在JDK 13中以预览版的形式发布。在JDK 14中，改进的文字块再次以预览版的形式发布。最后，文字块在JDK 15正式发布。</p><p>文字块的概念很简单，它是一个由多行文字构成的字符串。既然是字符串，为什么还需要文字块这个新概念呢？文字块和字符串又有什么区别呢？我们还是通过案例和代码，来弄清楚这些问题吧。</p><h2 id="阅读案例"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/02#阅读案例"><span class="icon icon-link"></span></a>阅读案例</h2><p>我们在编写代码的时候，总是或多或少地要和字符串打交道。有些字符串很简单，比如我们都知道的&quot;Hello，World！&quot;字符串。有些字符串很复杂，里面可能有换行、对齐、转义字符、占位符、连接符等。</p><p>比如下面的例子中，我们要构造一个简单的表示&quot;Hello，World！&quot;的HTML字符串，就需要处理好文本对齐、换行字符、连接符以及双引号的转义字符。这就使得这段代码既不美观、也不简约，一点都不自然。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">String stringBlock =</span></div><div class="token-line"><span class="token plain">            &quot;&lt;!DOCTYPE html&gt;\n&quot; +</span></div><div class="token-line"><span class="token plain">            &quot;&lt;html&gt;\n&quot; +</span></div><div class="token-line"><span class="token plain">            &quot;    &lt;body&gt;\n&quot; +</span></div><div class="token-line"><span class="token plain">            &quot;        &lt;h1&gt;\&quot;Hello World!\&quot;&lt;/h1&gt;\n&quot; +</span></div><div class="token-line"><span class="token plain">            &quot;    &lt;/body&gt;\n&quot; +</span></div><div class="token-line"><span class="token plain">            &quot;&lt;/html&gt;\n&quot;;</span></div></pre></div><p>这样的字符串不好写，不好看，也不好读。更糟糕的是，我们有时候需要从别的地方拷贝一段 HTML 或者 SQL 语句，然后再转换成类似于上面的字符串。是不是出力多，收效少，需要特别的耐心？遗憾的是，这样的工作还特别多，HTML, SQL, XML, JSON, HTTP, 随便就可以列一大堆。</p><p>不论对于写代码的人，还是阅读代码的人来说，处理这样的字符串都不是一件赏心悦目的事情。软件的质量是一个反馈系统，糟糕的事情总是可以让事情变得更糟糕。摊开来说，这样的字符串编写起来不省心，不仅消耗了更多时间，代码质量也没有保障。与此同时，复杂的语句也容易分散评审者的精力，让疏漏和错误不易被发现。</p><p>费时费力、质量还难以控制，这让复杂字符串的处理变成了一个很没有效率的事情。没有效率，也就意味着投入产出比低，所以我们就更不愿意投入精力和时间来做好这件事情。对于用户来说，糟糕的结果也会耗费他们更多的精力和时间。用户有多少，这个糟糕的成本就放大多少倍。</p><p>如果你经常需要阅读调试日志，你可能会有更深刻的体会。难以阅读的调试日志，可能会让你产生短暂的抗拒心理，甚至暂时地放弃调试，直到你的耐心又回来了。遗憾的是，提高调试日志的可读性，似乎永远排不上开发者的日程表。</p><p>这不是一个让人愉快的事情。不过，我们似乎也不曾有过更好的办法。</p><h2 id="所见即所得的文字块"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/02#所见即所得的文字块"><span class="icon icon-link"></span></a>所见即所得的文字块</h2><p>文字块是人们在试图扭转这种糟糕局面的过程中一个最重要的尝试。文字块是一个由多行文字构成的字符串。既然是字符串，文字块能有什么影响呢？其实，文字块是使用一个新的形式，而不是传统的形式，来表达字符串的。通过这个新的形式，文字块尝试消除换行、连接符、转义字符的影响，使得文字对齐和必要的占位符更加清晰，从而简化多行文字字符串的表达。</p><p>下面的这段代码，就是我使用文字块对阅读案例所做的改进。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">String textBlock = &quot;&quot;&quot;</span></div><div class="token-line"><span class="token plain">            &lt;!DOCTYPE html&gt;</span></div><div class="token-line"><span class="token plain">            &lt;html&gt;</span></div><div class="token-line"><span class="token plain">                &lt;body&gt;</span></div><div class="token-line"><span class="token plain">                    &lt;h1&gt;&quot;Hello World!&quot;&lt;/h1&gt;</span></div><div class="token-line"><span class="token plain">                &lt;/body&gt;</span></div><div class="token-line"><span class="token plain">            &lt;/html&gt;</span></div><div class="token-line"><span class="token plain">            &quot;&quot;&quot;;</span></div><div class="token-line"><span class="token plain">    System.out.println(</span></div><div class="token-line"><span class="token plain">            &quot;Here is the text block:\n&quot; + textBlock);</span></div></pre></div><p>对比一下阅读案例里的代码，我们可以看到，下面的这些特殊的字符从这个表达式里消失了：</p><ol><li>换行字符（\n）没有出现在文字块里；</li><li>连接字符（+）没有出现在文字块里；</li><li>双引号没有使用转义字符（\）。</li></ol><p>另外，出现在文字块开始和结束位置的，是三个双引号序列；而不是我们在字符串声明里看到的单个双引号。 <strong>文字块由零个或多个内容字符组成，从开始分隔符开始，到结束分隔符结束。开始分隔符是由三个双引号字符 (“”“) ，后面跟着的零个或多个空格，以及行结束符组成的序列。结束分隔符是一个由三个双引号字符 (”“”)组成的序列。</strong></p><p>**需要注意的是，开始分隔符必须单独成行；三个双引号字符后面的空格和换行符都属于开始分隔符。**所以，一个文字块至少有两行代码。即使是一个空字符，结束分隔符也不能和开始分隔符放在同一行代码里。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">jshell&gt; String s = &quot;&quot;&quot;&quot;&quot;&quot;;</span></div><div class="token-line"><span class="token plain">    |  Error:</span></div><div class="token-line"><span class="token plain">    |  illegal text block open delimiter sequence, missing line terminator</span></div><div class="token-line"><span class="token plain">    |  String s = &quot;&quot;&quot;&quot;&quot;&quot;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    jshell&gt; String s = &quot;&quot;&quot;</span></div><div class="token-line"><span class="token plain">       ...&gt; &quot;&quot;&quot;;</span></div><div class="token-line"><span class="token plain">    s ==&gt; &quot;&quot;</span></div></pre></div><p>同样需要注意的是，<strong>结束分隔符只有一个由三个双引号字符<strong><strong>组成的</strong></strong>序列。结束分隔符之前的字符，包括换行符，都属于文字块的有效内容。</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">jshell&gt; String s = &quot;&quot;&quot;</span></div><div class="token-line"><span class="token plain">       ...&gt; OneLine&quot;&quot;&quot;;</span></div><div class="token-line"><span class="token plain">    s ==&gt; &quot;OneLine&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    jshell&gt; String s = &quot;&quot;&quot;</span></div><div class="token-line"><span class="token plain">       ...&gt; TwoLines</span></div><div class="token-line"><span class="token plain">       ...&gt; &quot;&quot;&quot;;</span></div><div class="token-line"><span class="token plain">    s ==&gt; &quot;TwoLines\n&quot;</span></div></pre></div><p>由于文字块不再需要特殊字符、开始分隔符和结束分隔符这些格式安排，我们几乎就可以直接拷贝、粘贴看到的文字，而不再需要特殊的处理了。同样地，你在代码里看到的文字块是什么样子，它实际要表达的文字就是什么样子的。这也就是说，“所见即所得”。</p><p>很多系统里常见的“所见即所得”的境界，终于也能够在Java语言里呈现出来了。</p><h2 id="文字块的编译过程"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/02#文字块的编译过程"><span class="icon icon-link"></span></a>文字块的编译过程</h2><p>那么，我们用文字块改进过的阅读案例，打印结果是什么样子的呢？从下面的打印结果，我们可以看到，为了代码整洁而使用的缩进空格并没有出现在打印的结果里。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Here is the text block:</span></div><div class="token-line"><span class="token plain">    &lt;!DOCTYPE html&gt;</span></div><div class="token-line"><span class="token plain">    &lt;html&gt;</span></div><div class="token-line"><span class="token plain">        &lt;body&gt;</span></div><div class="token-line"><span class="token plain">            &lt;h1&gt;&quot;Hello World!&quot;&lt;/h1&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/body&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/html&gt;</span></div></pre></div><p>也就是说，文字块的内容并没有计入缩进空格。文字块是怎么处理缩进空格的呢？这是我们学习文字块必须要了解的一个问题。</p><p>像传统的字符串一样，文字块是字符串的一种常量表达式。<strong>不同于传统字符串的是，在编译期，文字块要顺序通过如下三个不同的编译步骤：</strong></p><ol><li><strong>为了降低不同平台间换行符的表达差异，编译器把文字内容里的换行符统一转换成 LF（\u000A）；</strong></li><li><strong>为了能够处理Java源代码里的缩进空格，要删除所有文字内容行和结束分隔符共享的前导空格，以及所有文字内容行的尾部空格；</strong></li><li><strong>最后处理转义字符，这样开发人员编写的转义序列就不会在第一步和第二步被修改或删除。</strong></li></ol><p>首先，我们从整体上来理解一下文字块的编译期处理这种方式。阅读一下下面的代码，你能不能预测一下下面这两个问题的结果？使用传统方式声明的字符串和使用文字块声明的字符串的内容是一样的吗？这两个字符串变量指向的是同一个对象，还是不同的对象？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package co.ivi.jus.text.modern;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class TextBlocks {</span></div><div class="token-line"><span class="token plain">        public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">            String stringBlock =</span></div><div class="token-line"><span class="token plain">                    &quot;&lt;!DOCTYPE html&gt;\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;&lt;html&gt;\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;    &lt;body&gt;\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;        &lt;h1&gt;\&quot;Hello World!\&quot;&lt;/h1&gt;\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;    &lt;/body&gt;\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;&lt;/html&gt;\n&quot;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            String textBlock = &quot;&quot;&quot;</span></div><div class="token-line"><span class="token plain">                    &lt;!DOCTYPE html&gt;</span></div><div class="token-line"><span class="token plain">                    &lt;html&gt;</span></div><div class="token-line"><span class="token plain">                        &lt;body&gt;</span></div><div class="token-line"><span class="token plain">                            &lt;h1&gt;&quot;Hello World!&quot;&lt;/h1&gt;</span></div><div class="token-line"><span class="token plain">                        &lt;/body&gt;</span></div><div class="token-line"><span class="token plain">                    &lt;/html&gt;</span></div><div class="token-line"><span class="token plain">                    &quot;&quot;&quot;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            System.out.println(</span></div><div class="token-line"><span class="token plain">                    &quot;Does the text block equal to the regular string? &quot; +</span></div><div class="token-line"><span class="token plain">                    stringBlock.equals(textBlock));</span></div><div class="token-line"><span class="token plain">            System.out.println(</span></div><div class="token-line"><span class="token plain">                    &quot;Does the text block refer to the regular string? &quot; +</span></div><div class="token-line"><span class="token plain">                    (stringBlock == textBlock));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>第一个问题的答案应该没有意外，第二个问题的答案可能就会有意外出现了。使用传统方式声明的字符串和使用文字块声明的字符串，它们的内容是一样的，而且指向的是同一个对象。</p><p>该怎么理解这样的结果呢？其实，这就说明了，文字块是在编译期处理的，并且在编译期被转换成了常量字符串，然后就被当作常规的字符串了。所以，如果文字块代表的内容，和传统字符串代表的内容一样，那么这两个常量字符串变量就指向同一内存地址，代表同一个对象。</p><p>虽然表达形式不同，但是文字块就是字符串。既然是字符串，就能够使用字符串支持的各种API和操作方法。比如，传统的字符串表现形式和文字块的表现形式可以混合使用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">System.out.println(&quot;Here is the text block:\n&quot; +</span></div><div class="token-line"><span class="token plain">            &quot;&quot;&quot;</span></div><div class="token-line"><span class="token plain">            &lt;!DOCTYPE html&gt;</span></div><div class="token-line"><span class="token plain">            &lt;html&gt;</span></div><div class="token-line"><span class="token plain">                &lt;body&gt;</span></div><div class="token-line"><span class="token plain">                    &lt;h1&gt;&quot;Hello World!&quot;&lt;/h1&gt;</span></div><div class="token-line"><span class="token plain">                &lt;/body&gt;</span></div><div class="token-line"><span class="token plain">            &lt;/html&gt;</span></div><div class="token-line"><span class="token plain">            &quot;&quot;&quot;);</span></div></pre></div><p>再比如，文字块可以调用字符串String的API:</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int stringSize = &quot;&quot;&quot;</span></div><div class="token-line"><span class="token plain">            &lt;!DOCTYPE html&gt;</span></div><div class="token-line"><span class="token plain">            &lt;html&gt;</span></div><div class="token-line"><span class="token plain">                &lt;body&gt;</span></div><div class="token-line"><span class="token plain">                    &lt;h1&gt;&quot;Hello World!&quot;&lt;/h1&gt;</span></div><div class="token-line"><span class="token plain">                &lt;/body&gt;</span></div><div class="token-line"><span class="token plain">            &lt;/html&gt;</span></div><div class="token-line"><span class="token plain">            &quot;&quot;&quot;.length();</span></div></pre></div><p>或者，使用嵌入式的表达式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">String greetingHtml = &quot;&quot;&quot;</span></div><div class="token-line"><span class="token plain">            &lt;!DOCTYPE html&gt;</span></div><div class="token-line"><span class="token plain">            &lt;html&gt;</span></div><div class="token-line"><span class="token plain">                &lt;body&gt;</span></div><div class="token-line"><span class="token plain">                    &lt;h1&gt;%s&lt;/h1&gt;</span></div><div class="token-line"><span class="token plain">                &lt;/body&gt;</span></div><div class="token-line"><span class="token plain">            &lt;/html&gt;</span></div><div class="token-line"><span class="token plain">            &quot;&quot;&quot;.formatted(&quot;Hello World!&quot;);</span></div></pre></div><h2 id="巧妙的结束分隔符"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/02#巧妙的结束分隔符"><span class="icon icon-link"></span></a>巧妙的结束分隔符</h2><p>好的，我们现在看看文字块编译的细分步骤。第一个和第二个步骤都很好理解。不过，第二个步骤里“删除共享的前导空格”，是一个我们可以巧妙使用的规则。通过合理地安排共享的前导空格，我们可以实现文字的编排和缩进。</p><p>为了方便理解，在下面的例子里，我们使用小数点号‘.’表示编译期要删除的前导空格，使用叹号‘!’表示编译期要删除的尾部空格。</p><p>第一个例子，我们把结束分隔符单独放在一行，和文本内容左边对齐。这时候，共享的前导空格就是文本内容本身共享的前导空格；结束分隔符仅仅是用来结束文字块的。这个例子里，我还加入了文字内容行的尾部空格，它们在编译期会被删除掉。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// There are 8 leading white spaces in common</span></div><div class="token-line"><span class="token plain">    String textBlock = &quot;&quot;&quot;</span></div><div class="token-line"><span class="token plain">    ........&lt;!DOCTYPE html&gt;</span></div><div class="token-line"><span class="token plain">    ........&lt;html&gt;</span></div><div class="token-line"><span class="token plain">    ........    &lt;body&gt;</span></div><div class="token-line"><span class="token plain">    ........        &lt;h1&gt;&quot;Hello World!&quot;&lt;/h1&gt;!!!!</span></div><div class="token-line"><span class="token plain">    ........    &lt;/body&gt;</span></div><div class="token-line"><span class="token plain">    ........&lt;/html&gt;</span></div><div class="token-line"><span class="token plain">    ........&quot;&quot;&quot;;</span></div></pre></div><p>第二个例子，我们也把结束分隔符单独放在一行，但是放在比文本内容更靠左的位置。这时候，结束分隔符除了用来结束文字块之外，还参与界定共享的前导空格。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// There are 4 leading white spaces in common</span></div><div class="token-line"><span class="token plain">    String textBlock = &quot;&quot;&quot;</span></div><div class="token-line"><span class="token plain">    ....    &lt;!DOCTYPE html&gt;</span></div><div class="token-line"><span class="token plain">    ....    &lt;html&gt;</span></div><div class="token-line"><span class="token plain">    ....        &lt;body&gt;</span></div><div class="token-line"><span class="token plain">    ....            &lt;h1&gt;&quot;Hello World!&quot;&lt;/h1&gt;!!!!</span></div><div class="token-line"><span class="token plain">    ....        &lt;/body&gt;</span></div><div class="token-line"><span class="token plain">    ....    &lt;/html&gt;</span></div><div class="token-line"><span class="token plain">    ....&quot;&quot;&quot;;</span></div></pre></div><p>第三个例子，我们也把结束分隔符单独放在了一行，但是放在文本内容左对齐位置的右侧。这时候，结束分隔符的左侧，除了共享的前导空格之外，还有多余的空格。这些多余的空格，就成了文字内容行的尾部空格，它们在编译期会被删除掉。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// There are 8 leading white spaces in common</span></div><div class="token-line"><span class="token plain">    String textBlock = &quot;&quot;&quot;</span></div><div class="token-line"><span class="token plain">    ........&lt;!DOCTYPE html&gt;</span></div><div class="token-line"><span class="token plain">    ........&lt;html&gt;</span></div><div class="token-line"><span class="token plain">    ........    &lt;body&gt;</span></div><div class="token-line"><span class="token plain">    ........        &lt;h1&gt;&quot;Hello World!&quot;&lt;/h1&gt;!!!!</span></div><div class="token-line"><span class="token plain">    ........    &lt;/body&gt;</span></div><div class="token-line"><span class="token plain">    ........&lt;/html&gt;</span></div><div class="token-line"><span class="token plain">    ........!!!!&quot;&quot;&quot;;</span></div></pre></div><h2 id="尾部空格还能回来吗"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/02#尾部空格还能回来吗"><span class="icon icon-link"></span></a>尾部空格还能回来吗？</h2><p>你可能会问， 一般情况下，尾部空格确实没有什么实质性的作用。但是万一需要尾部空格，它们还能回来吗？</p><p>其实是可以的。为了能够支持尾部附带的空格，文字块还引入了另外一个新的转义字符，‘\s’，空格转义符。空格转义符表示一个空格。我们前面说过的文字块的编译器处理顺序，空格转义符不会在文字块的编译期被删除，因此空格转义符之前的空格也能被保留。所以，每一行使用一个空格转义符也就足够了。</p><p>下面的代码，就是一个重新带回尾部空格的例子，这个字符串的前两行就包含有尾部空格。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// There are 8 leading white spaces in common</span></div><div class="token-line"><span class="token plain">    String textBlock = &quot;&quot;&quot;</span></div><div class="token-line"><span class="token plain">    ........&lt;!DOCTYPE html&gt;    \s!!!!</span></div><div class="token-line"><span class="token plain">    ........&lt;html&gt;             \s</span></div><div class="token-line"><span class="token plain">    ........    &lt;body&gt;!!!!!!!!!!</span></div><div class="token-line"><span class="token plain">    ........        &lt;h1&gt;&quot;Hello World!&quot;&lt;/h1&gt;</span></div><div class="token-line"><span class="token plain">    ........    &lt;/body&gt;</span></div><div class="token-line"><span class="token plain">    ........&lt;/html&gt;</span></div><div class="token-line"><span class="token plain">    ........&quot;&quot;&quot;;</span></div></pre></div><h2 id="该怎么表达长段落"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/02#该怎么表达长段落"><span class="icon icon-link"></span></a>该怎么表达长段落？</h2><p>但是所见即所得的文字块也有一个小烦恼。我们知道，编码规范一般都限定每一行的字节数 ，通常是80个或者120个字节。可是一个文本的长段落通常要超出这个限制。文字块里的换行符通常需要保留，编码规范通常要遵守，那该如何表达长段落或者长行呢？</p><p>针对这种情况，文字块引入了一个新的转义字符，‘&lt;行终止符&gt;’，换行转义符。换行转义符的意思是，如果转移符号出现在一个行的结束位置，这一行的换行符就会被取缔。下面的例子就使用了换行转义符，它就把分散在两行的&quot;Hello World!&quot;连接在一行里了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">String textBlock = &quot;&quot;&quot;</span></div><div class="token-line"><span class="token plain">            &lt;!DOCTYPE html&gt;</span></div><div class="token-line"><span class="token plain">            &lt;html&gt;</span></div><div class="token-line"><span class="token plain">                &lt;body&gt;</span></div><div class="token-line"><span class="token plain">                    &lt;h1&gt;&quot;Hello \</span></div><div class="token-line"><span class="token plain">            World!&quot;&lt;/h1&gt;</span></div><div class="token-line"><span class="token plain">                &lt;/body&gt;</span></div><div class="token-line"><span class="token plain">            &lt;/html&gt;</span></div><div class="token-line"><span class="token plain">            &quot;&quot;&quot;;</span></div></pre></div><p>需要注意的是，上面的例子里，换行转义符之前，还有一个空格。这个空格会被删除吗？连接后的字符，是没有空格间隔的“HelloWorld!”，还是中间有空格的“Hello World!”？还记得我们前面说过的编译器处理顺序吗？空格处理先于转义字符处理。因此，换行转义符之前的空格不算是文字块的尾部空格，因此会得到保留。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/02#总结"><span class="icon icon-link"></span></a>总结</h2><p>好，到这里，今天的课程就要结束了，我来做个小结。从前面的讨论中，我们了解了文字块的基本概念，它的表达形式以及编译的过程。</p><p>文字块是 Java 语言中一种新的文字。 字符串能够出现的任何地方，也都可以用文字块表示。但是，文字块提供了更好的表现力和更少的复杂性。 文字块“所见即所得”的表现形式，使得使用复杂字符串的代码更加清晰，便于编辑，也便于阅读。这是一个能够降低代码错误，提高生产效率的改进。</p><p>如果要丰富你的代码评审清单，学习完这一节内容后，你可以加入下面这一条：</p><blockquote><p>复杂的字符串，使用文字块表述是不是更清晰？</p></blockquote><p>另外，通过今天的讨论，我拎出了几个技术要点，这些都可能在你的面试中出现。通过这一次学习，你应该能够：</p><ul><li>知道文字块的基本概念，以及文字块和字符串的关系；<ul><li>面试问题：你知道Java的文字块吗？它和字符串有什么区别？</li></ul></li><li>了解文字块要解决的问题，并且能够准确使用文字块；<ul><li>面试问题：应当什么时候使用文字块？</li></ul></li><li>了解文字块的表达形式，编译过程以及文字块特有的转义字符。<ul><li>面试问题：怎么用文字块实现文本缩进？</li></ul></li></ul><p>如果能够有意识地使用文字块，你应该能够大幅度提高复杂字符串的可读性。从而更快地编写代码，也让潜在的错误更少。毫无疑问，在面试的时候，有意识地在代码里使用文字块，除了节省时间之外，还能够让你的代码更容易阅读和接受，给面试官带来新鲜的感受。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-java/深入剖析java新特性/02.提升编码效率/02#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>在前面的讨论里，我们说过文字块是一个“所见即所得”的字符串表现形式。我们可以直接拷贝、粘贴文字段落到代码里，而不需要大量的调整。可是，在有些场景里，要想完全地实现“所见即所得”，仅仅使用文字块，可能还是要费一点周折的。</p><p>比如说吧，我们看到的诗，有的时候是页面居中对齐的。比如下面的这首小诗，采用的格式就是居中对齐。</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimaged629d6f2ddf7210a0e1e6f921496d6620c29.fe55bb46.jpg" alt=""/></p><p>居中对齐这种形式，在HTML或者文档的世界里，很容易处理，设置一下格式就可以了。如果是用Java语言，该怎么处理好这首小诗的居中对齐问题？这就是今天我们的思考题。</p><p>稍微提示一个，你可以使用添加缩进空格的方式对齐，也可以不局限于简单的、单纯的Java语言，比如添加进来HTML的文本。</p><p>欢迎你在留言区留言、讨论，分享你的阅读体验以及你对这个思考题的想法。</p><p>注：本文使用的完整的代码可以从<a target="_blank" rel="noopener noreferrer" href="https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/text">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>下载，你可以通过修改<a target="_blank" rel="noopener noreferrer" href="https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/instance">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上<a target="_blank" rel="noopener noreferrer" href="https://github.com/XueleiFan/java-up/blob/main/src/main/java/co/ivi/jus/text/review/xuelei/Island.java">review template<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>代码，完成这次的思考题。如果你想要分享你的修改或者想听听评审的意见，请提交一个 GitHub的拉取请求（Pull Request），并把拉取请求的地址贴到留言里。这一小节的拉取请求代码，请放在<a target="_blank" rel="noopener noreferrer" href="https://github.com/XueleiFan/java-up/blob/main/src/main/java/co/ivi/jus/text/review">实例匹配专用的代码评审目录<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>下，建一个以你的名字命名的子目录，代码放到你专有的子目录里。比如，我的代码，就放在text/review/xuelei的目录下面。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/深入剖析java新特性/02.提升编码效率/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:06:36</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-java/umi.fde43fdb.js"></script>
  </body>
</html>
