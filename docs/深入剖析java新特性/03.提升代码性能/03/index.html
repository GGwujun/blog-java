<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-test/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-test";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>10 | Flow，是异步编程的终极选择吗？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/深入剖析java新特性/03.提升代码性能/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a aria-current="page" class="active" href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-test/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-test/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a aria-current="page" class="active" href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-test/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-test/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-test/深入剖析java新特性/01.开篇词">01.开篇词</a><ul><li><a href="/blog-test/深入剖析java新特性/01.开篇词/01"><span>开篇词 | 拥抱Java新特性，像设计者一样工作和思考</span></a></li></ul></li><li><a href="/blog-test/深入剖析java新特性/02.提升编码效率">02.提升编码效率</a><ul><li><a href="/blog-test/深入剖析java新特性/02.提升编码效率/01"><span>01 | JShell：怎么快速验证简单的小问题？</span></a></li><li><a href="/blog-test/深入剖析java新特性/02.提升编码效率/02"><span>02 | 文字块：怎么编写所见即所得的字符串？</span></a></li><li><a href="/blog-test/深入剖析java新特性/02.提升编码效率/03"><span>03 | 档案类：怎么精简地表达不可变数据？</span></a></li><li><a href="/blog-test/深入剖析java新特性/02.提升编码效率/04"><span>04 | 封闭类：怎么刹住失控的扩展性？</span></a></li><li><a href="/blog-test/深入剖析java新特性/02.提升编码效率/05"><span>05 | 类型匹配：怎么切除臃肿的强制转换？</span></a></li><li><a href="/blog-test/深入剖析java新特性/02.提升编码效率/06"><span>06 | switch表达式：怎么简化多情景操作？</span></a></li><li><a href="/blog-test/深入剖析java新特性/02.提升编码效率/07"><span>07 | switch匹配：能不能适配不同的类型？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-test/深入剖析java新特性/03.提升代码性能">03.提升代码性能</a><ul><li><a href="/blog-test/深入剖析java新特性/03.提升代码性能/01"><span>08 | 抛出异常，是不是错误处理的第一选择？</span></a></li><li><a href="/blog-test/深入剖析java新特性/03.提升代码性能/02"><span>09 | 异常恢复，付出的代价能不能少一点？</span></a></li><li><a aria-current="page" class="active" href="/blog-test/深入剖析java新特性/03.提升代码性能/03"><span>10 | Flow，是异步编程的终极选择吗？</span></a></li><li><a href="/blog-test/深入剖析java新特性/03.提升代码性能/04"><span>11 | 矢量运算：Java的机器学习要来了吗？</span></a></li><li><a href="/blog-test/深入剖析java新特性/03.提升代码性能/05"><span>12 | 外部内存接口：零拷贝的障碍还有多少？</span></a></li><li><a href="/blog-test/深入剖析java新特性/03.提升代码性能/06"><span>13 | 外部函数接口，能不能取代Java本地接口？</span></a></li></ul></li><li><a href="/blog-test/深入剖析java新特性/04.降低维护难度">04.降低维护难度</a><ul><li><a href="/blog-test/深入剖析java新特性/04.降低维护难度/01"><span>14 | 禁止空指针，该怎么避免崩溃的空指针？</span></a></li><li><a href="/blog-test/深入剖析java新特性/04.降低维护难度/02"><span>15 | 现代密码：你用的加密算法过时了吗？</span></a></li><li><a href="/blog-test/深入剖析java新特性/04.降低维护难度/03"><span>16 | 改进的废弃，怎么避免使用废弃的特性？</span></a></li><li><a href="/blog-test/深入剖析java新特性/04.降低维护难度/04"><span>17 | 模块系统：为什么Java需要模块化？</span></a></li><li><a href="/blog-test/深入剖析java新特性/04.降低维护难度/05"><span>18 | 模块系统：怎么模块化你的应用程序？</span></a></li></ul></li><li><a href="/blog-test/深入剖析java新特性/05.结束语">05.结束语</a><ul><li><a href="/blog-test/深入剖析java新特性/05.结束语/01"><span>期末测试｜来赴一场满分之约！</span></a></li><li><a href="/blog-test/深入剖析java新特性/05.结束语/02"><span>结束语 | Java的未来，依然是星辰大海</span></a></li></ul></li><li><a href="/blog-test/深入剖析java新特性/06.特别放送">06.特别放送</a><ul><li><a href="/blog-test/深入剖析java新特性/06.特别放送/01"><span>用户故事 | 保持好奇心，积极拥抱变化</span></a></li><li><a href="/blog-test/深入剖析java新特性/06.特别放送/02"><span>用户故事 | 与新特性开发者对话</span></a></li></ul></li><li><a href="/blog-test/深入剖析java新特性/summary">深入剖析java新特性</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="阅读案例" data-depth="2"><a href="/blog-test/深入剖析java新特性/03.提升代码性能/03#阅读案例"><span>阅读案例</span></a></li><li title="指令式编程模型" data-depth="3"><a href="/blog-test/深入剖析java新特性/03.提升代码性能/03#指令式编程模型"><span>指令式编程模型</span></a></li><li title="声明式编程模型" data-depth="3"><a href="/blog-test/深入剖析java新特性/03.提升代码性能/03#声明式编程模型"><span>声明式编程模型</span></a></li><li title="反应式编程" data-depth="2"><a href="/blog-test/深入剖析java新特性/03.提升代码性能/03#反应式编程"><span>反应式编程</span></a></li><li title="数据的输出" data-depth="3"><a href="/blog-test/深入剖析java新特性/03.提升代码性能/03#数据的输出"><span>数据的输出</span></a></li><li title="数据的输入" data-depth="3"><a href="/blog-test/深入剖析java新特性/03.提升代码性能/03#数据的输入"><span>数据的输入</span></a></li><li title="数据的控制" data-depth="3"><a href="/blog-test/深入剖析java新特性/03.提升代码性能/03#数据的控制"><span>数据的控制</span></a></li><li title="数据的传递" data-depth="3"><a href="/blog-test/深入剖析java新特性/03.提升代码性能/03#数据的传递"><span>数据的传递</span></a></li><li title="过程的串联" data-depth="3"><a href="/blog-test/深入剖析java新特性/03.提升代码性能/03#过程的串联"><span>过程的串联</span></a></li><li title="简洁的重构" data-depth="2"><a href="/blog-test/深入剖析java新特性/03.提升代码性能/03#简洁的重构"><span>简洁的重构</span></a></li><li title="缺陷与对策" data-depth="2"><a href="/blog-test/深入剖析java新特性/03.提升代码性能/03#缺陷与对策"><span>缺陷与对策</span></a></li><li title="总结" data-depth="2"><a href="/blog-test/深入剖析java新特性/03.提升代码性能/03#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-test/深入剖析java新特性/03.提升代码性能/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="10--flow是异步编程的终极选择吗"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入剖析java新特性/03.提升代码性能/03#10--flow是异步编程的终极选择吗"><span class="icon icon-link"></span></a>10 | Flow，是异步编程的终极选择吗？</h1><p>你好，我是范学雷。今天，我们讨论反应式编程。</p><p>反应式编程曾经是一个很热门的话题。它是代码的控制的一种模式。如果不分析其他的模式，我们很难识别反应式编程的好与坏，以及最合适它的使用场景。所以，我们今天的讨论，和以往有很大的不同。</p><p>除了反应式编程之外，我们还会花很大的篇幅讨论其他的编程模式，包括现在的和未来的。希望这样的安排，能够帮助你根据具体的场景，选择最合适的模式。</p><p>我们从阅读案例开始，先来看一看最传统的模式，然后一步一步地过渡到反应式编程，最后我们再来稍微聊几句Java尚未发布的协程模式。</p><h2 id="阅读案例"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入剖析java新特性/03.提升代码性能/03#阅读案例"><span class="icon icon-link"></span></a>阅读案例</h2><p>我想，你和我一样，无论是学习C语言，还是Java语言，都是从打印&quot;Hello, world!&quot;这个简单的例子开始的。我们再来看看这个我们熟悉的代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">System.out.println(&quot;Hello, World!&quot;);</span></div></pre></div><p>这段代码就是使用了最常用的代码控制模式：指令式编程模型。<strong>所谓指令式编程模型，需要我们通过代码发布指令，然后等待指令的执行以及指令执行带来的状态变化。我们还要根据目前的状态，来确定下一次要发布的指令，并且用代码把下一个指令表示出来。</strong></p><p>上面的代码里，我们发布的指令就是：标准输出打印“Hello, World!”这句话。然后，我们就等待指令的执行结果，验证我们编写的代码有没有按照我们的指令工作。</p><h3 id="指令式编程模型"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入剖析java新特性/03.提升代码性能/03#指令式编程模型"><span class="icon icon-link"></span></a><strong>指令式编程模型</strong></h3><p><strong>指令式编程模型关注的重点就在于控制状态。</strong>&quot;Hello, world!&quot;这个例子能看出来一点端倪，但是要了解状态变化和控制，我们需要看两行以上的代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">try {</span></div><div class="token-line"><span class="token plain">        Digest messageDigest = Digest.of(&quot;SHA-256&quot;);</span></div><div class="token-line"><span class="token plain">        byte[] digestValue =</span></div><div class="token-line"><span class="token plain">                messageDigest.digest(&quot;Hello, world!&quot;.getBytes());</span></div><div class="token-line"><span class="token plain">    } catch (NoSuchAlgorithmException ex) {</span></div><div class="token-line"><span class="token plain">        System.out.println(&quot;Unsupported algorithm: SHA-256&quot;);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在上面的这段代码里，我们首先调用Digest.of方法，得到一个Digest实例；然后调用这个实例的方法Digest.digest，获得一个返回值。第一个方法执行完成后，获得了第一个方法执行后的状态，第二个方法才能接着执行。</p><p>这种顺序执行的模式，逻辑简单直接。简单直接本身就有着巨大的能量，特别是实现精确控制方面。所以，这种模式在通用编程语言设计和一般的应用程序开发中，占据着压倒性的优势。</p><p>但是，这种模式需要维护和同步状态。如果状态数量大，我们就要把大的代码块分解成小的代码块；这样，我们编写的代码才能更容易阅读，更容易维护。而更大的问题来自于状态同步需要的顺序执行。</p><p>比如说吧，上面的例子中，Digest.of这个方法实现，可能效率很高，执行得很快；而Digest.digest这个方法的实现，它的执行速度可能就是毫秒级的，甚至是秒一级别的。在要求低延迟、高并发的环境下，等待Digest.digest调用的返回结果，可能就不是一个好的选择。换句话说，阻塞在方法的调用上，增加了系统的延迟，降低了系统能够支持的吞吐量。</p><p>这种顺序执行的模式带来的延迟后果，在互联网时代的很多场景下是无法忍受的（比如春节的火车票预售系统，或者网上购物节的订购系统等）。存在这种问题最典型的场景之一，就是客户端-服务器这种架构下的传统的套接字编程接口。它也引发了大约20年前提出的C10K问题（支持1万个并发用户）。</p><p>怎样解决C10K问题呢？一个主要方向，就是使用非阻塞的异步编程。</p><h3 id="声明式编程模型"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入剖析java新特性/03.提升代码性能/03#声明式编程模型"><span class="icon icon-link"></span></a><strong>声明式编程模型</strong></h3><p>非阻塞的异步编程，并不是可以通过编程语言或者标准类库就可以得到的。支持非阻塞的异步编程，需要大幅度地更改代码，转换代码编写的思维习惯。</p><p>我们可以使用打电话来做个比方。</p><p>传统的指令式编程模型，就像我们通常打电话一样。我们拨打对方的电话号码，然后等待接听，然后通话，然后挂断。当我们挂断电话的时候，打电话这一个过程也就结束了，我们也拿到了想要的结果。</p><p>而非阻塞的异步编程，更像是电话留言。我们拨打对方的电话，告诉对方方便的时候，回拨电话，然后就挂断了。当我们挂断电话的时候，打电话这一个过程当然也是结束了，但是我们没有拿到想要的结果。想要的结果，还要依靠回拨电话，才能够得到。</p><p>而类似于回拨电话的逻辑，正是非阻塞的异步编程的关键模型。映射到代码上，就是使用回调函数或者方法。</p><p>当我们试图使用回调函数时，我们编写代码的思想和模型都会产生巨大的变化。我们关注的重点，就会从指令式编程模型的“控制状态”转变到“控制目标”。这时候，我们编程模型也就转变到了<strong>声明式的编程模型</strong>。</p><p>**如果指令式编程模型的逻辑是告诉计算机“该怎么做”，那么声明式的编程模型的逻辑就是告诉计算机“要做什么”。**指令式编程模型的代码像是流水线作业的工程师，事无巨细，拧好每一个螺丝；而声明式的编程模型的代码，更像是稳坐在军帐中的军师，布置任务，运筹帷幄。</p><p>我们前面讨论的Digest，能不能实现非阻塞的异步编程呢？答案是肯定的，不过我们需要彻底地更改代码，从API到实现都要转换思路。下面这段代码里声明的API，就是我们尝试使用声明式编程的一个例子。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public sealed abstract class Digest {</span></div><div class="token-line"><span class="token plain">        public static void of(String algorithm,</span></div><div class="token-line"><span class="token plain">            Consumer&lt;Digest&gt; onSuccess, Consumer&lt;Integer&gt; onFailure) {</span></div><div class="token-line"><span class="token plain">            // snipped</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public abstract void digest(byte[] message,</span></div><div class="token-line"><span class="token plain">            Consumer&lt;byte[]&gt; onSuccess, Consumer&lt;Integer&gt; onFailure);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>转化了思路的Digest.of方法，就像是布置任务：如果执行成功，请继续执行A计划（也就是onSuccess这个回调函数）；否则，就继续执行B计划（也就是onFailure这个回调函数）。其实，这也就是我们前面提到的，告诉计算机“要做什么”的概念。</p><p>有了回调函数的设计，代码的实现方式就放开了管制。无论是回调函数的实现，还是回调函数的调用，都可以自由地选择是采用异步的模式，还是同步的模式。不用说，这种自由很具有吸引力。从JDK 7引入NIO新特性开始，这种模式开始进入Java的工业实践，并且取得了巨大的成功。出现了一大批的明星项目。</p><p>不过，回调函数的设计也有着天生的缺陷。这个缺陷，就是回调地狱（Callback Hell，常被译为回调地狱。为了更直观地表达，我更喜欢把它叫做回调堆挤）。什么意思呢？通常地，我们需要布置多个小的任务，才能完成一项大的任务。这些小任务还有可能是有因果关系的任务，这时候，就需要小任务的配合，或者按顺序执行。</p><p>比如说，上面的Digest设计，我们先要判断of方法能不能成功；如果成功的话，那么就使用这个Digest实例，调用它的Digest.digest方法。而Digest.digest方法的调用，也要作出A计划和B计划。这样，两个回调函数的使用，就会堆积起来。如果回调函数的嵌套增多，代码看起来就像挤在一块一样，形式上不美观，阅读起来很费解，维护起来难度很大。</p><p>下面的这段代码，就是我们使用回调函数设计的Digest的一个用例。这个用例里，回调函数的嵌套仅仅有两层，代码的形式已经变得很难阅读了。你可以尝试编写一个3层或者5层的回调函数的嵌套，体验一下深度嵌套的代码是什么样子的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Digest.of(&quot;SHA-256&quot;,</span></div><div class="token-line"><span class="token plain">        md -&gt; {</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;SHA-256 is not supported&quot;);</span></div><div class="token-line"><span class="token plain">            md.digest(&quot;Hello, world!&quot;.getBytes(),</span></div><div class="token-line"><span class="token plain">                values -&gt; {</span></div><div class="token-line"><span class="token plain">                    System.out.println(&quot;SHA-256 is available&quot;);</span></div><div class="token-line"><span class="token plain">                },</span></div><div class="token-line"><span class="token plain">                errorCode -&gt; {</span></div><div class="token-line"><span class="token plain">                    System.out.println(&quot;SHA-256 is not available&quot;);</span></div><div class="token-line"><span class="token plain">                });</span></div><div class="token-line"><span class="token plain">        },</span></div><div class="token-line"><span class="token plain">        errorCode -&gt; {</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;Unsupported algorithm: SHA-256&quot;);</span></div><div class="token-line"><span class="token plain">        });</span></div></pre></div><p>如果说，回调函数带来的形式的堆积我们还可以克服的话；那这种形式上的堆积带来的逻辑堆积，我们就几乎不可承受了。<strong>逻辑上的堆积，意味着代码的深度耦合。而深度耦合，意味着代码维护困难。深度嵌套里的一点点代码修改，都可能通过嵌套层层朝上传递，最后牵动全局。</strong></p><p>这就导致，使用回调函数的声明式编程模型有着严重的场景适应问题。我们通常只使用回调函数解决性能影响最大的模块，比如说网络数据的传输；而大部分的代码，依然使用传统的、顺序执行的指令式模型。</p><p>好在，业界也有很多努力，试图改善回调函数的使用困境。其中最出色也是影响最大的一个，就是反应式编程。</p><h2 id="反应式编程"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入剖析java新特性/03.提升代码性能/03#反应式编程"><span class="icon icon-link"></span></a>反应式编程</h2><p>反应式编程的基本逻辑，仍然是告诉计算机“要做什么”；但是它的关注点转移到了数据的变化以及数据和变化的传递上，或者说，是转移到了对数据变化的反应上。所以，<strong>反应式编程的核心是数据流和变化传递。</strong></p><p>如果我们从数据的流向角度来看的话，数据有两种基本的形式： 数据的输入和数据的输出。从这两种基本的形式，能够衍生出三种过程：最初的来源，数据的传递和最终的结局。</p><h3 id="数据的输出"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入剖析java新特性/03.提升代码性能/03#数据的输出"><span class="icon icon-link"></span></a><strong>数据的输出</strong></h3><p>在Java的反应式编程模型的设计里，数据的输出使用只有一个参数的Flow.Publisher来表示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@FunctionalInterface</span></div><div class="token-line"><span class="token plain">    public static interface Publisher&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        public void subscribe(Subscriber&lt;? super T&gt; subscriber);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在Flow.Publisher的接口设计里，泛型T表示的就是数据的类型。 数据输出的对象，是使用Flow.Subscriber来表示的。换句话说，数据的发布者通过授权订阅者，来实现数据从发布者到订阅者的传递。一个数据的发布者，可以有多个数据的订阅者。</p><p>需要注意的是，订阅的接口，安排在了Flow.Publisher这个接口里。这也就意味着，订阅者的订阅行为，是由数据的发布者发起的，而不是订阅者发起的。</p><p>数据最初的来源，就是一种形式的数据输出；它只有数据输出这一个传递方向，而不能接收数据的输入。</p><p>比如下面的代码，就是一个表示数据最初来源的例子。在这段代码里，数据的类型是字节数组；而数据发布的实现，我们使用了Java标准类库的参考性实现SubmissionPublisher这个类。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">SubmissionPublisher&lt;byte[]&gt; publisher = new SubmissionPublisher&lt;&gt;();</span></div></pre></div><h3 id="数据的输入"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入剖析java新特性/03.提升代码性能/03#数据的输入"><span class="icon icon-link"></span></a><strong>数据的输入</strong></h3><p>下面，我们再来看下数据的输入。</p><p>在Java的反应式编程模型的设计里，数据的输入用只有一个参数的Flow.Subscriber来表示。也就是我们前面提到的订阅者。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public static interface Subscriber&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">        public void onSubscribe(Subscription subscription);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public void onNext(T item);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public void onError(Throwable throwable);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public void onComplete();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在Flow.Subscriber的接口设计里，泛型T表示的就是数据的类型。 这个接口里一共定义了四种任务，并分别规定了下面四种情形下的反应：</p><ol><li>如果接收到订阅邀请该怎么办？这个行为由onSubscribe这个方法的实现确定。</li><li>如果接收到数据该怎么办？这个行为由onNext这个方法的实现确定。</li><li>如果遇到了错误该怎么办？这个行为由onError这个方法的实现确定。</li><li>如果数据传输完毕该怎么办？这个行为由onComplete这个方法的实现确定。</li></ol><p>数据最终的结局，就是一种形式的数据输入；它只有数据输入这一个传递方向，而不能产生数据的输出。</p><p>比如下面的代码，就是一个表示数据最终结果的例子。在这段代码里，我们使用一个泛型来表示数据的类型；然后，使用了一个Consumer函数来表示我们该怎么处理接收到的数据。这样的安排让这个例子具有了普遍的意义。只要稍作修改，就可以把它使用到实际场景中去了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package co.ivi.jus.flow.reactive;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import java.util.concurrent.Flow;</span></div><div class="token-line"><span class="token plain">    import java.util.function.Consumer;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class Destination&lt;T&gt; implements Flow.Subscriber&lt;T&gt;{</span></div><div class="token-line"><span class="token plain">        private Flow.Subscription subscription;</span></div><div class="token-line"><span class="token plain">        private final Consumer&lt;T&gt; consumer;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public Destination(Consumer&lt;T&gt; consumer) {</span></div><div class="token-line"><span class="token plain">            this.consumer = consumer;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void onSubscribe(Flow.Subscription subscription) {</span></div><div class="token-line"><span class="token plain">            this.subscription = subscription;</span></div><div class="token-line"><span class="token plain">            subscription.request(1);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void onNext(T item) {</span></div><div class="token-line"><span class="token plain">            subscription.request(1);</span></div><div class="token-line"><span class="token plain">            consumer.accept(item);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void onError(Throwable throwable) {</span></div><div class="token-line"><span class="token plain">            throwable.printStackTrace();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void onComplete() {</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;Done&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="数据的控制"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入剖析java新特性/03.提升代码性能/03#数据的控制"><span class="icon icon-link"></span></a><strong>数据的控制</strong></h3><p>你可能已经注意到了，Flow.Subscriber接口，并没有和Flow.Publisher直接联系。取而代之地出现了一个中间代理Flow.Subscription。Flow.Subscription管理、控制着Flow.Publisher和Flow.Subscriber之间的连接，以及数据的传递。</p><p>也就是说，在Java的反应式编程模型里，数据的传递控制从数据和数据的变化里分离了出来。这样的分离，对于降低功能之间的耦合意义重大。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public static interface Subscription {</span></div><div class="token-line"><span class="token plain">        public void request(long n);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public void cancel();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在Flow.Subscription的接口设计里，我们定义了两个方法。一个方法表示订阅者希望接收的数据数量，也就是Subscription.request这个方法。另一个方法表示订阅者希望取消订阅，也就是Subscription.cancel这个方法。</p><h3 id="数据的传递"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入剖析java新特性/03.提升代码性能/03#数据的传递"><span class="icon icon-link"></span></a><strong>数据的传递</strong></h3><p>除了最初的来源和最终的结局，数据表现还有一个过程，就是数据的传递。数据的传递这个过程，既包括接收输入数据，也包括发送输出数据。在数据传递这个环节，数据的内容可能会发生变化，数据的数量也可能会发生变化（比如，过滤掉一部分的数据，或者修改输入的数据，甚至替换掉输入的数据）。</p><p>在Java的反应式编程模型的设计里，这样的过程是由Flow.Processor表示的。Flow.Processor是一个扩展了Flow.Publisher和Flow.Subscriber的接口。所以，Flow.Processor有两个数据类型，泛型T表述输入数据的类型，泛型R表述输出数据的类型。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public static interface Processor&lt;T,R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>下面的代码，就是一个表示数据传递的例子。在这段代码里，我们使用泛型来表示输入数据和输出数据的类型；然后，我们使用了一个Function函数，来表示该怎么处理接收到的数据，并且输出处理的结果。这样的安排让这个例子具有了普遍的意义。稍作修改，你就可以把它用到实际场景中去了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package co.ivi.jus.flow.reactive;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import java.util.concurrent.Flow;</span></div><div class="token-line"><span class="token plain">    import java.util.concurrent.SubmissionPublisher;</span></div><div class="token-line"><span class="token plain">    import java.util.function.Function;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class Transform&lt;T, R&gt; extends SubmissionPublisher&lt;R&gt;</span></div><div class="token-line"><span class="token plain">            implements Flow.Processor&lt;T, R&gt; {</span></div><div class="token-line"><span class="token plain">        private Function&lt;T, R&gt; transform;</span></div><div class="token-line"><span class="token plain">        private Flow.Subscription subscription;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public Transform(Function&lt;T, R&gt; transform) {</span></div><div class="token-line"><span class="token plain">            super();</span></div><div class="token-line"><span class="token plain">            this.transform = transform;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void onSubscribe(Flow.Subscription subscription) {</span></div><div class="token-line"><span class="token plain">            this.subscription = subscription;</span></div><div class="token-line"><span class="token plain">            subscription.request(1);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void onNext(T item) {</span></div><div class="token-line"><span class="token plain">            submit(transform.apply(item));</span></div><div class="token-line"><span class="token plain">            subscription.request(1);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void onError(Throwable throwable) {</span></div><div class="token-line"><span class="token plain">            closeExceptionally(throwable);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void onComplete() {</span></div><div class="token-line"><span class="token plain">            close();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="过程的串联"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入剖析java新特性/03.提升代码性能/03#过程的串联"><span class="icon icon-link"></span></a><strong>过程的串联</strong></h3><p>既然数据的表述方式分为输入和输出两种基本的形式，而且还提供了由此衍生出来的三种过程，我们就能够把数据的处理过程，很方便地串联起来了。</p><p>下面的代码，就是我们试图把最初的来源、数据的传递和最终的结局这三个过程，串联成一个更大的过程的例子。当然，你也可以试着串联进更多的数据处理过程。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private static void transform(byte[] message,</span></div><div class="token-line"><span class="token plain">              Function&lt;byte[], byte[]&gt; transformFunction) {</span></div><div class="token-line"><span class="token plain">        SubmissionPublisher&lt;byte[]&gt; publisher =</span></div><div class="token-line"><span class="token plain">                new SubmissionPublisher&lt;&gt;();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // Create the transform processor</span></div><div class="token-line"><span class="token plain">        Transform&lt;byte[], byte[]&gt; messageDigest =</span></div><div class="token-line"><span class="token plain">                new Transform&lt;&gt;(transformFunction);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // Create subscriber for the processor</span></div><div class="token-line"><span class="token plain">        Destination&lt;byte[]&gt; subscriber = new Destination&lt;&gt;(</span></div><div class="token-line"><span class="token plain">                values -&gt; System.out.println(</span></div><div class="token-line"><span class="token plain">                        &quot;Got it: &quot; + Utilities.toHexString(values)));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // Chain processor and subscriber</span></div><div class="token-line"><span class="token plain">        publisher.subscribe(messageDigest);</span></div><div class="token-line"><span class="token plain">        messageDigest.subscribe(subscriber);</span></div><div class="token-line"><span class="token plain">        publisher.submit(message);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // Close the submission publisher.</span></div><div class="token-line"><span class="token plain">        publisher.close();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>串联的形式，接藕了不同环节的关联；而且每个环节的代码也可以换个场景复用。支持过程的串联，是反应式编程模型强大的最大动力之一。像Scala这样的编程语言，甚至把过程串联提升到了编程语言的层面来支持。这样做，毫无疑问大幅度地提高了编码的效率和代码的美观程度。</p><h2 id="简洁的重构"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入剖析java新特性/03.提升代码性能/03#简洁的重构"><span class="icon icon-link"></span></a>简洁的重构</h2><p>介绍完Java的反应式编程模型设计，我们要回头看看我们在阅读案例里提出的问题了。反应式编程，是怎么解决顺序执行的模式带来的延迟后果的呢？ 反应式编程，怎么解决回调函数带来的堆挤问题呢？</p><p>我们还是先看一眼使用反应式编程模型的代码，然后再来讨论这些问题吧。下面的代码，就是我们对阅读案例里Digest用法的改进。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Returned&lt;Digest&gt; rt = Digest.of(&quot;SHA-256&quot;);</span></div><div class="token-line"><span class="token plain">    switch (rt) {</span></div><div class="token-line"><span class="token plain">        case Returned.ReturnValue rv -&gt; {</span></div><div class="token-line"><span class="token plain">            // Get the returned value</span></div><div class="token-line"><span class="token plain">            if (rv.returnValue() instanceof Digest d) {</span></div><div class="token-line"><span class="token plain">                // Call the transform method for the message digest.</span></div><div class="token-line"><span class="token plain">                transform(&quot;Hello, World!&quot;.getBytes(), d::digest);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                // Wait for completion</span></div><div class="token-line"><span class="token plain">                Thread.sleep(20000);</span></div><div class="token-line"><span class="token plain">            } else {  // unlikely</span></div><div class="token-line"><span class="token plain">                System.out.println(&quot;Implementation error: SHA-256&quot;);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        case Returned.ErrorCode ec -&gt;</span></div><div class="token-line"><span class="token plain">                System.out.println(&quot;Unsupported algorithm: SHA-256&quot;);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这个例子里，我们没有发现类似于回调函数一样的堆挤现象。这里面，起重要作用的就是我们上面提到的过程的串联这种形式。Java的反应式编程模型里的过程串联和数据控制的设计，以及数据输入和输出的分离，降低了代码的耦合，不再需要嵌套的调用了。</p><p>在这个例子里，我们还看到了Digest.digest方法的直接使用。为了能够使用反应式编程模型，我们没有必要去修改Digest代码。只要把Digest原来的设计和实现，恰当地放到反应式编程模型里来，就能够实现异步非阻塞的设想了。这一点，无疑具有极大的吸引力。如果不是被逼无奈，谁会去颠覆已有的代码呢？</p><p>那到底反应式编程模型是怎么支持异步非阻塞的呢？其实，和回调函数一样，反应式编程既能够支持同步阻塞的模式，也能够支持异步非阻塞的模式。如果这些接口实现是异步非阻塞模式的，这些实现的调用，也就是异步非阻塞的。当然，反应式编程模型的主要使用场景，目前还是异步非阻塞模式。</p><p>比如我们例子中的SubmissionPublisher，就是一个异步非阻塞模式的实现。在上面的代码里，如果没有调用Thread.sleep，我们可能还看不到Digest的处理结果，主线程就退出了。这就是一个非阻塞的实现表现出来的现象。</p><h2 id="缺陷与对策"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入剖析java新特性/03.提升代码性能/03#缺陷与对策"><span class="icon icon-link"></span></a>缺陷与对策</h2><p>到目前为止，反应式编程模型看起来还很完美。可是，反应式编程模型的缺陷也很要命。其中最要命的缺陷，就是错误很难排查，这是异步编程的通病。而反应式编程模型的解耦设计，加剧了错误排查的难度，这会严重影响开发的效率，降低代码的可维护性。</p><p>目前来看，解决反应式编程模型的缺陷，或者说是异步编程的缺陷的方向，似乎又要回到了指令式编程模型这条老路上来了。这里最值得提及的就是协程（Fiber）这个概念（目前，Java的协程模式还没有发布，但是我可以带你先了解一下）。</p><p>我们再来看看阅读案例里提到的这段代码。为了方便你阅读，我把它拷贝粘贴到这里来了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">try {</span></div><div class="token-line"><span class="token plain">        Digest messageDigest = Digest.of(&quot;SHA-256&quot;);</span></div><div class="token-line"><span class="token plain">        byte[] digestValue =</span></div><div class="token-line"><span class="token plain">                messageDigest.digest(&quot;Hello, world!&quot;.getBytes());</span></div><div class="token-line"><span class="token plain">    } catch (NoSuchAlgorithmException ex) {</span></div><div class="token-line"><span class="token plain">        System.out.println(&quot;Unsupported algorithm: SHA-256&quot;);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在Java的指令式编程模型里，这段代码要在一个线程里执行。我们首先调用Digest.of方法，得到一个Digest实例；然后调用这个实例的方法Digest.digest，获得一个返回值。在每个方法返回之前，线程都会处于等待状态。而线程的等待，是造成资源浪费的最大因素。</p><p>而协程的处理方式，消除了线程的等待。如果调用阻塞，就会把资源切换出去，执行其他的操作。这就节省了大量的计算资源，使得系统在阻塞的模式下，支持大规模的并发。如果指令式编程模型能够通过协程的方式支持大规模的并发，也许它是一个颠覆现有高并发架构的新技术。</p><p>目前，Java的协程模式还没有发布。它能够给反应式编程模型带来什么样的影响，能够给我们实现大规模并发系统带来多大的便利？这些问题的答案，我们还需要等待一段时间。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入剖析java新特性/03.提升代码性能/03#总结"><span class="icon icon-link"></span></a>总结</h2><p>好，到这里，我来做个小结。前面，我们讨论了指令式编程模型和声明式编程模型，回调函数以及回调地狱，以及Java反应式编程模型的基本组件。</p><p>限于篇幅，我们不能展开讨论Java反应式编程模型的各种潜力和变化，比如“反应式宣言”“背压”这样的热门词汇。我建议你继续深入地了解反应式编程的这些要求（比如反应式宣言和反应式系统），以及成熟的明星产品（比如Akka和Spring 5+）。</p><p>由于Java的协程模式还没有发布，我对反应式编程的未来还没有清晰的判断。也欢迎你在留言区里留言、讨论反应式编程的现在和未来。</p><p>另外，我还拎出了几个今天讨论过的技术要点，这些都可能在你们面试中出现哦。通过这一次学习，你应该能够：</p><ul><li>了解指令式编程模型和声明式编程模型这两个术语；<ul><li>面试问题：你知道声明式编程模型吗，它是怎么工作的？</li></ul></li><li>了解Java反应式编程模型的基本组件，以及它们的组合方式；<ul><li>面试问题：你知道怎么使用Java反应式编程模型吗？</li></ul></li><li>知道回调函数的形式，以及回调地狱这个说法。<ul><li>面试问题：你知道回调函数有什么问题吗？</li></ul></li></ul><p>反应式编程是目前主流的支持高并发的技术架构思路。学会反应式编程，意味着你有能力处理高并发应用这样的需求。能够编写高并发的代码，现在很重要，以后更重要。学会使用Java反应式编程模型这样一个高度抽象的接口，毫无疑问能够提升你的技术深度。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入剖析java新特性/03.提升代码性能/03#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>今天的思考题，我们来试着使用一下Java反应式编程模型。在讨论反应式编程的时候，计算a = b + c是一个常用的范例。在这个计算里，b和c随着时间的推移，会发生变化。而每一次的变化，都会影响a的计算结果。</p><p>现在我们假设a表示的数据是一件事情结束的时候是星期几，b表示的数据是一件事情开始的时候是星期几，c表示处理完这件事情需要多少天。你会怎么使用Java反应式编程模型来处理这个问题？</p><p>欢迎你在留言区留言、讨论，分享你的阅读体验以及你的设计和代码。我们下节课见！</p><p>注：本文使用的完整的代码可以从<a target="_blank" rel="noopener noreferrer" href="https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/flow">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>下载，你可以通过修改<a target="_blank" rel="noopener noreferrer" href="https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/flow">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上<a target="_blank" rel="noopener noreferrer" href="https://github.com/XueleiFan/java-up/blob/main/src/main/java/co/ivi/jus/flow/review/xuelei">review template<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>代码，完成这次的思考题。如果你想要分享你的修改或者想听听评审的意见，请提交一个 GitHub的拉取请求（Pull Request），并把拉取请求的地址贴到留言里。这一小节的拉取请求代码，请在<a target="_blank" rel="noopener noreferrer" href="https://github.com/XueleiFan/java-up/blob/main/src/main/java/co/ivi/jus/flow/review">反应式编程专用的代码评审目录<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>下，建一个以你的名字命名的子目录，代码放到你专有的子目录里。比如，我的代码，就放在flow/review/xuelei的目录下面。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/深入剖析java新特性/03.提升代码性能/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 09:43:57</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-test/umi.3ded5539.js"></script>
  </body>
</html>
