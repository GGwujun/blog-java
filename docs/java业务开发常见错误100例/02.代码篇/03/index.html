<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-java/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-java";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>03 | 线程池：业务代码最常用也最容易犯错的组件 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/java业务开发常见错误100例/02.代码篇/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java业务开发常见错误100例/01.开篇词">01.开篇词</a><ul><li><a href="/blog-java/java业务开发常见错误100例/01.开篇词/01"><span>开篇词 | 业务代码真的会有这么多坑？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例/02.代码篇">02.代码篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/01"><span>01 | 使用了并发工具类库，线程安全就高枕无忧了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/02"><span>02 | 代码加锁：不要让“锁”事成为烦心事</span></a></li><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例/02.代码篇/03"><span>03 | 线程池：业务代码最常用也最容易犯错的组件</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/04"><span>04 | 连接池：别让连接池帮了倒忙</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/05"><span>05 | HTTP调用：你考虑到超时、重试、并发了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/06"><span>06 | 20%的业务代码的Spring声明式事务，可能都没处理正确</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/07"><span>答疑篇：代码篇思考题集锦（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/08"><span>07 | 数据库索引：索引并不是万能药</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/09"><span>08 | 判等问题：程序里如何确定你就是你？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/10"><span>09 | 数值计算：注意精度、舍入和溢出问题</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/11"><span>10 | 集合类：坑满地的List列表操作</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/12"><span>11 | 空值处理：分不清楚的null和恼人的空指针</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/13"><span>12 | 异常处理：别让自己在出问题的时候变为瞎子</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/14"><span>答疑篇：代码篇思考题集锦（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/15"><span>13 | 日志：日志记录真没你想象的那么简单</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/16"><span>14 | 文件IO：实现高效正确的文件读写并非易事</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/17"><span>15 | 序列化：一来一回你还是原来的你吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/18"><span>16 | 用好Java 8的日期时间类，少踩一些“老三样”的坑</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/19"><span>17 | 别以为“自动挡”就不可能出现OOM</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/20"><span>18 | 当反射、注解和泛型遇到OOP时，会有哪些坑？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/21"><span>19 | Spring框架：IoC和AOP是扩展的核心</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/22"><span>20 | Spring框架：框架帮我们做了很多工作也带来了复杂度</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/23"><span>答疑篇：代码篇思考题集锦（三）</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇">03.设计篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/01"><span>21 |  代码重复：搞定代码重复的三个绝招</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/02"><span>22 | 接口设计：系统间对话的语言，一定要统一</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/03"><span>23 | 缓存设计：缓存可以锦上添花也可以落井下石</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/04"><span>24 | 业务代码写完，就意味着生产就绪了？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/05"><span>25 | 异步处理好用，但非常容易用错</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/06"><span>26 | 数据存储：NoSQL与RDBMS如何取长补短、相辅相成？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/07"><span>答疑篇：设计篇思考题答案合集</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇">04.安全篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/01"><span>27 | 数据源头：任何客户端的东西都不可信任</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/02"><span>28 | 安全兜底：涉及钱时，必须考虑防刷、限量和防重</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/03"><span>29 | 数据和代码：数据就是数据，代码就是代码</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/04"><span>30 | 如何正确保存和传输敏感数据？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/05"><span>答疑篇：安全篇思考题答案合集</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐">05.加餐</a><ul><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/01"><span>31 | 加餐1：带你吃透课程中Java 8的那些重要知识点（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/02"><span>32 | 加餐2：带你吃透课程中Java 8的那些重要知识点（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/03"><span>33 | 加餐3：定位应用问题，排错套路很重要</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/04"><span>34 | 加餐4：分析定位Java问题，一定要用好这些工具（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/05"><span>35 | 加餐5：分析定位Java问题，一定要用好这些工具（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/06"><span>36 | 加餐6：这15年来，我是如何在工作中学习技术和英语的？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/07"><span>答疑篇：加餐篇思考题答案合集</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/08"><span>37 | 加餐7：程序员成长28计</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/09"><span>38 | 加餐8：Java程序从虚拟机迁移到Kubernetes的一些坑</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语">06.结束语</a><ul><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/01"><span>结束语 | 写代码时，如何才能尽量避免踩坑？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/02"><span>结课测试 | 关于Java业务开发的100个常见错误，你都明白其中缘由了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/03"><span>结课问卷获奖用户名单</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/summary">java业务开发常见错误100例</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="线程池的声明需要手动进行" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/03#线程池的声明需要手动进行"><span>线程池的声明需要手动进行</span></a></li><li title="线程池线程管理策略详解" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/03#线程池线程管理策略详解"><span>线程池线程管理策略详解</span></a></li><li title="务必确认清楚线程池本身是不是复用的" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/03#务必确认清楚线程池本身是不是复用的"><span>务必确认清楚线程池本身是不是复用的</span></a></li><li title="需要仔细斟酌线程池的混用策略" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/03#需要仔细斟酌线程池的混用策略"><span>需要仔细斟酌线程池的混用策略</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/03#重点回顾"><span>重点回顾</span></a></li><li title="思考与讨论" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/03#思考与讨论"><span>思考与讨论</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="03--线程池业务代码最常用也最容易犯错的组件"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/03#03--线程池业务代码最常用也最容易犯错的组件"><span class="icon icon-link"></span></a>03 | 线程池：业务代码最常用也最容易犯错的组件</h1><p>你好，我是朱晔。今天，我来讲讲使用线程池需要注意的一些问题。</p><p>在程序中，我们会用各种池化技术来缓存创建昂贵的对象，比如线程池、连接池、内存池。一般是预先创建一些对象放入池中，使用的时候直接取出使用，用完归还以便复用，还会通过一定的策略调整池中缓存对象的数量，实现池的动态伸缩。</p><p>由于线程的创建比较昂贵，随意、没有控制地创建大量线程会造成性能问题，因此短平快的任务一般考虑使用线程池来处理，而不是直接创建线程。</p><p>今天，我们就针对线程池这个话题展开讨论，通过三个生产事故，来看看使用线程池应该注意些什么。</p><h2 id="线程池的声明需要手动进行"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/03#线程池的声明需要手动进行"><span class="icon icon-link"></span></a>线程池的声明需要手动进行</h2><p>Java中的Executors类定义了一些快捷的工具方法，来帮助我们快速创建线程池。《阿里巴巴Java开发手册》中提到，禁止使用这些方法来创建线程池，而应该手动new ThreadPoolExecutor来创建线程池。这一条规则的背后，是大量血淋淋的生产事故，最典型的就是newFixedThreadPool和newCachedThreadPool，可能因为资源耗尽导致OOM问题。</p><p>首先，我们来看一下newFixedThreadPool为什么可能会出现OOM的问题。</p><p>我们写一段测试代码，来初始化一个单线程的FixedThreadPool，循环1亿次向线程池提交任务，每个任务都会创建一个比较大的字符串然后休眠一小时：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;oom1&quot;)</span></div><div class="token-line"><span class="token plain">    public void oom1() throws InterruptedException {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        ThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(1);</span></div><div class="token-line"><span class="token plain">        //打印线程池的信息，稍后我会解释这段代码</span></div><div class="token-line"><span class="token plain">        printStats(threadPool); </span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; 100000000; i++) {</span></div><div class="token-line"><span class="token plain">            threadPool.execute(() -&gt; {</span></div><div class="token-line"><span class="token plain">                String payload = IntStream.rangeClosed(1, 1000000)</span></div><div class="token-line"><span class="token plain">                        .mapToObj(__ -&gt; &quot;a&quot;)</span></div><div class="token-line"><span class="token plain">                        .collect(Collectors.joining(&quot;&quot;)) + UUID.randomUUID().toString();</span></div><div class="token-line"><span class="token plain">                try {</span></div><div class="token-line"><span class="token plain">                    TimeUnit.HOURS.sleep(1);</span></div><div class="token-line"><span class="token plain">                } catch (InterruptedException e) {</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">                log.info(payload);</span></div><div class="token-line"><span class="token plain">            });</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        threadPool.shutdown();</span></div><div class="token-line"><span class="token plain">        threadPool.awaitTermination(1, TimeUnit.HOURS);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>执行程序后不久，日志中就出现了如下OOM：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Exception in thread &quot;http-nio-45678-ClientPoller&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</span></div></pre></div><p>翻看newFixedThreadPool方法的源码不难发现，线程池的工作队列直接new了一个LinkedBlockingQueue，<strong>而默认构造方法的LinkedBlockingQueue是一个Integer.MAX_VALUE长度的队列，可以认为是无界的</strong>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public static ExecutorService newFixedThreadPool(int nThreads) {</span></div><div class="token-line"><span class="token plain">        return new ThreadPoolExecutor(nThreads, nThreads,</span></div><div class="token-line"><span class="token plain">                                      0L, TimeUnit.MILLISECONDS,</span></div><div class="token-line"><span class="token plain">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span></div><div class="token-line"><span class="token plain">            implements BlockingQueue&lt;E&gt;, java.io.Serializable {</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /**</span></div><div class="token-line"><span class="token plain">         * Creates a {@code LinkedBlockingQueue} with a capacity of</span></div><div class="token-line"><span class="token plain">         * {@link Integer#MAX_VALUE}.</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        public LinkedBlockingQueue() {</span></div><div class="token-line"><span class="token plain">            this(Integer.MAX_VALUE);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>虽然使用newFixedThreadPool可以把工作线程控制在固定的数量上，但任务队列是无界的。如果任务较多并且执行较慢的话，队列可能会快速积压，撑爆内存导致OOM。</p><p>我们再把刚才的例子稍微改一下，改为使用newCachedThreadPool方法来获得线程池。程序运行不久后，同样看到了如下OOM异常：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[11:30:30.487] [http-nio-45678-exec-1] [ERROR] [.a.c.c.C.[.[.[/].[dispatcherServlet]:175 ] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Handler dispatch failed; nested exception is java.lang.OutOfMemoryError: unable to create new native thread] with root cause</span></div><div class="token-line"><span class="token plain">    java.lang.OutOfMemoryError: unable to create new native thread</span></div></pre></div><p>从日志中可以看到，这次OOM的原因是无法创建线程，翻看newCachedThreadPool的源码可以看到，<strong>这种线程池的最大线程数是Integer.MAX_VALUE，可以认为是没有上限的，而其工作队列SynchronousQueue是一个没有存储空间的阻塞队列</strong>。这意味着，只要有请求到来，就必须找到一条工作线程来处理，如果当前没有空闲的线程就再创建一条新的。</p><p>由于我们的任务需要1小时才能执行完成，大量的任务进来后会创建大量的线程。我们知道线程是需要分配一定的内存空间作为线程栈的，比如1MB，因此无限制创建线程必然会导致OOM：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public static ExecutorService newCachedThreadPool() {</span></div><div class="token-line"><span class="token plain">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span></div><div class="token-line"><span class="token plain">                                      60L, TimeUnit.SECONDS,</span></div><div class="token-line"><span class="token plain">                                      new SynchronousQueue&lt;Runnable&gt;());</span></div></pre></div><p>其实，大部分Java开发同学知道这两种线程池的特性，只是抱有侥幸心理，觉得只是使用线程池做一些轻量级的任务，不可能造成队列积压或开启大量线程。</p><p>但，现实往往是残酷的。我之前就遇到过这么一个事故：用户注册后，我们调用一个外部服务去发送短信，发送短信接口正常时可以在100毫秒内响应，TPS 100的注册量，CachedThreadPool能稳定在占用10个左右线程的情况下满足需求。在某个时间点，外部短信服务不可用了，我们调用这个服务的超时又特别长，比如1分钟，1分钟可能就进来了6000用户，产生6000个发送短信的任务，需要6000个线程，没多久就因为无法创建线程导致了OOM，整个应用程序崩溃。</p><p>因此，<strong>我同样不建议使用Executors提供的两种快捷的线程池，原因如下</strong>：</p><ul><li>我们需要根据自己的场景、并发情况来评估线程池的几个核心参数，包括核心线程数、最大线程数、线程回收策略、工作队列的类型，以及拒绝策略，确保线程池的工作行为符合需求，一般都需要设置有界的工作队列和可控的线程数。</li><li>任何时候，都应该为自定义线程池指定有意义的名称，以方便排查问题。当出现线程数量暴增、线程死锁、线程占用大量CPU、线程执行出现异常等问题时，我们往往会抓取线程栈。此时，有意义的线程名称，就可以方便我们定位问题。</li></ul><p>除了建议手动声明线程池以外，我还建议<strong>用一些监控手段来观察线程池的状态</strong>。线程池这个组件往往会表现得任劳任怨、默默无闻，除非是出现了拒绝策略，否则压力再大都不会抛出一个异常。如果我们能提前观察到线程池队列的积压，或者线程数量的快速膨胀，往往可以提早发现并解决问题。</p><h2 id="线程池线程管理策略详解"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/03#线程池线程管理策略详解"><span class="icon icon-link"></span></a>线程池线程管理策略详解</h2><p>在之前的Demo中，我们用一个printStats方法实现了最简陋的监控，每秒输出一次线程池的基本内部信息，包括线程数、活跃线程数、完成了多少任务，以及队列中还有多少积压任务等信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private void printStats(ThreadPoolExecutor threadPool) {</span></div><div class="token-line"><span class="token plain">       Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(() -&gt; {</span></div><div class="token-line"><span class="token plain">            log.info(&quot;=========================&quot;);</span></div><div class="token-line"><span class="token plain">            log.info(&quot;Pool Size: {}&quot;, threadPool.getPoolSize());</span></div><div class="token-line"><span class="token plain">            log.info(&quot;Active Threads: {}&quot;, threadPool.getActiveCount());</span></div><div class="token-line"><span class="token plain">            log.info(&quot;Number of Tasks Completed: {}&quot;, threadPool.getCompletedTaskCount());</span></div><div class="token-line"><span class="token plain">            log.info(&quot;Number of Tasks in Queue: {}&quot;, threadPool.getQueue().size());</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            log.info(&quot;=========================&quot;);</span></div><div class="token-line"><span class="token plain">        }, 0, 1, TimeUnit.SECONDS);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接下来，我们就利用这个方法来观察一下线程池的基本特性吧。</p><p>首先，自定义一个线程池。这个线程池具有2个核心线程、5个最大线程、使用容量为10的ArrayBlockingQueue阻塞队列作为工作队列，使用默认的AbortPolicy拒绝策略，也就是任务添加到线程池失败会抛出RejectedExecutionException。此外，我们借助了Jodd类库的ThreadFactoryBuilder方法来构造一个线程工厂，实现线程池线程的自定义命名。</p><p>然后，我们写一段测试代码来观察线程池管理线程的策略。测试代码的逻辑为，每次间隔1秒向线程池提交任务，循环20次，每个任务需要10秒才能执行完成，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;right&quot;)</span></div><div class="token-line"><span class="token plain">    public int right() throws InterruptedException {</span></div><div class="token-line"><span class="token plain">        //使用一个计数器跟踪完成的任务数</span></div><div class="token-line"><span class="token plain">        AtomicInteger atomicInteger = new AtomicInteger();</span></div><div class="token-line"><span class="token plain">        //创建一个具有2个核心线程、5个最大线程，使用容量为10的ArrayBlockingQueue阻塞队列作为工作队列的线程池，使用默认的AbortPolicy拒绝策略</span></div><div class="token-line"><span class="token plain">        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(</span></div><div class="token-line"><span class="token plain">                2, 5,</span></div><div class="token-line"><span class="token plain">                5, TimeUnit.SECONDS,</span></div><div class="token-line"><span class="token plain">                new ArrayBlockingQueue&lt;&gt;(10),</span></div><div class="token-line"><span class="token plain">                new ThreadFactoryBuilder().setNameFormat(&quot;demo-threadpool-%d&quot;).get(),</span></div><div class="token-line"><span class="token plain">                new ThreadPoolExecutor.AbortPolicy());</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        printStats(threadPool);</span></div><div class="token-line"><span class="token plain">        //每隔1秒提交一次，一共提交20次任务</span></div><div class="token-line"><span class="token plain">        IntStream.rangeClosed(1, 20).forEach(i -&gt; {</span></div><div class="token-line"><span class="token plain">            try {</span></div><div class="token-line"><span class="token plain">                TimeUnit.SECONDS.sleep(1);</span></div><div class="token-line"><span class="token plain">            } catch (InterruptedException e) {</span></div><div class="token-line"><span class="token plain">                e.printStackTrace();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            int id = atomicInteger.incrementAndGet();</span></div><div class="token-line"><span class="token plain">            try {</span></div><div class="token-line"><span class="token plain">                threadPool.submit(() -&gt; {</span></div><div class="token-line"><span class="token plain">                    log.info(&quot;{} started&quot;, id);</span></div><div class="token-line"><span class="token plain">                    //每个任务耗时10秒</span></div><div class="token-line"><span class="token plain">                    try {</span></div><div class="token-line"><span class="token plain">                        TimeUnit.SECONDS.sleep(10);</span></div><div class="token-line"><span class="token plain">                    } catch (InterruptedException e) {</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                    log.info(&quot;{} finished&quot;, id);</span></div><div class="token-line"><span class="token plain">                });</span></div><div class="token-line"><span class="token plain">            } catch (Exception ex) {</span></div><div class="token-line"><span class="token plain">                //提交出现异常的话，打印出错信息并为计数器减一</span></div><div class="token-line"><span class="token plain">                log.error(&quot;error submitting task {}&quot;, id, ex);</span></div><div class="token-line"><span class="token plain">                atomicInteger.decrementAndGet();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        TimeUnit.SECONDS.sleep(60);</span></div><div class="token-line"><span class="token plain">        return atomicInteger.intValue();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>60秒后页面输出了17，有3次提交失败了：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage4b2c4b820e0b24ce0deefbf2dd7af295c32c.51c65cf8.png" alt=""/></p><p>并且日志中也出现了3次类似的错误信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[14:24:52.879] [http-nio-45678-exec-1] [ERROR] [.t.c.t.demo1.ThreadPoolOOMController:103 ] - error submitting task 18</span></div><div class="token-line"><span class="token plain">    java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@163a2dec rejected from java.util.concurrent.ThreadPoolExecutor@18061ad2[Running, pool size = 5, active threads = 5, queued tasks = 10, completed tasks = 2]</span></div></pre></div><p>我们把printStats方法打印出的日志绘制成图表，得出如下曲线：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimaged81ed819035f60bf1c0022a98051d50e031e.ea118f68.png" alt=""/></p><p><strong>至此，我们可以总结出线程池默认的工作行为</strong>：</p><ul><li>不会初始化corePoolSize个线程，有任务来了才创建工作线程；</li><li>当核心线程满了之后不会立即扩容线程池，而是把任务堆积到工作队列中；</li><li>当工作队列满了后扩容线程池，一直到线程个数达到maximumPoolSize为止；</li><li>如果队列已满且达到了最大线程后还有任务进来，按照拒绝策略处理；</li><li>当线程数大于核心线程数时，线程等待keepAliveTime后还是没有任务需要处理的话，收缩线程到核心线程数。</li></ul><p>了解这个策略，有助于我们根据实际的容量规划需求，为线程池设置合适的初始化参数。当然，我们也可以通过一些手段来改变这些默认工作行为，比如：</p><ul><li>声明线程池后立即调用prestartAllCoreThreads方法，来启动所有核心线程；</li><li>传入true给allowCoreThreadTimeOut方法，来让线程池在空闲的时候同样回收核心线程。</li></ul><p>不知道你有没有想过：Java线程池是先用工作队列来存放来不及处理的任务，满了之后再扩容线程池。当我们的工作队列设置得很大时，最大线程数这个参数显得没有意义，因为队列很难满，或者到满的时候再去扩容线程池已经于事无补了。</p><p>那么，**我们有没有办法让线程池****更激进一点，优先开启更多的线程，而把队列当成一个后备方案呢？**比如我们这个例子，任务执行得很慢，需要10秒，如果线程池可以优先扩容到5个最大线程，那么这些任务最终都可以完成，而不会因为线程池扩容过晚导致慢任务来不及处理。</p><p>限于篇幅，这里我只给你一个大致思路：</p><ol><li>由于线程池在工作队列满了无法入队的情况下会扩容线程池，那么我们是否可以重写队列的offer方法，造成这个队列已满的假象呢？</li><li>由于我们Hack了队列，在达到了最大线程后势必会触发拒绝策略，那么能否实现一个自定义的拒绝策略处理程序，这个时候再把任务真正插入队列呢？</li></ol><p>接下来，就请你动手试试看如何实现这样一个“弹性”线程池吧。Tomcat线程池也实现了类似的效果，可供你借鉴。</p><h2 id="务必确认清楚线程池本身是不是复用的"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/03#务必确认清楚线程池本身是不是复用的"><span class="icon icon-link"></span></a>务必确认清楚线程池本身是不是复用的</h2><p>不久之前我遇到了这样一个事故：某项目生产环境时不时有报警提示线程数过多，超过2000个，收到报警后查看监控发现，瞬时线程数比较多但过一会儿又会降下来，线程数抖动很厉害，而应用的访问量变化不大。</p><p>为了定位问题，我们在线程数比较高的时候进行线程栈抓取，抓取后发现内存中有1000多个自定义线程池。一般而言，线程池肯定是复用的，有5个以内的线程池都可以认为正常，而1000多个线程池肯定不正常。</p><p>在项目代码里，我们没有搜到声明线程池的地方，搜索execute关键字后定位到，原来是业务代码调用了一个类库来获得线程池，类似如下的业务代码：调用ThreadPoolHelper的getThreadPool方法来获得线程池，然后提交数个任务到线程池处理，看不出什么异常。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;wrong&quot;)</span></div><div class="token-line"><span class="token plain">    public String wrong() throws InterruptedException {</span></div><div class="token-line"><span class="token plain">        ThreadPoolExecutor threadPool = ThreadPoolHelper.getThreadPool();</span></div><div class="token-line"><span class="token plain">        IntStream.rangeClosed(1, 10).forEach(i -&gt; {</span></div><div class="token-line"><span class="token plain">            threadPool.execute(() -&gt; {</span></div><div class="token-line"><span class="token plain">                ...</span></div><div class="token-line"><span class="token plain">                try {</span></div><div class="token-line"><span class="token plain">                    TimeUnit.SECONDS.sleep(1);</span></div><div class="token-line"><span class="token plain">                } catch (InterruptedException e) {</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            });</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">        return &quot;OK&quot;;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>但是，来到ThreadPoolHelper的实现让人大跌眼镜，<strong>getThreadPool方法居然是每次都使用Executors.newCachedThreadPool来创建一个线程池</strong>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class ThreadPoolHelper {</span></div><div class="token-line"><span class="token plain">        public static ThreadPoolExecutor getThreadPool() {</span></div><div class="token-line"><span class="token plain">            //线程池没有复用</span></div><div class="token-line"><span class="token plain">            return (ThreadPoolExecutor) Executors.newCachedThreadPool();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>通过上一小节的学习，我们可以想到newCachedThreadPool会在需要时创建必要多的线程，业务代码的一次业务操作会向线程池提交多个慢任务，这样执行一次业务操作就会开启多个线程。如果业务操作并发量较大的话，的确有可能一下子开启几千个线程。</p><p>那，为什么我们能在监控中看到线程数量会下降，而不会撑爆内存呢？</p><p>回到newCachedThreadPool的定义就会发现，它的核心线程数是0，而keepAliveTime是60秒，也就是在60秒之后所有的线程都是可以回收的。好吧，就因为这个特性，我们的业务程序死得没太难看。</p><p>要修复这个Bug也很简单，使用一个静态字段来存放线程池的引用，返回线程池的代码直接返回这个静态字段即可。这里一定要记得我们的最佳实践，手动创建线程池。修复后的ThreadPoolHelper类如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class ThreadPoolHelper {</span></div><div class="token-line"><span class="token plain">    	private static ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(</span></div><div class="token-line"><span class="token plain">    		10, 50,</span></div><div class="token-line"><span class="token plain">    		2, TimeUnit.SECONDS,</span></div><div class="token-line"><span class="token plain">    		new ArrayBlockingQueue&lt;&gt;(1000),</span></div><div class="token-line"><span class="token plain">    		new ThreadFactoryBuilder().setNameFormat(&quot;demo-threadpool-%d&quot;).get());</span></div><div class="token-line"><span class="token plain">    	public static ThreadPoolExecutor getRightThreadPool() {</span></div><div class="token-line"><span class="token plain">    		return threadPoolExecutor;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="需要仔细斟酌线程池的混用策略"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/03#需要仔细斟酌线程池的混用策略"><span class="icon icon-link"></span></a>需要仔细斟酌线程池的混用策略</h2><p>线程池的意义在于复用，那这是不是意味着程序应该始终使用一个线程池呢？</p><p>当然不是。通过第一小节的学习我们知道，<strong>要根据任务的“轻重缓急”来指定线程池的核心参数，包括线程数、回收策略和任务队列</strong>：</p><ul><li>对于执行比较慢、数量不大的IO任务，或许要考虑更多的线程数，而不需要太大的队列。</li><li>而对于吞吐量较大的计算型任务，线程数量不宜过多，可以是CPU核数或核数*2（理由是，线程一定调度到某个CPU进行执行，如果任务本身是CPU绑定的任务，那么过多的线程只会增加线程切换的开销，并不能提升吞吐量），但可能需要较长的队列来做缓冲。</li></ul><p>之前我也遇到过这么一个问题，业务代码使用了线程池异步处理一些内存中的数据，但通过监控发现处理得非常慢，整个处理过程都是内存中的计算不涉及IO操作，也需要数秒的处理时间，应用程序CPU占用也不是特别高，有点不可思议。</p><p>经排查发现，业务代码使用的线程池，还被一个后台的文件批处理任务用到了。</p><p>或许是够用就好的原则，这个线程池只有2个核心线程，最大线程也是2，使用了容量为100的ArrayBlockingQueue作为工作队列，使用了CallerRunsPolicy拒绝策略：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private static ThreadPoolExecutor threadPool = new ThreadPoolExecutor(</span></div><div class="token-line"><span class="token plain">            2, 2,</span></div><div class="token-line"><span class="token plain">            1, TimeUnit.HOURS,</span></div><div class="token-line"><span class="token plain">            new ArrayBlockingQueue&lt;&gt;(100),</span></div><div class="token-line"><span class="token plain">            new ThreadFactoryBuilder().setNameFormat(&quot;batchfileprocess-threadpool-%d&quot;).get(),</span></div><div class="token-line"><span class="token plain">            new ThreadPoolExecutor.CallerRunsPolicy());</span></div></pre></div><p>这里，我们模拟一下文件批处理的代码，在程序启动后通过一个线程开启死循环逻辑，不断向线程池提交任务，任务的逻辑是向一个文件中写入大量的数据：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@PostConstruct</span></div><div class="token-line"><span class="token plain">    public void init() {</span></div><div class="token-line"><span class="token plain">        printStats(threadPool);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        new Thread(() -&gt; {</span></div><div class="token-line"><span class="token plain">            //模拟需要写入的大量数据</span></div><div class="token-line"><span class="token plain">            String payload = IntStream.rangeClosed(1, 1_000_000)</span></div><div class="token-line"><span class="token plain">                    .mapToObj(__ -&gt; &quot;a&quot;)</span></div><div class="token-line"><span class="token plain">                    .collect(Collectors.joining(&quot;&quot;));</span></div><div class="token-line"><span class="token plain">            while (true) {</span></div><div class="token-line"><span class="token plain">                threadPool.execute(() -&gt; {</span></div><div class="token-line"><span class="token plain">                    try {</span></div><div class="token-line"><span class="token plain">                        //每次都是创建并写入相同的数据到相同的文件</span></div><div class="token-line"><span class="token plain">                        Files.write(Paths.get(&quot;demo.txt&quot;), Collections.singletonList(LocalTime.now().toString() + &quot;:&quot; + payload), UTF_8, CREATE, TRUNCATE_EXISTING);</span></div><div class="token-line"><span class="token plain">                    } catch (IOException e) {</span></div><div class="token-line"><span class="token plain">                        e.printStackTrace();</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                    log.info(&quot;batch file processing done&quot;);</span></div><div class="token-line"><span class="token plain">                });</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }).start();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以想象到，这个线程池中的2个线程任务是相当重的。通过printStats方法打印出的日志，我们观察下线程池的负担：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage495549c132595db60f109530e0dec55ccd55.4e7bc12c.png" alt=""/></p><p>可以看到，**线程池的2个线程始终处于活跃状态，队列也基本处于打满状态。**因为开启了CallerRunsPolicy拒绝处理策略，所以当线程满载队列也满的情况下，任务会在提交任务的线程，或者说调用execute方法的线程执行，也就是说不能认为提交到线程池的任务就一定是异步处理的。如果使用了CallerRunsPolicy策略，那么有可能异步任务变为同步执行。从日志的第四行也可以看到这点。这也是这个拒绝策略比较特别的原因。</p><p>不知道写代码的同学为什么设置这个策略，或许是测试时发现线程池因为任务处理不过来出现了异常，而又不希望线程池丢弃任务，所以最终选择了这样的拒绝策略。不管怎样，这些日志足以说明线程池是饱和状态。</p><p>可以想象到，业务代码复用这样的线程池来做内存计算，命运一定是悲惨的。我们写一段代码测试下，向线程池提交一个简单的任务，这个任务只是休眠10毫秒没有其他逻辑：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private Callable&lt;Integer&gt; calcTask() {</span></div><div class="token-line"><span class="token plain">        return () -&gt; {</span></div><div class="token-line"><span class="token plain">            TimeUnit.MILLISECONDS.sleep(10);</span></div><div class="token-line"><span class="token plain">            return 1;</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @GetMapping(&quot;wrong&quot;)</span></div><div class="token-line"><span class="token plain">    public int wrong() throws ExecutionException, InterruptedException {</span></div><div class="token-line"><span class="token plain">        return threadPool.submit(calcTask()).get();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们使用wrk工具对这个接口进行一个简单的压测，可以看到TPS为75，性能的确非常差。</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage9807989f7ab383e59e21751adb77a9b53507.e72ad7e6.png" alt=""/></p><p>细想一下，问题其实没有这么简单。因为原来执行IO任务的线程池使用的是CallerRunsPolicy策略，所以直接使用这个线程池进行异步计算的话，<strong>当线程池饱和的时候，计算任务会在执行Web请求的Tomcat线程执行，这时就会进一步影响到其他同步处理的线程，甚至造成整个应用程序崩溃</strong>。</p><p>解决方案很简单，使用独立的线程池来做这样的“计算任务”即可。计算任务打了双引号，是因为我们的模拟代码执行的是休眠操作，并不属于CPU绑定的操作，更类似IO绑定的操作，如果线程池线程数设置太小会限制吞吐能力：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private static ThreadPoolExecutor asyncCalcThreadPool = new ThreadPoolExecutor(</span></div><div class="token-line"><span class="token plain">    	200, 200,</span></div><div class="token-line"><span class="token plain">    	1, TimeUnit.HOURS,</span></div><div class="token-line"><span class="token plain">    	new ArrayBlockingQueue&lt;&gt;(1000),</span></div><div class="token-line"><span class="token plain">    	new ThreadFactoryBuilder().setNameFormat(&quot;asynccalc-threadpool-%d&quot;).get());</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @GetMapping(&quot;right&quot;)</span></div><div class="token-line"><span class="token plain">    public int right() throws ExecutionException, InterruptedException {</span></div><div class="token-line"><span class="token plain">    	return asyncCalcThreadPool.submit(calcTask()).get();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>使用单独的线程池改造代码后再来测试一下性能，TPS提高到了1727：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimagec206c21eed38ccd18758d38745dd09496a06.7663f063.png" alt=""/></p><p>可以看到，盲目复用线程池混用线程的问题在于，别人定义的线程池属性不一定适合你的任务，而且混用会相互干扰。这就好比，我们往往会用虚拟化技术来实现资源的隔离，而不是让所有应用程序都直接使用物理机。</p><p>就线程池混用问题，我想再和你补充一个坑：<strong>Java 8的parallel stream功能，可以让我们很方便地并行处理集合中的元素，其背后是共享同一个ForkJoinPool，默认并行度是CPU核数-1</strong>。对于CPU绑定的任务来说，使用这样的配置比较合适，但如果集合操作涉及同步IO操作的话（比如数据库操作、外部服务调用等），建议自定义一个ForkJoinPool（或普通线程池）。你可以参考<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/209494">第一讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的相关Demo。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/03#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>线程池管理着线程，线程又属于宝贵的资源，有许多应用程序的性能问题都来自线程池的配置和使用不当。在今天的学习中，我通过三个和线程池相关的生产事故，和你分享了使用线程池的几个最佳实践。</p><p>第一，Executors类提供的一些快捷声明线程池的方法虽然简单，但隐藏了线程池的参数细节。因此，使用线程池时，我们一定要根据场景和需求配置合理的线程数、任务队列、拒绝策略、线程回收策略，并对线程进行明确的命名方便排查问题。</p><p>第二，既然使用了线程池就需要确保线程池是在复用的，每次new一个线程池出来可能比不用线程池还糟糕。如果你没有直接声明线程池而是使用其他同学提供的类库来获得一个线程池，请务必查看源码，以确认线程池的实例化方式和配置是符合预期的。</p><p>第三，复用线程池不代表应用程序始终使用同一个线程池，我们应该根据任务的性质来选用不同的线程池。特别注意IO绑定的任务和CPU绑定的任务对于线程池属性的偏好，如果希望减少任务间的相互干扰，考虑按需使用隔离的线程池。</p><p>最后我想强调的是，<strong>线程池作为应用程序内部的核心组件往往缺乏监控</strong>（如果你使用类似RabbitMQ这样的MQ中间件，运维同学一般会帮我们做好中间件监控），往往到程序崩溃后才发现线程池的问题，很被动。在设计篇中我们会重新谈及这个问题及其解决方案。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a target="_blank" rel="noopener noreferrer" href="https://github.com/JosephZhu1983/java-common-mistakes">这个链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>查看。</p><h2 id="思考与讨论"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/03#思考与讨论"><span class="icon icon-link"></span></a>思考与讨论</h2><ol><li>在第一节中我们提到，或许一个激进创建线程的弹性线程池更符合我们的需求，你能给出相关的实现吗？实现后再测试一下，是否所有的任务都可以正常处理完成呢？</li><li>在第二节中，我们改进了ThreadPoolHelper使其能够返回复用的线程池。如果我们不小心每次都创建了这样一个自定义的线程池（10核心线程，50最大线程，2秒回收的），反复执行测试接口线程，最终可以被回收吗？会出现OOM问题吗？</li></ol><p>你还遇到过线程池相关的其他坑吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/java业务开发常见错误100例/02.代码篇/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:06:36</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-java/umi.fde43fdb.js"></script>
  </body>
</html>
