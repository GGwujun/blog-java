<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-java/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-java";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>04 | 连接池：别让连接池帮了倒忙 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/java业务开发常见错误100例/02.代码篇/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java业务开发常见错误100例/01.开篇词">01.开篇词</a><ul><li><a href="/blog-java/java业务开发常见错误100例/01.开篇词/01"><span>开篇词 | 业务代码真的会有这么多坑？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例/02.代码篇">02.代码篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/01"><span>01 | 使用了并发工具类库，线程安全就高枕无忧了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/02"><span>02 | 代码加锁：不要让“锁”事成为烦心事</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/03"><span>03 | 线程池：业务代码最常用也最容易犯错的组件</span></a></li><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例/02.代码篇/04"><span>04 | 连接池：别让连接池帮了倒忙</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/05"><span>05 | HTTP调用：你考虑到超时、重试、并发了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/06"><span>06 | 20%的业务代码的Spring声明式事务，可能都没处理正确</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/07"><span>答疑篇：代码篇思考题集锦（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/08"><span>07 | 数据库索引：索引并不是万能药</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/09"><span>08 | 判等问题：程序里如何确定你就是你？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/10"><span>09 | 数值计算：注意精度、舍入和溢出问题</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/11"><span>10 | 集合类：坑满地的List列表操作</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/12"><span>11 | 空值处理：分不清楚的null和恼人的空指针</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/13"><span>12 | 异常处理：别让自己在出问题的时候变为瞎子</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/14"><span>答疑篇：代码篇思考题集锦（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/15"><span>13 | 日志：日志记录真没你想象的那么简单</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/16"><span>14 | 文件IO：实现高效正确的文件读写并非易事</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/17"><span>15 | 序列化：一来一回你还是原来的你吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/18"><span>16 | 用好Java 8的日期时间类，少踩一些“老三样”的坑</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/19"><span>17 | 别以为“自动挡”就不可能出现OOM</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/20"><span>18 | 当反射、注解和泛型遇到OOP时，会有哪些坑？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/21"><span>19 | Spring框架：IoC和AOP是扩展的核心</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/22"><span>20 | Spring框架：框架帮我们做了很多工作也带来了复杂度</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/23"><span>答疑篇：代码篇思考题集锦（三）</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇">03.设计篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/01"><span>21 |  代码重复：搞定代码重复的三个绝招</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/02"><span>22 | 接口设计：系统间对话的语言，一定要统一</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/03"><span>23 | 缓存设计：缓存可以锦上添花也可以落井下石</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/04"><span>24 | 业务代码写完，就意味着生产就绪了？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/05"><span>25 | 异步处理好用，但非常容易用错</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/06"><span>26 | 数据存储：NoSQL与RDBMS如何取长补短、相辅相成？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/07"><span>答疑篇：设计篇思考题答案合集</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇">04.安全篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/01"><span>27 | 数据源头：任何客户端的东西都不可信任</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/02"><span>28 | 安全兜底：涉及钱时，必须考虑防刷、限量和防重</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/03"><span>29 | 数据和代码：数据就是数据，代码就是代码</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/04"><span>30 | 如何正确保存和传输敏感数据？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/05"><span>答疑篇：安全篇思考题答案合集</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐">05.加餐</a><ul><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/01"><span>31 | 加餐1：带你吃透课程中Java 8的那些重要知识点（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/02"><span>32 | 加餐2：带你吃透课程中Java 8的那些重要知识点（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/03"><span>33 | 加餐3：定位应用问题，排错套路很重要</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/04"><span>34 | 加餐4：分析定位Java问题，一定要用好这些工具（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/05"><span>35 | 加餐5：分析定位Java问题，一定要用好这些工具（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/06"><span>36 | 加餐6：这15年来，我是如何在工作中学习技术和英语的？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/07"><span>答疑篇：加餐篇思考题答案合集</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/08"><span>37 | 加餐7：程序员成长28计</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/09"><span>38 | 加餐8：Java程序从虚拟机迁移到Kubernetes的一些坑</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语">06.结束语</a><ul><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/01"><span>结束语 | 写代码时，如何才能尽量避免踩坑？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/02"><span>结课测试 | 关于Java业务开发的100个常见错误，你都明白其中缘由了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/03"><span>结课问卷获奖用户名单</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/summary">java业务开发常见错误100例</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="注意鉴别客户端SDK是否基于连接池" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/04#注意鉴别客户端sdk是否基于连接池"><span>注意鉴别客户端SDK是否基于连接池</span></a></li><li title="使用连接池务必确保复用" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/04#使用连接池务必确保复用"><span>使用连接池务必确保复用</span></a></li><li title="连接池的配置不是一成不变的" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/04#连接池的配置不是一成不变的"><span>连接池的配置不是一成不变的</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/04#重点回顾"><span>重点回顾</span></a></li><li title="思考与讨论" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/04#思考与讨论"><span>思考与讨论</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="04--连接池别让连接池帮了倒忙"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/04#04--连接池别让连接池帮了倒忙"><span class="icon icon-link"></span></a>04 | 连接池：别让连接池帮了倒忙</h1><p>你好，我是朱晔。今天，我们来聊聊使用连接池需要注意的问题。</p><p>在上一讲，我们学习了使用线程池需要注意的问题。今天，我再与你说说另一种很重要的池化技术，即连接池。</p><p>我先和你说说连接池的结构。连接池一般对外提供获得连接、归还连接的接口给客户端使用，并暴露最小空闲连接数、最大连接数等可配置参数，在内部则实现连接建立、连接心跳保持、连接管理、空闲连接回收、连接可用性检测等功能。连接池的结构示意图，如下所示：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage167e1685d9db2602e1de8483de171af6fd7e.37b9dd80.png" alt=""/></p><p>业务项目中经常会用到的连接池，主要是数据库连接池、Redis连接池和HTTP连接池。所以，今天我就以这三种连接池为例，和你聊聊使用和配置连接池容易出错的地方。</p><h2 id="注意鉴别客户端sdk是否基于连接池"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/04#注意鉴别客户端sdk是否基于连接池"><span class="icon icon-link"></span></a>注意鉴别客户端SDK是否基于连接池</h2><p>在使用三方客户端进行网络通信时，我们首先要确定客户端SDK是否是基于连接池技术实现的。我们知道，TCP是面向连接的基于字节流的协议：</p><ul><li>面向连接，意味着连接需要先创建再使用，创建连接的三次握手有一定开销；</li><li>基于字节流，意味着字节是发送数据的最小单元，TCP协议本身无法区分哪几个字节是完整的消息体，也无法感知是否有多个客户端在使用同一个TCP连接，TCP只是一个读写数据的管道。</li></ul><p>如果客户端SDK没有使用连接池，而直接是TCP连接，那么就需要考虑每次建立TCP连接的开销，<strong>并且因为TCP基于字节流，在多线程的情况下对同一连接进行复用，可能会产生线程安全问题</strong>。</p><p>我们先看一下涉及TCP连接的客户端SDK，对外提供API的三种方式。在面对各种三方客户端的时候，只有先识别出其属于哪一种，才能理清楚使用方式。</p><ul><li>连接池和连接分离的API：有一个XXXPool类负责连接池实现，先从其获得连接XXXConnection，然后用获得的连接进行服务端请求，完成后使用者需要归还连接。通常，XXXPool是线程安全的，可以并发获取和归还连接，而XXXConnection是非线程安全的。对应到连接池的结构示意图中，XXXPool就是右边连接池那个框，左边的客户端是我们自己的代码。</li><li>内部带有连接池的API：对外提供一个XXXClient类，通过这个类可以直接进行服务端请求；这个类内部维护了连接池，SDK使用者无需考虑连接的获取和归还问题。一般而言，XXXClient是线程安全的。对应到连接池的结构示意图中，整个API就是蓝色框包裹的部分。</li><li>非连接池的API：一般命名为XXXConnection，以区分其是基于连接池还是单连接的，而不建议命名为XXXClient或直接是XXX。直接连接方式的API基于单一连接，每次使用都需要创建和断开连接，性能一般，且通常不是线程安全的。对应到连接池的结构示意图中，这种形式相当于没有右边连接池那个框，客户端直接连接服务端创建连接。</li></ul><p>虽然上面提到了SDK一般的命名习惯，但不排除有一些客户端特立独行，因此在使用三方SDK时，一定要先查看官方文档了解其最佳实践，或是在类似Stackoverflow的网站搜索XXX threadsafe/singleton字样看看大家的回复，也可以一层一层往下看源码，直到定位到原始Socket来判断Socket和客户端API的对应关系。</p><p>明确了SDK连接池的实现方式后，我们就大概知道了使用SDK的最佳实践：</p><ul><li>如果是分离方式，那么连接池本身一般是线程安全的，可以复用。每次使用需要从连接池获取连接，使用后归还，归还的工作由使用者负责。</li><li>如果是内置连接池，SDK会负责连接的获取和归还，使用的时候直接复用客户端。</li><li>如果SDK没有实现连接池（大多数中间件、数据库的客户端SDK都会支持连接池），那通常不是线程安全的，而且短连接的方式性能不会很高，使用的时候需要考虑是否自己封装一个连接池。</li></ul><p>接下来，我就以Java中用于操作Redis最常见的库Jedis为例，从源码角度分析下Jedis类到底属于哪种类型的API，直接在多线程环境下复用一个连接会产生什么问题，以及如何用最佳实践来修复这个问题。</p><p>首先，向Redis初始化2组数据，Key=a、Value=1，Key=b、Value=2：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@PostConstruct</span></div><div class="token-line"><span class="token plain">    public void init() {</span></div><div class="token-line"><span class="token plain">        try (Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379)) {</span></div><div class="token-line"><span class="token plain">            Assert.isTrue(&quot;OK&quot;.equals(jedis.set(&quot;a&quot;, &quot;1&quot;)), &quot;set a = 1 return OK&quot;);</span></div><div class="token-line"><span class="token plain">            Assert.isTrue(&quot;OK&quot;.equals(jedis.set(&quot;b&quot;, &quot;2&quot;)), &quot;set b = 2 return OK&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后，启动两个线程，共享操作同一个Jedis实例，每一个线程循环1000次，分别读取Key为a和b的Value，判断是否分别为1和2：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span></div><div class="token-line"><span class="token plain">    new Thread(() -&gt; {</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; 1000; i++) {</span></div><div class="token-line"><span class="token plain">            String result = jedis.get(&quot;a&quot;);</span></div><div class="token-line"><span class="token plain">            if (!result.equals(&quot;1&quot;)) {</span></div><div class="token-line"><span class="token plain">                log.warn(&quot;Expect a to be 1 but found {}&quot;, result);</span></div><div class="token-line"><span class="token plain">                return;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }).start();</span></div><div class="token-line"><span class="token plain">    new Thread(() -&gt; {</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; 1000; i++) {</span></div><div class="token-line"><span class="token plain">            String result = jedis.get(&quot;b&quot;);</span></div><div class="token-line"><span class="token plain">            if (!result.equals(&quot;2&quot;)) {</span></div><div class="token-line"><span class="token plain">                log.warn(&quot;Expect b to be 2 but found {}&quot;, result);</span></div><div class="token-line"><span class="token plain">                return;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }).start();</span></div><div class="token-line"><span class="token plain">    TimeUnit.SECONDS.sleep(5);</span></div></pre></div><p>执行程序多次，可以看到日志中出现了各种奇怪的异常信息，有的是读取Key为b的Value读取到了1，有的是流非正常结束，还有的是连接关闭异常：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//错误1</span></div><div class="token-line"><span class="token plain">    [14:56:19.069] [Thread-28] [WARN ] [.t.c.c.redis.JedisMisreuseController:45  ] - Expect b to be 2 but found 1</span></div><div class="token-line"><span class="token plain">    //错误2</span></div><div class="token-line"><span class="token plain">    redis.clients.jedis.exceptions.JedisConnectionException: Unexpected end of stream.</span></div><div class="token-line"><span class="token plain">    	at redis.clients.jedis.util.RedisInputStream.ensureFill(RedisInputStream.java:202)</span></div><div class="token-line"><span class="token plain">    	at redis.clients.jedis.util.RedisInputStream.readLine(RedisInputStream.java:50)</span></div><div class="token-line"><span class="token plain">    	at redis.clients.jedis.Protocol.processError(Protocol.java:114)</span></div><div class="token-line"><span class="token plain">    	at redis.clients.jedis.Protocol.process(Protocol.java:166)</span></div><div class="token-line"><span class="token plain">    	at redis.clients.jedis.Protocol.read(Protocol.java:220)</span></div><div class="token-line"><span class="token plain">    	at redis.clients.jedis.Connection.readProtocolWithCheckingBroken(Connection.java:318)</span></div><div class="token-line"><span class="token plain">    	at redis.clients.jedis.Connection.getBinaryBulkReply(Connection.java:255)</span></div><div class="token-line"><span class="token plain">    	at redis.clients.jedis.Connection.getBulkReply(Connection.java:245)</span></div><div class="token-line"><span class="token plain">    	at redis.clients.jedis.Jedis.get(Jedis.java:181)</span></div><div class="token-line"><span class="token plain">    	at org.geekbang.time.commonmistakes.connectionpool.redis.JedisMisreuseController.lambda$wrong$1(JedisMisreuseController.java:43)</span></div><div class="token-line"><span class="token plain">    	at java.lang.Thread.run(Thread.java:748)</span></div><div class="token-line"><span class="token plain">    //错误3</span></div><div class="token-line"><span class="token plain">    java.io.IOException: Socket Closed</span></div><div class="token-line"><span class="token plain">    	at java.net.AbstractPlainSocketImpl.getOutputStream(AbstractPlainSocketImpl.java:440)</span></div><div class="token-line"><span class="token plain">    	at java.net.Socket$3.run(Socket.java:954)</span></div><div class="token-line"><span class="token plain">    	at java.net.Socket$3.run(Socket.java:952)</span></div><div class="token-line"><span class="token plain">    	at java.security.AccessController.doPrivileged(Native Method)</span></div><div class="token-line"><span class="token plain">    	at java.net.Socket.getOutputStream(Socket.java:951)</span></div><div class="token-line"><span class="token plain">    	at redis.clients.jedis.Connection.connect(Connection.java:200)</span></div><div class="token-line"><span class="token plain">    	... 7 more</span></div></pre></div><p>让我们分析一下Jedis类的源码，搞清楚其中缘由吧。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands,</span></div><div class="token-line"><span class="token plain">        AdvancedJedisCommands, ScriptingCommands, BasicCommands, ClusterCommands, SentinelCommands, ModuleCommands {</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    public class BinaryJedis implements BasicCommands, BinaryJedisCommands, MultiKeyBinaryCommands,</span></div><div class="token-line"><span class="token plain">        AdvancedBinaryJedisCommands, BinaryScriptingCommands, Closeable {</span></div><div class="token-line"><span class="token plain">    	protected Client client = null;</span></div><div class="token-line"><span class="token plain">          ...</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class Client extends BinaryClient implements Commands {</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    public class BinaryClient extends Connection {</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    public class Connection implements Closeable {</span></div><div class="token-line"><span class="token plain">      private Socket socket;</span></div><div class="token-line"><span class="token plain">      private RedisOutputStream outputStream;</span></div><div class="token-line"><span class="token plain">      private RedisInputStream inputStream;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，Jedis继承了BinaryJedis，BinaryJedis中保存了单个Client的实例，Client最终继承了Connection，Connection中保存了单个Socket的实例，和Socket对应的两个读写流。因此，一个Jedis对应一个Socket连接。类图如下：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimagee70fe72120b1f6daf4a951e75c05b9191a0f.afe237ee.png" alt=""/></p><p>BinaryClient封装了各种Redis命令，其最终会调用基类Connection的方法，使用Protocol类发送命令。看一下Protocol类的sendCommand方法的源码，可以发现其发送命令时是直接操作RedisOutputStream写入字节。</p><p>我们在多线程环境下复用Jedis对象，其实就是在复用RedisOutputStream。<strong>如果多个线程在执行操作，那么既无法确保整条命令以一个原子操作写入Socket，也无法确保写入后、读取前没有其他数据写到远端</strong>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private static void sendCommand(final RedisOutputStream os, final byte[] command,</span></div><div class="token-line"><span class="token plain">    	  final byte[]... args) {</span></div><div class="token-line"><span class="token plain">    	try {</span></div><div class="token-line"><span class="token plain">    	  os.write(ASTERISK_BYTE);</span></div><div class="token-line"><span class="token plain">    	  os.writeIntCrLf(args.length + 1);</span></div><div class="token-line"><span class="token plain">    	  os.write(DOLLAR_BYTE);</span></div><div class="token-line"><span class="token plain">    	  os.writeIntCrLf(command.length);</span></div><div class="token-line"><span class="token plain">    	  os.write(command);</span></div><div class="token-line"><span class="token plain">    	  os.writeCrLf();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	  for (final byte[] arg : args) {</span></div><div class="token-line"><span class="token plain">    	    os.write(DOLLAR_BYTE);</span></div><div class="token-line"><span class="token plain">    	    os.writeIntCrLf(arg.length);</span></div><div class="token-line"><span class="token plain">    	    os.write(arg);</span></div><div class="token-line"><span class="token plain">    	    os.writeCrLf();</span></div><div class="token-line"><span class="token plain">    	  }</span></div><div class="token-line"><span class="token plain">    	} catch (IOException e) {</span></div><div class="token-line"><span class="token plain">    	  throw new JedisConnectionException(e);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>看到这里我们也可以理解了，为啥多线程情况下使用Jedis对象操作Redis会出现各种奇怪的问题。</p><p>比如，写操作互相干扰，多条命令相互穿插的话，必然不是合法的Redis命令，那么Redis会关闭客户端连接，导致连接断开；又比如，线程1和2先后写入了get a和get b操作的请求，Redis也返回了值1和2，但是线程2先读取了数据1就会出现数据错乱的问题。</p><p>修复方式是，使用Jedis提供的另一个线程安全的类JedisPool来获得Jedis的实例。JedisPool可以声明为static在多个线程之间共享，扮演连接池的角色。使用时，按需使用try-with-resources模式从JedisPool获得和归还Jedis实例。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private static JedisPool jedisPool = new JedisPool(&quot;127.0.0.1&quot;, 6379);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    new Thread(() -&gt; {</span></div><div class="token-line"><span class="token plain">        try (Jedis jedis = jedisPool.getResource()) {</span></div><div class="token-line"><span class="token plain">            for (int i = 0; i &lt; 1000; i++) {</span></div><div class="token-line"><span class="token plain">                String result = jedis.get(&quot;a&quot;);</span></div><div class="token-line"><span class="token plain">                if (!result.equals(&quot;1&quot;)) {</span></div><div class="token-line"><span class="token plain">                    log.warn(&quot;Expect a to be 1 but found {}&quot;, result);</span></div><div class="token-line"><span class="token plain">                    return;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }).start();</span></div><div class="token-line"><span class="token plain">    new Thread(() -&gt; {</span></div><div class="token-line"><span class="token plain">        try (Jedis jedis = jedisPool.getResource()) {</span></div><div class="token-line"><span class="token plain">            for (int i = 0; i &lt; 1000; i++) {</span></div><div class="token-line"><span class="token plain">                String result = jedis.get(&quot;b&quot;);</span></div><div class="token-line"><span class="token plain">                if (!result.equals(&quot;2&quot;)) {</span></div><div class="token-line"><span class="token plain">                    log.warn(&quot;Expect b to be 2 but found {}&quot;, result);</span></div><div class="token-line"><span class="token plain">                    return;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }).start();</span></div></pre></div><p>这样修复后，代码不再有线程安全问题了。此外，我们最好通过shutdownhook，在程序退出之前关闭JedisPool：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@PostConstruct</span></div><div class="token-line"><span class="token plain">    public void init() {</span></div><div class="token-line"><span class="token plain">        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {</span></div><div class="token-line"><span class="token plain">            jedisPool.close();</span></div><div class="token-line"><span class="token plain">        }));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>看一下Jedis类close方法的实现可以发现，如果Jedis是从连接池获取的话，那么close方法会调用连接池的return方法归还连接：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands,</span></div><div class="token-line"><span class="token plain">        AdvancedJedisCommands, ScriptingCommands, BasicCommands, ClusterCommands, SentinelCommands, ModuleCommands {</span></div><div class="token-line"><span class="token plain">      protected JedisPoolAbstract dataSource = null;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      @Override</span></div><div class="token-line"><span class="token plain">      public void close() {</span></div><div class="token-line"><span class="token plain">        if (dataSource != null) {</span></div><div class="token-line"><span class="token plain">          JedisPoolAbstract pool = this.dataSource;</span></div><div class="token-line"><span class="token plain">          this.dataSource = null;</span></div><div class="token-line"><span class="token plain">          if (client.isBroken()) {</span></div><div class="token-line"><span class="token plain">            pool.returnBrokenResource(this);</span></div><div class="token-line"><span class="token plain">          } else {</span></div><div class="token-line"><span class="token plain">            pool.returnResource(this);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">          super.close();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果不是，则直接关闭连接，其最终调用Connection类的disconnect方法来关闭TCP连接：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public void disconnect() {</span></div><div class="token-line"><span class="token plain">      if (isConnected()) {</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">          outputStream.flush();</span></div><div class="token-line"><span class="token plain">          socket.close();</span></div><div class="token-line"><span class="token plain">        } catch (IOException ex) {</span></div><div class="token-line"><span class="token plain">          broken = true;</span></div><div class="token-line"><span class="token plain">          throw new JedisConnectionException(ex);</span></div><div class="token-line"><span class="token plain">        } finally {</span></div><div class="token-line"><span class="token plain">          IOUtils.closeQuietly(socket);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，Jedis可以独立使用，也可以配合连接池使用，这个连接池就是JedisPool。我们再看看JedisPool的实现。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class JedisPool extends JedisPoolAbstract {</span></div><div class="token-line"><span class="token plain">    @Override</span></div><div class="token-line"><span class="token plain">      public Jedis getResource() {</span></div><div class="token-line"><span class="token plain">        Jedis jedis = super.getResource();</span></div><div class="token-line"><span class="token plain">        jedis.setDataSource(this);</span></div><div class="token-line"><span class="token plain">        return jedis;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      @Override</span></div><div class="token-line"><span class="token plain">      protected void returnResource(final Jedis resource) {</span></div><div class="token-line"><span class="token plain">        if (resource != null) {</span></div><div class="token-line"><span class="token plain">          try {</span></div><div class="token-line"><span class="token plain">            resource.resetState();</span></div><div class="token-line"><span class="token plain">            returnResourceObject(resource);</span></div><div class="token-line"><span class="token plain">          } catch (Exception e) {</span></div><div class="token-line"><span class="token plain">            returnBrokenResource(resource);</span></div><div class="token-line"><span class="token plain">            throw new JedisException(&quot;Resource is returned to the pool as broken&quot;, e);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class JedisPoolAbstract extends Pool&lt;Jedis&gt; {</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public abstract class Pool&lt;T&gt; implements Closeable {</span></div><div class="token-line"><span class="token plain">      protected GenericObjectPool&lt;T&gt; internalPool;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>JedisPool的getResource方法在拿到Jedis对象后，将自己设置为了连接池。连接池JedisPool，继承了JedisPoolAbstract，而后者继承了抽象类Pool，Pool内部维护了Apache Common的通用池GenericObjectPool。JedisPool的连接池就是基于GenericObjectPool的。</p><p>看到这里我们了解了，Jedis的API实现是我们说的三种类型中的第一种，也就是连接池和连接分离的API，JedisPool是线程安全的连接池，Jedis是非线程安全的单一连接。知道了原理之后，我们再使用Jedis就胸有成竹了。</p><h2 id="使用连接池务必确保复用"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/04#使用连接池务必确保复用"><span class="icon icon-link"></span></a>使用连接池务必确保复用</h2><p>在介绍<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/210337">线程池<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的时候我们强调过，<strong>池一定是用来复用的，否则其使用代价会比每次创建单一对象更大。对连接池来说更是如此，原因如下：</strong></p><ul><li>创建连接池的时候很可能一次性创建了多个连接，大多数连接池考虑到性能，会在初始化的时候维护一定数量的最小连接（毕竟初始化连接池的过程一般是一次性的），可以直接使用。如果每次使用连接池都按需创建连接池，那么很可能你只用到一个连接，但是创建了N个连接。</li><li>连接池一般会有一些管理模块，也就是连接池的结构示意图中的绿色部分。举个例子，大多数的连接池都有闲置超时的概念。连接池会检测连接的闲置时间，定期回收闲置的连接，把活跃连接数降到最低（闲置）连接的配置值，减轻服务端的压力。一般情况下，闲置连接由独立线程管理，启动了空闲检测的连接池相当于还会启动一个线程。此外，有些连接池还需要独立线程负责连接保活等功能。因此，启动一个连接池相当于启动了N个线程。</li></ul><p>除了使用代价，连接池不释放，还可能会引起线程泄露。接下来，我就以Apache HttpClient为例，和你说说连接池不复用的问题。</p><p>首先，创建一个CloseableHttpClient，设置使用PoolingHttpClientConnectionManager连接池并启用空闲连接驱逐策略，最大空闲时间为60秒，然后使用这个连接来请求一个会返回OK字符串的服务端接口：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;wrong1&quot;)</span></div><div class="token-line"><span class="token plain">    public String wrong1() {</span></div><div class="token-line"><span class="token plain">        CloseableHttpClient client = HttpClients.custom()</span></div><div class="token-line"><span class="token plain">                .setConnectionManager(new PoolingHttpClientConnectionManager())</span></div><div class="token-line"><span class="token plain">                .evictIdleConnections(60, TimeUnit.SECONDS).build();</span></div><div class="token-line"><span class="token plain">        try (CloseableHttpResponse response = client.execute(new HttpGet(&quot;http://127.0.0.1:45678/httpclientnotreuse/test&quot;))) {</span></div><div class="token-line"><span class="token plain">            return EntityUtils.toString(response.getEntity());</span></div><div class="token-line"><span class="token plain">        } catch (Exception ex) {</span></div><div class="token-line"><span class="token plain">            ex.printStackTrace();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return null;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>访问这个接口几次后查看应用线程情况，可以看到有大量叫作Connection evictor的线程，且这些线程不会销毁：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage331033a2389c20653e97b8157897d06c1510.96d3e021.png" alt=""/></p><p>对这个接口进行几秒的压测（压测使用wrk，1个并发1个连接）可以看到，已经建立了三千多个TCP连接到45678端口（其中有1个是压测客户端到Tomcat的连接，大部分都是HttpClient到Tomcat的连接）：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage54f254a71ee9a7bbbd5e121b12fe6289aff2.39e3c19e.png" alt=""/></p><p>好在有了空闲连接回收的策略，60秒之后连接处于CLOSE_WAIT状态，最终彻底关闭。</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage8e778ea5f53e6510d76cf447c23fb15daa77.30ea6f23.png" alt=""/></p><p>这2点证明，CloseableHttpClient属于第二种模式，即内部带有连接池的API，其背后是连接池，最佳实践一定是复用。</p><p>复用方式很简单，你可以把CloseableHttpClient声明为static，只创建一次，并且在JVM关闭之前通过addShutdownHook钩子关闭连接池，在使用的时候直接使用CloseableHttpClient即可，无需每次都创建。</p><p>首先，定义一个right接口来实现服务端接口调用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private static CloseableHttpClient httpClient = null;</span></div><div class="token-line"><span class="token plain">    static {</span></div><div class="token-line"><span class="token plain">        //当然，也可以把CloseableHttpClient定义为Bean，然后在@PreDestroy标记的方法内close这个HttpClient</span></div><div class="token-line"><span class="token plain">        httpClient = HttpClients.custom().setMaxConnPerRoute(1).setMaxConnTotal(1).evictIdleConnections(60, TimeUnit.SECONDS).build();</span></div><div class="token-line"><span class="token plain">        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {</span></div><div class="token-line"><span class="token plain">            try {</span></div><div class="token-line"><span class="token plain">                httpClient.close();</span></div><div class="token-line"><span class="token plain">            } catch (IOException ignored) {</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }));</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @GetMapping(&quot;right&quot;)</span></div><div class="token-line"><span class="token plain">    public String right() {</span></div><div class="token-line"><span class="token plain">        try (CloseableHttpResponse response = httpClient.execute(new HttpGet(&quot;http://127.0.0.1:45678/httpclientnotreuse/test&quot;))) {</span></div><div class="token-line"><span class="token plain">            return EntityUtils.toString(response.getEntity());</span></div><div class="token-line"><span class="token plain">        } catch (Exception ex) {</span></div><div class="token-line"><span class="token plain">            ex.printStackTrace();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return null;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后，重新定义一个wrong2接口，修复之前按需创建CloseableHttpClient的代码，每次用完之后确保连接池可以关闭：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;wrong2&quot;)</span></div><div class="token-line"><span class="token plain">    public String wrong2() {</span></div><div class="token-line"><span class="token plain">        try (CloseableHttpClient client = HttpClients.custom()</span></div><div class="token-line"><span class="token plain">                .setConnectionManager(new PoolingHttpClientConnectionManager())</span></div><div class="token-line"><span class="token plain">                .evictIdleConnections(60, TimeUnit.SECONDS).build();</span></div><div class="token-line"><span class="token plain">             CloseableHttpResponse response = client.execute(new HttpGet(&quot;http://127.0.0.1:45678/httpclientnotreuse/test&quot;))) {</span></div><div class="token-line"><span class="token plain">                return EntityUtils.toString(response.getEntity());</span></div><div class="token-line"><span class="token plain">            } catch (Exception ex) {</span></div><div class="token-line"><span class="token plain">            ex.printStackTrace();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return null;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>使用wrk对wrong2和right两个接口分别压测60秒，可以看到两种使用方式性能上的差异，每次创建连接池的QPS是337，而复用连接池的QPS是2022：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimageb72db79fb99cf8a5c3a17e60b0850544472d.0007362c.png" alt=""/></p><p>如此大的性能差异显然是因为TCP连接的复用。你可能注意到了，刚才定义连接池时，我将最大连接数设置为1。所以，复用连接池方式复用的始终应该是同一个连接，而新建连接池方式应该是每次都会创建新的TCP连接。</p><p>接下来，我们通过网络抓包工具Wireshark来证实这一点。</p><p>如果调用wrong2接口每次创建新的连接池来发起HTTP请求，从Wireshark可以看到，每次请求服务端45678的客户端端口都是新的。这里我发起了三次请求，程序通过HttpClient访问服务端45678的客户端端口号，分别是51677、51679和51681：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage7b357b8f651755cef0c05ecb08727d315e35.dce999e1.png" alt=""/></p><p>也就是说，每次都是新的TCP连接，放开HTTP这个过滤条件也可以看到完整的TCP握手、挥手的过程：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage480d4815c0edd21d5bf0cae8c0c3e578960d.34752938.png" alt=""/></p><p>而复用连接池方式的接口right的表现就完全不同了。可以看到，第二次HTTP请求#41的客户端端口61468和第一次连接#23的端口是一样的，Wireshark也提示了整个TCP会话中，当前#41请求是第二次请求，前一次是#23，后面一次是#75：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage2c2c2cbada9be98ce33321b29d38adb09f2c.a1192f29.png" alt=""/></p><p>只有TCP连接闲置超过60秒后才会断开，连接池会新建连接。你可以尝试通过Wireshark观察这一过程。</p><p>接下来，我们就继续聊聊连接池的配置问题。</p><h2 id="连接池的配置不是一成不变的"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/04#连接池的配置不是一成不变的"><span class="icon icon-link"></span></a>连接池的配置不是一成不变的</h2><p>为方便根据容量规划设置连接处的属性，连接池提供了许多参数，包括最小（闲置）连接、最大连接、闲置连接生存时间、连接生存时间等。其中，最重要的参数是最大连接数，它决定了连接池能使用的连接数量上限，达到上限后，新来的请求需要等待其他请求释放连接。</p><p>但，<strong>最大连接数不是设置得越大越好</strong>。如果设置得太大，不仅仅是客户端需要耗费过多的资源维护连接，更重要的是由于服务端对应的是多个客户端，每一个客户端都保持大量的连接，会给服务端带来更大的压力。这个压力又不仅仅是内存压力，可以想一下如果服务端的网络模型是一个TCP连接一个线程，那么几千个连接意味着几千个线程，如此多的线程会造成大量的线程切换开销。</p><p>当然，<strong>连接池最大连接数设置得太小，很可能会因为获取连接的等待时间太长，导致吞吐量低下，甚至超时无法获取连接</strong>。</p><p>接下来，我们就模拟下压力增大导致数据库连接池打满的情况，来实践下如何确认连接池的使用情况，以及有针对性地进行参数优化。</p><p>首先，定义一个用户注册方法，通过@Transactional注解为方法开启事务。其中包含了500毫秒的休眠，一个数据库事务对应一个TCP连接，所以500多毫秒的时间都会占用数据库连接：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Transactional</span></div><div class="token-line"><span class="token plain">    public User register(){</span></div><div class="token-line"><span class="token plain">        User user=new User();</span></div><div class="token-line"><span class="token plain">        user.setName(&quot;new-user-&quot;+System.currentTimeMillis());</span></div><div class="token-line"><span class="token plain">        userRepository.save(user);</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">            TimeUnit.MILLISECONDS.sleep(500);</span></div><div class="token-line"><span class="token plain">        } catch (InterruptedException e) {</span></div><div class="token-line"><span class="token plain">            e.printStackTrace();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return user;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>随后，修改配置文件启用register-mbeans，使Hikari连接池能通过JMX MBean注册连接池相关统计信息，方便观察连接池：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">spring.datasource.hikari.register-mbeans=true</span></div></pre></div><p>启动程序并通过JConsole连接进程后，可以看到默认情况下最大连接数为10：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage7b947b8e5aff5a3ef6ade1d8027c20c92f94.cec7fd43.png" alt=""/></p><p>使用wrk对应用进行压测，可以看到连接数一下子从0到了10，有20个线程在等待获取连接：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimageb2efb22169b8d8bbfabbb8b93ece11a1f9ef.3714621d.png" alt=""/></p><p>不久就出现了无法获取数据库连接的异常，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[15:37:56.156] [http-nio-45678-exec-15] [ERROR] [.a.c.c.C.[.[.[/].[dispatcherServlet]:175 ] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.dao.DataAccessResourceFailureException: unable to obtain isolated JDBC connection; nested exception is org.hibernate.exception.JDBCConnectionException: unable to obtain isolated JDBC connection] with root cause</span></div><div class="token-line"><span class="token plain">    java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30000ms.</span></div></pre></div><p>从异常信息中可以看到，数据库连接池是HikariPool，解决方式很简单，修改一下配置文件，调整数据库连接池最大连接参数到50即可。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">spring.datasource.hikari.maximum-pool-size=50</span></div></pre></div><p>然后，再观察一下这个参数是否适合当前压力，满足需求的同时也不占用过多资源。从监控来看这个调整是合理的，有一半的富余资源，再也没有线程需要等待连接了：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimaged231d24f23f05d49378a10a857cd8b9ef031.7d956ef0.png" alt=""/></p><p>在这个Demo里，我知道压测大概能对应使用25左右的并发连接，所以直接把连接池最大连接设置为了50。在真实情况下，只要数据库可以承受，你可以选择在遇到连接超限的时候先设置一个足够大的连接数，然后观察最终应用的并发，再按照实际并发数留出一半的余量来设置最终的最大连接。</p><p>其实，看到错误日志后再调整已经有点儿晚了。更合适的做法是，<strong>对类似数据库连接池的重要资源进行持续检测，并设置一半的使用量作为报警阈值，出现预警后及时扩容</strong>。</p><p>在这里我是为了演示，才通过JConsole查看参数配置后的效果，生产上需要把相关数据对接到指标监控体系中持续监测。</p><p><strong>这里要强调的是，修改配置参数务必验证是否生效，并且在监控系统中确认参数是否生效、是否合理。之所以要“强调”，是因为这里有坑</strong>。</p><p>我之前就遇到过这样一个事故。应用准备针对大促活动进行扩容，把数据库配置文件中Druid连接池最大连接数maxActive从50提高到了100，修改后并没有通过监控验证，结果大促当天应用因为连接池连接数不够爆了。</p><p>经排查发现，当时修改的连接数并没有生效。原因是，应用虽然一开始使用的是Druid连接池，但后来框架升级了，把连接池替换为了Hikari实现，原来的那些配置其实都是无效的，修改后的参数配置当然也不会生效。</p><p>所以说，对连接池进行调参，一定要眼见为实。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/04#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>今天，我以三种业务代码最常用的Redis连接池、HTTP连接池、数据库连接池为例，和你探讨了有关连接池实现方式、使用姿势和参数配置的三大问题。</p><p>客户端SDK实现连接池的方式，包括池和连接分离、内部带有连接池和非连接池三种。要正确使用连接池，就必须首先鉴别连接池的实现方式。比如，Jedis的API实现的是池和连接分离的方式，而Apache HttpClient是内置连接池的API。</p><p>对于使用姿势其实就是两点，一是确保连接池是复用的，二是尽可能在程序退出之前显式关闭连接池释放资源。连接池设计的初衷就是为了保持一定量的连接，这样连接可以随取随用。从连接池获取连接虽然很快，但连接池的初始化会比较慢，需要做一些管理模块的初始化以及初始最小闲置连接。一旦连接池不是复用的，那么其性能会比随时创建单一连接更差。</p><p>最后，连接池参数配置中，最重要的是最大连接数，许多高并发应用往往因为最大连接数不够导致性能问题。但，最大连接数不是设置得越大越好，够用就好。需要注意的是，针对数据库连接池、HTTP连接池、Redis连接池等重要连接池，务必建立完善的监控和报警机制，根据容量规划及时调整参数配置。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a target="_blank" rel="noopener noreferrer" href="https://github.com/JosephZhu1983/java-common-mistakes">这个链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>查看。</p><h2 id="思考与讨论"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/04#思考与讨论"><span class="icon icon-link"></span></a>思考与讨论</h2><ol><li>有了连接池之后，获取连接是从连接池获取，没有足够连接时连接池会创建连接。这时，获取连接操作往往有两个超时时间：一个是从连接池获取连接的最长等待时间，通常叫作请求连接超时connectRequestTimeout或连接等待超时connectWaitTimeout；一个是连接池新建TCP连接三次握手的连接超时，通常叫作连接超时connectTimeout。针对JedisPool、Apache HttpClient和Hikari数据库连接池，你知道如何设置这2个参数吗？</li><li>对于带有连接池的SDK的使用姿势，最主要的是鉴别其内部是否实现了连接池，如果实现了连接池要尽量复用Client。对于NoSQL中的MongoDB来说，使用MongoDB Java驱动时，MongoClient类应该是每次都创建还是复用呢？你能否在<a target="_blank" rel="noopener noreferrer" href="https://mongodb.github.io/mongo-java-driver/3.12/">官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中找到答案呢？</li></ol><p>关于连接池，你还遇到过什么坑吗？我是朱晔，欢迎在评论区与我留言分享，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/java业务开发常见错误100例/02.代码篇/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:06:36</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-java/umi.fde43fdb.js"></script>
  </body>
</html>
