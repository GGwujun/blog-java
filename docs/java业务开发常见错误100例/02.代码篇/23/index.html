<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-test/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-test";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>答疑篇：代码篇思考题集锦（三） - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/java业务开发常见错误100例/02.代码篇/23" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a aria-current="page" class="active" href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-test/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-test/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a aria-current="page" class="active" href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-test/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-test/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java业务开发常见错误100例/01.开篇词">01.开篇词</a><ul><li><a href="/blog-test/java业务开发常见错误100例/01.开篇词/01"><span>开篇词 | 业务代码真的会有这么多坑？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-test/java业务开发常见错误100例/02.代码篇">02.代码篇</a><ul><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/01"><span>01 | 使用了并发工具类库，线程安全就高枕无忧了吗？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/02"><span>02 | 代码加锁：不要让“锁”事成为烦心事</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/03"><span>03 | 线程池：业务代码最常用也最容易犯错的组件</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/04"><span>04 | 连接池：别让连接池帮了倒忙</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/05"><span>05 | HTTP调用：你考虑到超时、重试、并发了吗？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/06"><span>06 | 20%的业务代码的Spring声明式事务，可能都没处理正确</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/07"><span>答疑篇：代码篇思考题集锦（一）</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/08"><span>07 | 数据库索引：索引并不是万能药</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/09"><span>08 | 判等问题：程序里如何确定你就是你？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/10"><span>09 | 数值计算：注意精度、舍入和溢出问题</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/11"><span>10 | 集合类：坑满地的List列表操作</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/12"><span>11 | 空值处理：分不清楚的null和恼人的空指针</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/13"><span>12 | 异常处理：别让自己在出问题的时候变为瞎子</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/14"><span>答疑篇：代码篇思考题集锦（二）</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/15"><span>13 | 日志：日志记录真没你想象的那么简单</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/16"><span>14 | 文件IO：实现高效正确的文件读写并非易事</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/17"><span>15 | 序列化：一来一回你还是原来的你吗？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/18"><span>16 | 用好Java 8的日期时间类，少踩一些“老三样”的坑</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/19"><span>17 | 别以为“自动挡”就不可能出现OOM</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/20"><span>18 | 当反射、注解和泛型遇到OOP时，会有哪些坑？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/21"><span>19 | Spring框架：IoC和AOP是扩展的核心</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/22"><span>20 | Spring框架：框架帮我们做了很多工作也带来了复杂度</span></a></li><li><a aria-current="page" class="active" href="/blog-test/java业务开发常见错误100例/02.代码篇/23"><span>答疑篇：代码篇思考题集锦（三）</span></a></li></ul></li><li><a href="/blog-test/java业务开发常见错误100例/03.设计篇">03.设计篇</a><ul><li><a href="/blog-test/java业务开发常见错误100例/03.设计篇/01"><span>21 |  代码重复：搞定代码重复的三个绝招</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/03.设计篇/02"><span>22 | 接口设计：系统间对话的语言，一定要统一</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/03.设计篇/03"><span>23 | 缓存设计：缓存可以锦上添花也可以落井下石</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/03.设计篇/04"><span>24 | 业务代码写完，就意味着生产就绪了？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/03.设计篇/05"><span>25 | 异步处理好用，但非常容易用错</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/03.设计篇/06"><span>26 | 数据存储：NoSQL与RDBMS如何取长补短、相辅相成？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/03.设计篇/07"><span>答疑篇：设计篇思考题答案合集</span></a></li></ul></li><li><a href="/blog-test/java业务开发常见错误100例/04.安全篇">04.安全篇</a><ul><li><a href="/blog-test/java业务开发常见错误100例/04.安全篇/01"><span>27 | 数据源头：任何客户端的东西都不可信任</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/04.安全篇/02"><span>28 | 安全兜底：涉及钱时，必须考虑防刷、限量和防重</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/04.安全篇/03"><span>29 | 数据和代码：数据就是数据，代码就是代码</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/04.安全篇/04"><span>30 | 如何正确保存和传输敏感数据？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/04.安全篇/05"><span>答疑篇：安全篇思考题答案合集</span></a></li></ul></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐">05.加餐</a><ul><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/01"><span>31 | 加餐1：带你吃透课程中Java 8的那些重要知识点（一）</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/02"><span>32 | 加餐2：带你吃透课程中Java 8的那些重要知识点（二）</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/03"><span>33 | 加餐3：定位应用问题，排错套路很重要</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/04"><span>34 | 加餐4：分析定位Java问题，一定要用好这些工具（一）</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/05"><span>35 | 加餐5：分析定位Java问题，一定要用好这些工具（二）</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/06"><span>36 | 加餐6：这15年来，我是如何在工作中学习技术和英语的？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/07"><span>答疑篇：加餐篇思考题答案合集</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/08"><span>37 | 加餐7：程序员成长28计</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/09"><span>38 | 加餐8：Java程序从虚拟机迁移到Kubernetes的一些坑</span></a></li></ul></li><li><a href="/blog-test/java业务开发常见错误100例/06.结束语">06.结束语</a><ul><li><a href="/blog-test/java业务开发常见错误100例/06.结束语/01"><span>结束语 | 写代码时，如何才能尽量避免踩坑？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/06.结束语/02"><span>结课测试 | 关于Java业务开发的100个常见错误，你都明白其中缘由了吗？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/06.结束语/03"><span>结课问卷获奖用户名单</span></a></li></ul></li><li><a href="/blog-test/java业务开发常见错误100例/summary">java业务开发常见错误100例</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="13 | 日志：日志记录真没你想象的那么简单" data-depth="3"><a href="/blog-test/java业务开发常见错误100例/02.代码篇/23#13--日志日志记录真没你想象的那么简单"><span>13 | 日志：日志记录真没你想象的那么简单</span></a></li><li title="14 | 文件IO：实现高效正确的文件读写并非易事" data-depth="3"><a href="/blog-test/java业务开发常见错误100例/02.代码篇/23#14--文件io实现高效正确的文件读写并非易事"><span>14 | 文件IO：实现高效正确的文件读写并非易事</span></a></li><li title="15 | 序列化：一来一回你还是原来的你吗？" data-depth="3"><a href="/blog-test/java业务开发常见错误100例/02.代码篇/23#15--序列化一来一回你还是原来的你吗"><span>15 | 序列化：一来一回你还是原来的你吗？</span></a></li><li title="16 | 用好Java 8的日期时间类，少踩一些“老三样”的坑" data-depth="3"><a href="/blog-test/java业务开发常见错误100例/02.代码篇/23#16--用好java-8的日期时间类少踩一些老三样的坑"><span>16 | 用好Java 8的日期时间类，少踩一些“老三样”的坑</span></a></li><li title="17 | 别以为“自动挡”就不可能出现OOM" data-depth="3"><a href="/blog-test/java业务开发常见错误100例/02.代码篇/23#17--别以为自动挡就不可能出现oom"><span>17 | 别以为“自动挡”就不可能出现OOM</span></a></li><li title="18 | 当反射、注解和泛型遇到OOP时，会有哪些坑？" data-depth="3"><a href="/blog-test/java业务开发常见错误100例/02.代码篇/23#18--当反射注解和泛型遇到oop时会有哪些坑"><span>18 | 当反射、注解和泛型遇到OOP时，会有哪些坑？</span></a></li><li title="19 | Spring框架：IoC和AOP是扩展的核心" data-depth="3"><a href="/blog-test/java业务开发常见错误100例/02.代码篇/23#19--spring框架ioc和aop是扩展的核心"><span>19 | Spring框架：IoC和AOP是扩展的核心</span></a></li><li title="20 | Spring框架：框架帮我们做了很多工作也带来了复杂度" data-depth="3"><a href="/blog-test/java业务开发常见错误100例/02.代码篇/23#20--spring框架框架帮我们做了很多工作也带来了复杂度"><span>20 | Spring框架：框架帮我们做了很多工作也带来了复杂度</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="答疑篇代码篇思考题集锦三"><a aria-hidden="true" tabindex="-1" href="/blog-test/java业务开发常见错误100例/02.代码篇/23#答疑篇代码篇思考题集锦三"><span class="icon icon-link"></span></a>答疑篇：代码篇思考题集锦（三）</h1><p>你好，我是朱晔。</p><p>今天，我们继续一起分析这门课第13~20讲的课后思考题。这些题目涉及了日志、文件IO、序列化、Java 8日期时间类、OOM、Java高级特性（反射、注解和泛型）和Spring框架的16道问题。</p><p>接下来，我们就一一具体分析吧。</p><h3 id="13--日志日志记录真没你想象的那么简单"><a aria-hidden="true" tabindex="-1" href="/blog-test/java业务开发常见错误100例/02.代码篇/23#13--日志日志记录真没你想象的那么简单"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/220307">13 | 日志：日志记录真没你想象的那么简单<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>**问题1：**在讲“为什么我的日志会重复记录？”的案例时，我们把INFO级别的日志存放到_info.log中，把WARN和ERROR级别的日志存放到_error.log中。如果现在要把INFO和WARN级别的日志存放到_info.log中，把ERROR日志存放到_error.log中，应该如何配置Logback呢？</p><p>答：要实现这个配置有两种方式，分别是：直接使用EvaluatorFilter和自定义一个Filter。我们分别看一下。</p><p>第一种方式是，直接使用logback自带的EvaluatorFilter：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;filter class=&quot;ch.qos.logback.core.filter.EvaluatorFilter&quot;&gt;</span></div><div class="token-line"><span class="token plain">        &lt;evaluator class=&quot;ch.qos.logback.classic.boolex.GEventEvaluator&quot;&gt;</span></div><div class="token-line"><span class="token plain">            &lt;expression&gt;</span></div><div class="token-line"><span class="token plain">                e.level.toInt() == WARN.toInt() || e.level.toInt() == INFO.toInt()</span></div><div class="token-line"><span class="token plain">            &lt;/expression&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/evaluator&gt;</span></div><div class="token-line"><span class="token plain">        &lt;OnMismatch&gt;DENY&lt;/OnMismatch&gt;</span></div><div class="token-line"><span class="token plain">        &lt;OnMatch&gt;NEUTRAL&lt;/OnMatch&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/filter&gt;</span></div></pre></div><p>第二种方式是，自定义一个Filter，实现解析配置中的“|”字符分割的多个Level：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class MultipleLevelsFilter extends Filter&lt;ILoggingEvent&gt; {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Getter</span></div><div class="token-line"><span class="token plain">        @Setter</span></div><div class="token-line"><span class="token plain">        private String levels;</span></div><div class="token-line"><span class="token plain">        private List&lt;Integer&gt; levelList;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public FilterReply decide(ILoggingEvent event) {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            if (levelList == null &amp;&amp; !StringUtils.isEmpty(levels)) {</span></div><div class="token-line"><span class="token plain">                //把由|分割的多个Level转换为List&lt;Integer&gt;</span></div><div class="token-line"><span class="token plain">                levelList = Arrays.asList(levels.split(&quot;\\|&quot;)).stream()</span></div><div class="token-line"><span class="token plain">                        .map(item -&gt; Level.valueOf(item))</span></div><div class="token-line"><span class="token plain">                        .map(level -&gt; level.toInt())</span></div><div class="token-line"><span class="token plain">                        .collect(Collectors.toList());</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            //如果levelList包含当前日志的级别，则接收否则拒绝</span></div><div class="token-line"><span class="token plain">            if (levelList.contains(event.getLevel().toInt()))</span></div><div class="token-line"><span class="token plain">                return FilterReply.ACCEPT;</span></div><div class="token-line"><span class="token plain">            else</span></div><div class="token-line"><span class="token plain">                return FilterReply.DENY;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后，在配置文件中使用这个MultipleLevelsFilter就可以了（完整的配置代码参考<a target="_blank" rel="noopener noreferrer" href="https://github.com/JosephZhu1983/java-common-mistakes/blob/master/src/main/java/org/geekbang/time/commonmistakes/logging/duplicate/multiplelevelsfilter.xml">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;filter class=&quot;org.geekbang.time.commonmistakes.logging.duplicate.MultipleLevelsFilter&quot;&gt;</span></div><div class="token-line"><span class="token plain">        &lt;levels&gt;INFO|WARN&lt;/levels&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/filter&gt;</span></div></pre></div><p>**问题2：**生产级项目的文件日志肯定需要按时间和日期进行分割和归档处理，以避免单个文件太大，同时保留一定天数的历史日志，你知道如何配置吗？可以在<a target="_blank" rel="noopener noreferrer" href="http://logback.qos.ch/manual/appenders.html#RollingFileAppender">官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>找到答案。</p><p>答：参考配置如下，使用SizeAndTimeBasedRollingPolicy来实现按照文件大小和历史文件保留天数，进行文件分割和归档：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt;</span></div><div class="token-line"><span class="token plain">        &lt;!--日志文件保留天数--&gt;</span></div><div class="token-line"><span class="token plain">        &lt;MaxHistory&gt;30&lt;/MaxHistory&gt;</span></div><div class="token-line"><span class="token plain">        &lt;!--日志文件最大的大小--&gt;</span></div><div class="token-line"><span class="token plain">        &lt;MaxFileSize&gt;100MB&lt;/MaxFileSize&gt;</span></div><div class="token-line"><span class="token plain">        &lt;!--日志整体最大</span></div><div class="token-line"><span class="token plain">         可选的totalSizeCap属性控制所有归档文件的总大小。当超过总大小上限时，将异步删除最旧的存档。</span></div><div class="token-line"><span class="token plain">         totalSizeCap属性也需要设置maxHistory属性。此外，“最大历史”限制总是首先应用，“总大小上限”限制其次应用。</span></div><div class="token-line"><span class="token plain">         --&gt;</span></div><div class="token-line"><span class="token plain">        &lt;totalSizeCap&gt;10GB&lt;/totalSizeCap&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/rollingPolicy&gt;</span></div></pre></div><h3 id="14--文件io实现高效正确的文件读写并非易事"><a aria-hidden="true" tabindex="-1" href="/blog-test/java业务开发常见错误100例/02.代码篇/23#14--文件io实现高效正确的文件读写并非易事"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/223051">14 | 文件IO：实现高效正确的文件读写并非易事<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>**问题1：**Files.lines方法进行流式处理，需要使用try-with-resources进行资源释放。那么，使用Files类中其他返回Stream包装对象的方法进行流式处理，比如newDirectoryStream方法返回DirectoryStream，list、walk和find方法返回Stream，也同样有资源释放问题吗？</p><p>答：使用Files类中其他返回Stream包装对象的方法进行流式处理，也同样会有资源释放问题。</p><p>因为，这些接口都需要使用try-with-resources模式来释放。正如文中所说，如果不显式释放，那么可能因为底层资源没有及时关闭造成资源泄露。</p><p>**问题2：**Java的File类和Files类提供的文件复制、重命名、删除等操作，是原子性的吗？</p><p>答：Java的File和Files类的文件复制、重命名、删除等操作，都不是原子性的。原因是，文件类操作基本都是调用操作系统本身的API，一般来说这些文件API并不像数据库有事务机制（也很难办到），即使有也很可能有平台差异性。</p><p>比如，File.renameTo方法的文档中提到：</p><blockquote><p>Many aspects of the behavior of this method are inherently platform-dependent: The rename operation might not be able to move a file from one filesystem to another, it might not be atomic, and it might not succeed if a file with the destination abstract pathname already exists. The return value should always be checked to make sure that the rename operation was successful.</p></blockquote><p>又比如，Files.copy方法的文档中提到：</p><blockquote><p>Copying a file is not an atomic operation. If an IOException is thrown, then it is possible that the target file is incomplete or some of its file attributes have not been copied from the source file. When the REPLACE_EXISTING option is specified and the target file exists, then the target file is replaced. The check for the existence of the file and the creation of the new file may not be atomic with respect to other file system activities.</p></blockquote><h3 id="15--序列化一来一回你还是原来的你吗"><a aria-hidden="true" tabindex="-1" href="/blog-test/java业务开发常见错误100例/02.代码篇/23#15--序列化一来一回你还是原来的你吗"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/223111">15 | 序列化：一来一回你还是原来的你吗？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>**问题1：**在讨论Redis序列化方式的时候，我们自定义了RedisTemplate，让Key使用String序列化、让Value使用JSON序列化，从而使Redis获得的Value可以直接转换为需要的对象类型。那么，使用RedisTemplate&lt;String, Long&gt;能否存取Value是Long的数据呢？这其中有什么坑吗？</p><p>答：使用RedisTemplate&lt;String, Long&gt;，不一定能存取Value是Long的数据。在Integer区间内返回的是Integer，超过这个区间返回Long。测试代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;wrong2&quot;)</span></div><div class="token-line"><span class="token plain">    public void wrong2() {</span></div><div class="token-line"><span class="token plain">        String key = &quot;testCounter&quot;;</span></div><div class="token-line"><span class="token plain">        //测试一下设置在Integer范围内的值</span></div><div class="token-line"><span class="token plain">        countRedisTemplate.opsForValue().set(key, 1L);</span></div><div class="token-line"><span class="token plain">        log.info(&quot;{} {}&quot;, countRedisTemplate.opsForValue().get(key), countRedisTemplate.opsForValue().get(key) instanceof Long);</span></div><div class="token-line"><span class="token plain">        Long l1 = getLongFromRedis(key);</span></div><div class="token-line"><span class="token plain">        //测试一下设置超过Integer范围的值</span></div><div class="token-line"><span class="token plain">        countRedisTemplate.opsForValue().set(key, Integer.MAX_VALUE + 1L);</span></div><div class="token-line"><span class="token plain">        log.info(&quot;{} {}&quot;, countRedisTemplate.opsForValue().get(key), countRedisTemplate.opsForValue().get(key) instanceof Long);</span></div><div class="token-line"><span class="token plain">        //使用getLongFromRedis转换后的值必定是Long</span></div><div class="token-line"><span class="token plain">        Long l2 = getLongFromRedis(key);</span></div><div class="token-line"><span class="token plain">        log.info(&quot;{} {}&quot;, l1, l2);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    private Long getLongFromRedis(String key) {</span></div><div class="token-line"><span class="token plain">        Object o = countRedisTemplate.opsForValue().get(key);</span></div><div class="token-line"><span class="token plain">        if (o instanceof Integer) {</span></div><div class="token-line"><span class="token plain">            return ((Integer) o).longValue();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if (o instanceof Long) {</span></div><div class="token-line"><span class="token plain">            return (Long) o;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return null;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>会得到如下输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">1 false</span></div><div class="token-line"><span class="token plain">    2147483648 true</span></div><div class="token-line"><span class="token plain">    1 2147483648</span></div></pre></div><p>可以看到，值设置1的时候类型不是Long，设置2147483648的时候是Long。也就是使用RedisTemplate&lt;String, Long&gt;不一定就代表获取的到的Value是Long。</p><p>所以，这边我写了一个getLongFromRedis方法来做转换避免出错，判断当值是Integer的时候转换为Long。</p><p>**问题2：**你可以看一下Jackson2ObjectMapperBuilder类源码的实现（注意configure方法），分析一下其除了关闭FAIL_ON_UNKNOWN_PROPERTIES外，还做了什么吗？</p><p>答：除了关闭FAIL_ON_UNKNOWN_PROPERTIES外，Jackson2ObjectMapperBuilder类源码还主要做了以下两方面的事儿。</p><p>第一，设置Jackson的一些默认值，比如：</p><ul><li>MapperFeature.DEFAULT_VIEW_INCLUSION设置为禁用；</li><li>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES设置为禁用。</li></ul><p>第二，自动注册classpath中存在的一些jackson模块，比如：</p><ul><li>jackson-datatype-jdk8，支持JDK8的一些类型，比如Optional；</li><li>jackson-datatype-jsr310， 支持JDK8的日期时间一些类型。</li><li>jackson-datatype-joda，支持Joda-Time类型。</li><li>jackson-module-kotlin，支持Kotlin。</li></ul><h3 id="16--用好java-8的日期时间类少踩一些老三样的坑"><a aria-hidden="true" tabindex="-1" href="/blog-test/java业务开发常见错误100例/02.代码篇/23#16--用好java-8的日期时间类少踩一些老三样的坑"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/224240">16 | 用好Java 8的日期时间类，少踩一些“老三样”的坑<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>**问题1：**在这一讲中，我多次强调了Date是一个时间戳，是UTC时间、没有时区概念。那，为什么调用其toString方法，会输出类似CST之类的时区字样呢？</p><p>答：关于这个问题，参考toString中的相关源码，你可以看到会获取当前时区（取不到则显示GMT）进行格式化：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public String toString() {</span></div><div class="token-line"><span class="token plain">        BaseCalendar.Date date = normalize();</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">        TimeZone zi = date.getZone();</span></div><div class="token-line"><span class="token plain">        if (zi != null) {</span></div><div class="token-line"><span class="token plain">            sb.append(zi.getDisplayName(date.isDaylightTime(), TimeZone.SHORT, Locale.US)); // zzz</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">            sb.append(&quot;GMT&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        sb.append(&#x27; &#x27;).append(date.getYear());  // yyyy</span></div><div class="token-line"><span class="token plain">        return sb.toString();</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    private final BaseCalendar.Date normalize() {</span></div><div class="token-line"><span class="token plain">        if (cdate == null) {</span></div><div class="token-line"><span class="token plain">            BaseCalendar cal = getCalendarSystem(fastTime);</span></div><div class="token-line"><span class="token plain">            cdate = (BaseCalendar.Date) cal.getCalendarDate(fastTime,</span></div><div class="token-line"><span class="token plain">                                                            TimeZone.getDefaultRef());</span></div><div class="token-line"><span class="token plain">            return cdate;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        // Normalize cdate with the TimeZone in cdate first. This is</span></div><div class="token-line"><span class="token plain">        // required for the compatible behavior.</span></div><div class="token-line"><span class="token plain">        if (!cdate.isNormalized()) {</span></div><div class="token-line"><span class="token plain">            cdate = normalize(cdate);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        // If the default TimeZone has changed, then recalculate the</span></div><div class="token-line"><span class="token plain">        // fields with the new TimeZone.</span></div><div class="token-line"><span class="token plain">        TimeZone tz = TimeZone.getDefaultRef();</span></div><div class="token-line"><span class="token plain">        if (tz != cdate.getZone()) {</span></div><div class="token-line"><span class="token plain">            cdate.setZone(tz);</span></div><div class="token-line"><span class="token plain">            CalendarSystem cal = getCalendarSystem(cdate);</span></div><div class="token-line"><span class="token plain">            cal.getCalendarDate(fastTime, cdate);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return cdate;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其实说白了，这里显示的时区仅仅用于呈现，并不代表Date类内置了时区信息。</p><p>**问题2：**日期时间数据始终要保存到数据库中，MySQL中有两种数据类型datetime和timestamp可以用来保存日期时间。你能说说它们的区别吗，它们是否包含时区信息呢？</p><p>答：datetime和timestamp的区别，主要体现在占用空间、表示的时间范围和时区三个方面。</p><ul><li>占用空间：datetime占用8字节；timestamp占用4字节。</li><li>表示的时间范围：datetime表示的范围是从“1000-01-01 00:00:00.000000”到“9999-12-31 23:59:59.999999”；timestamp表示的范围是从“1970-01-01 00:00:01.000000”到“2038-01-19 03:14:07.999999”。</li><li>时区：timestamp保存的时候根据当前时区转换为UTC，查询的时候再根据当前时区从UTC转回来；而datetime就是一个死的字符串时间（仅仅对MySQL本身而言）表示。</li></ul><p>需要注意的是，我们说datetime不包含时区是固定的时间表示，仅仅是指MySQL本身。使用timestamp，需要考虑Java进程的时区和MySQL连接的时区。而使用datetime类型，则只需要考虑Java进程的时区（因为MySQL datetime没有时区信息了，JDBC时间戳转换成MySQL datetime，会根据MySQL的serverTimezone做一次转换）。</p><p>如果你的项目有国际化需求，我推荐使用时间戳，并且要确保你的应用服务器和数据库服务器设置了正确的匹配当地时区的时区配置。</p><p>其实，即便你的项目没有国际化需求，至少是应用服务器和数据库服务器设置一致的时区，也是需要的。</p><h3 id="17--别以为自动挡就不可能出现oom"><a aria-hidden="true" tabindex="-1" href="/blog-test/java业务开发常见错误100例/02.代码篇/23#17--别以为自动挡就不可能出现oom"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/224784">17 | 别以为“自动挡”就不可能出现OOM<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>**问题1：**Spring的ConcurrentReferenceHashMap，针对Key和Value支持软引用和弱引用两种方式。你觉得哪种方式更适合做缓存呢？</p><p>答：软引用和弱引用的区别在于：若一个对象是弱引用可达，无论当前内存是否充足它都会被回收，而软引用可达的对象在内存不充足时才会被回收。因此，软引用要比弱引用“强”一些。</p><p>那么，使用弱引用作为缓存就会让缓存的生命周期过短，所以软引用更适合作为缓存。</p><p>**问题2：**当我们需要动态执行一些表达式时，可以使用Groovy动态语言实现：new出一个GroovyShell类，然后调用evaluate方法动态执行脚本。这种方式的问题是，会重复产生大量的类，增加Metaspace区的GC负担，有可能会引起OOM。你知道如何避免这个问题吗？</p><p>答：调用evaluate方法动态执行脚本会产生大量的类，要避免可能因此导致的OOM问题，我们可以把脚本包装为一个函数，先调用parse函数来得到Script对象，然后缓存起来，以后直接使用invokeMethod方法调用这个函数即可：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private Object rightGroovy(String script, String method, Object... args) {</span></div><div class="token-line"><span class="token plain">        Script scriptObject;</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">        if (SCRIPT_CACHE.containsKey(script)) {</span></div><div class="token-line"><span class="token plain">            //如果脚本已经生成过Script则直接使用</span></div><div class="token-line"><span class="token plain">            scriptObject = SCRIPT_CACHE.get(script);</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">            //否则把脚本解析为Script</span></div><div class="token-line"><span class="token plain">            scriptObject = shell.parse(script);</span></div><div class="token-line"><span class="token plain">            SCRIPT_CACHE.put(script, scriptObject);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return scriptObject.invokeMethod(method, args);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我在源码中提供了一个<a target="_blank" rel="noopener noreferrer" href="https://github.com/JosephZhu1983/java-common-mistakes/blob/master/src/main/java/org/geekbang/time/commonmistakes/oom/groovyoom/GroovyOOMController.java">测试程序<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，你可以直接去看一下。</p><h3 id="18--当反射注解和泛型遇到oop时会有哪些坑"><a aria-hidden="true" tabindex="-1" href="/blog-test/java业务开发常见错误100例/02.代码篇/23#18--当反射注解和泛型遇到oop时会有哪些坑"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/225596">18 | 当反射、注解和泛型遇到OOP时，会有哪些坑？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>**问题1：**泛型类型擦除后会生成一个bridge方法，这个方法同时又是synthetic方法。除了泛型类型擦除，你知道还有什么情况编译器会生成synthetic方法吗？</p><p>答：Synthetic方法是编译器自动生成的方法（在源码中不出现）。除了文中提到的泛型类型擦除外，Synthetic方法还可能出现的一个比较常见的场景，是内部类和顶层类需要相互访问对方的private字段或方法的时候。</p><p>编译后的内部类和普通类没有区别，遵循private字段或方法对外部类不可见的原则，但语法上内部类和顶层类的私有字段需要可以相互访问。为了解决这个矛盾，编译器就只能生成桥接方法，也就是Synthetic方法，来把private成员转换为package级别的访问限制。</p><p>比如如下代码，InnerClassApplication类的test方法需要访问内部类MyInnerClass类的私有字段name，而内部类MyInnerClass类的test方法需要访问外部类InnerClassApplication类的私有字段gender。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class InnerClassApplication {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        private String gender = &quot;male&quot;;</span></div><div class="token-line"><span class="token plain">        public static void main(String[] args) throws Exception {</span></div><div class="token-line"><span class="token plain">            InnerClassApplication application = new InnerClassApplication();</span></div><div class="token-line"><span class="token plain">            application.test();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        private void test(){</span></div><div class="token-line"><span class="token plain">            MyInnerClass myInnerClass = new MyInnerClass();</span></div><div class="token-line"><span class="token plain">            System.out.println(myInnerClass.name);</span></div><div class="token-line"><span class="token plain">            myInnerClass.test();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        class MyInnerClass {</span></div><div class="token-line"><span class="token plain">            private String name = &quot;zhuye&quot;;</span></div><div class="token-line"><span class="token plain">            void test(){</span></div><div class="token-line"><span class="token plain">                System.out.println(gender);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>编译器会为InnerClassApplication和MyInnerClass都生成桥接方法。</p><p>如下图所示，InnerClassApplication的test方法，其实调用的是内部类的access$000静态方法：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage936693a0fd1feb705be9fd63c3b963943c66.bdc1c796.png" alt=""/></p><p>这个access$000方法是Synthetic方法：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage2af02aa967cfbd7832d0893605c4249363f0.227a3543.png" alt=""/></p><p>而Synthetic方法的实现转接调用了内部类的name字段：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage063d064809b7fba7dc34f5c955a1a7dbf33d.0ae94a3c.png" alt=""/></p><p>反过来，内部类的test方法也是通过外部类InnerClassApplication类的桥接方法access$100调用到其私有字段：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimageeb9eebefeeda2de626ca8cbdf5388763669e.fca3d1d6.png" alt=""/></p><p>**问题2：**关于注解继承问题，你觉得Spring的常用注解@Service、@Controller是否支持继承呢？</p><p>答：Spring的常用注解@Service、@Controller，不支持继承。这些注解只支持放到具体的（非接口非抽象）顶层类上（来让它们成为Bean），如果支持继承会非常不灵活而且容易出错。</p><h3 id="19--spring框架ioc和aop是扩展的核心"><a aria-hidden="true" tabindex="-1" href="/blog-test/java业务开发常见错误100例/02.代码篇/23#19--spring框架ioc和aop是扩展的核心"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/227917">19 | Spring框架：IoC和AOP是扩展的核心<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>**问题1：**除了通过@Autowired注入Bean外，还可以使用@Inject或@Resource来注入Bean。你知道这三种方式的区别是什么吗？</p><p>答：我们先说一下使用@Autowired、@Inject和@Resource这三种注解注入Bean的方式：</p><ul><li>@Autowired，是Spring的注解，优先按照类型注入。当无法确定具体注入类型的时候，可以通过@Qualifier注解指定Bean名称。</li><li>@Inject：是JSR330规范的实现，也是根据类型进行自动装配的，这一点和@Autowired类似。如果需要按名称进行装配，则需要配合使用@Named。@Autowired和@Inject的区别在于，前者可以使用required=false允许注入null，后者允许注入一个Provider实现延迟注入。</li><li>@Resource：JSR250规范的实现，如果不指定name优先根据名称进行匹配（然后才是类型），如果指定name则仅根据名称匹配。</li></ul><p>**问题2：**当Bean产生循环依赖时，比如BeanA的构造方法依赖BeanB作为成员需要注入，BeanB也依赖BeanA，你觉得会出现什么问题呢？又有哪些解决方式呢？</p><p>答：Bean产生循环依赖，主要包括两种情况：一种是注入属性或字段涉及循环依赖，另一种是构造方法注入涉及循环依赖。接下来，我分别和你讲一讲。</p><p>第一种，注入属性或字段涉及循环依赖，比如TestA和TestB相互依赖：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Component</span></div><div class="token-line"><span class="token plain">    public class TestA {</span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        @Getter</span></div><div class="token-line"><span class="token plain">        private TestB testB;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Component</span></div><div class="token-line"><span class="token plain">    public class TestB {</span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        @Getter</span></div><div class="token-line"><span class="token plain">        private TestA testA;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>针对这个问题，Spring内部通过三个Map的方式解决了这个问题，不会出错。基本原理是，因为循环依赖，所以实例的初始化无法一次到位，需要分步进行：</p><ol><li>创建A（仅仅实例化，不注入依赖）；</li><li>创建B（仅仅实例化，不注入依赖）；</li><li>为B注入A（此时B已健全）；</li><li>为A注入B（此时A也健全）。</li></ol><p>网上有很多相关的分析，我找了<a target="_blank" rel="noopener noreferrer" href="https://cloud.tencent.com/developer/article/1497692">一篇比较详细的<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，可供你参考。</p><p>第二种，构造方法注入涉及循环依赖。遇到这种情况的话，程序无法启动，比如TestC和TestD的相互依赖：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Component</span></div><div class="token-line"><span class="token plain">    public class TestC {</span></div><div class="token-line"><span class="token plain">        @Getter</span></div><div class="token-line"><span class="token plain">        private TestD testD;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        public TestC(TestD testD) {</span></div><div class="token-line"><span class="token plain">            this.testD = testD;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Component</span></div><div class="token-line"><span class="token plain">    public class TestD {</span></div><div class="token-line"><span class="token plain">        @Getter</span></div><div class="token-line"><span class="token plain">        private TestC testC;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        public TestD(TestC testC) {</span></div><div class="token-line"><span class="token plain">            this.testC = testC;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这种循环依赖的主要解决方式，有2种：</p><ul><li>改为属性或字段注入；</li><li>使用@Lazy延迟注入。比如如下代码：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Component</span></div><div class="token-line"><span class="token plain">    public class TestC {</span></div><div class="token-line"><span class="token plain">        @Getter</span></div><div class="token-line"><span class="token plain">        private TestD testD;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        public TestC(@Lazy TestD testD) {</span></div><div class="token-line"><span class="token plain">            this.testD = testD;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其实，这种@Lazy方式注入的就不是实际的类型了，而是代理类，获取的时候通过代理去拿值（实例化）。所以，它可以解决循环依赖无法实例化的问题。</p><h3 id="20--spring框架框架帮我们做了很多工作也带来了复杂度"><a aria-hidden="true" tabindex="-1" href="/blog-test/java业务开发常见错误100例/02.代码篇/23#20--spring框架框架帮我们做了很多工作也带来了复杂度"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/227918">20 | Spring框架：框架帮我们做了很多工作也带来了复杂度<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>**问题1：**除了Spring框架这两讲涉及的execution、within、@within、@annotation 四个指示器外，Spring AOP 还支持 this、target、args、@target、@args。你能说说后面五种指示器的作用吗？</p><p>答：关于这些指示器的作用，你可以参考<a target="_blank" rel="noopener noreferrer" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-pointcuts-designators">官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，文档里已经写的很清晰。</p><p>总结一下，按照使用场景，建议使用下面这些指示器：</p><ul><li>针对方法签名，使用execution；</li><li>针对类型匹配，使用within（匹配类型）、this（匹配代理类实例）、target（匹配代理背后的目标类实例）、args（匹配参数）；</li><li>针对注解匹配，使用@annotation（使用指定注解标注的方法）、@target（使用指定注解标注的类）、@args（使用指定注解标注的类作为某个方法的参数）。</li></ul><p>你可能会问，@within怎么没有呢？</p><p>其实，对于Spring默认的基于动态代理或CGLIB的AOP，因为切点只能是方法，使用@within和@target指示器并无区别；但需要注意如果切换到AspectJ，那么使用@within和@target这两个指示器的行为就会有所区别了，@within会切入更多的成员的访问（比如静态构造方法、字段访问），一般而言使用@target指示器即可。</p><p>**问题2：**Spring 的 Environment 中的 PropertySources 属性可以包含多个 PropertySource，越往前优先级越高。那，我们能否利用这个特点实现配置文件中属性值的自动赋值呢？比如，我们可以定义 %%MYSQL.URL%%、%%MYSQL.USERNAME%% 和 %%MYSQL.PASSWORD%%，分别代表数据库连接字符串、用户名和密码。在配置数据源时，我们只要设置其值为占位符，框架就可以自动根据当前应用程序名 application.name，统一把占位符替换为真实的数据库信息。这样，生产的数据库信息就不需要放在配置文件中了，会更安全。</p><p>答：我们利用PropertySource具有优先级的特点，实现配置文件中属性值的自动赋值。主要逻辑是，遍历现在的属性值，找出能匹配到占位符的属性，并把这些属性的值替换为实际的数据库信息，然后再把这些替换后的属性值构成新的PropertiesPropertySource，加入PropertySources的第一个。这样，我们这个PropertiesPropertySource中的值就可以生效了。</p><p>主要源码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">        Utils.loadPropertySource(CommonMistakesApplication.class, &quot;db.properties&quot;);</span></div><div class="token-line"><span class="token plain">        new SpringApplicationBuilder()</span></div><div class="token-line"><span class="token plain">                .sources(CommonMistakesApplication.class)</span></div><div class="token-line"><span class="token plain">                .initializers(context -&gt; initDbUrl(context.getEnvironment()))</span></div><div class="token-line"><span class="token plain">                .run(args);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    private static final String MYSQL_URL_PLACEHOLDER = &quot;%%MYSQL.URL%%&quot;;</span></div><div class="token-line"><span class="token plain">    private static final String MYSQL_USERNAME_PLACEHOLDER = &quot;%%MYSQL.USERNAME%%&quot;;</span></div><div class="token-line"><span class="token plain">    private static final String MYSQL_PASSWORD_PLACEHOLDER = &quot;%%MYSQL.PASSWORD%%&quot;;</span></div><div class="token-line"><span class="token plain">    private static void initDbUrl(ConfigurableEnvironment env) {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        String dataSourceUrl = env.getProperty(&quot;spring.datasource.url&quot;);</span></div><div class="token-line"><span class="token plain">        String username = env.getProperty(&quot;spring.datasource.username&quot;);</span></div><div class="token-line"><span class="token plain">        String password = env.getProperty(&quot;spring.datasource.password&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if (dataSourceUrl != null &amp;&amp; !dataSourceUrl.contains(MYSQL_URL_PLACEHOLDER))</span></div><div class="token-line"><span class="token plain">            throw new IllegalArgumentException(&quot;请使用占位符&quot; + MYSQL_URL_PLACEHOLDER + &quot;来替换数据库URL配置！&quot;);</span></div><div class="token-line"><span class="token plain">        if (username != null &amp;&amp; !username.contains(MYSQL_USERNAME_PLACEHOLDER))</span></div><div class="token-line"><span class="token plain">            throw new IllegalArgumentException(&quot;请使用占位符&quot; + MYSQL_USERNAME_PLACEHOLDER + &quot;来替换数据库账号配置！&quot;);</span></div><div class="token-line"><span class="token plain">        if (password != null &amp;&amp; !password.contains(MYSQL_PASSWORD_PLACEHOLDER))</span></div><div class="token-line"><span class="token plain">            throw new IllegalArgumentException(&quot;请使用占位符&quot; + MYSQL_PASSWORD_PLACEHOLDER + &quot;来替换数据库密码配置！&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //这里我把值写死了，实际应用中可以从外部服务来获取</span></div><div class="token-line"><span class="token plain">        Map&lt;String, String&gt; property = new HashMap&lt;&gt;();</span></div><div class="token-line"><span class="token plain">        property.put(MYSQL_URL_PLACEHOLDER, &quot;jdbc:mysql://localhost:6657/common_mistakes?characterEncoding=UTF-8&amp;useSSL=false&quot;);</span></div><div class="token-line"><span class="token plain">        property.put(MYSQL_USERNAME_PLACEHOLDER, &quot;root&quot;);</span></div><div class="token-line"><span class="token plain">        property.put(MYSQL_PASSWORD_PLACEHOLDER, &quot;kIo9u7Oi0eg&quot;);</span></div><div class="token-line"><span class="token plain">        //保存修改后的配置属性</span></div><div class="token-line"><span class="token plain">        Properties modifiedProps = new Properties();</span></div><div class="token-line"><span class="token plain">        //遍历现在的属性值，找出能匹配到占位符的属性，并把这些属性的值替换为实际的数据库信息</span></div><div class="token-line"><span class="token plain">        StreamSupport.stream(env.getPropertySources().spliterator(), false)</span></div><div class="token-line"><span class="token plain">                .filter(ps -&gt; ps instanceof EnumerablePropertySource)</span></div><div class="token-line"><span class="token plain">                .map(ps -&gt; ((EnumerablePropertySource) ps).getPropertyNames())</span></div><div class="token-line"><span class="token plain">                .flatMap(Arrays::stream)</span></div><div class="token-line"><span class="token plain">                .forEach(propKey -&gt; {</span></div><div class="token-line"><span class="token plain">                    String propValue = env.getProperty(propKey);</span></div><div class="token-line"><span class="token plain">                    property.entrySet().forEach(item -&gt; {</span></div><div class="token-line"><span class="token plain">                        //如果原先配置的属性值包含我们定义的占位符</span></div><div class="token-line"><span class="token plain">                        if (propValue.contains(item.getKey())) {</span></div><div class="token-line"><span class="token plain">                            //那么就把实际的配置信息加入modifiedProps</span></div><div class="token-line"><span class="token plain">                            modifiedProps.put(propKey, propValue.replaceAll(item.getKey(), item.getValue()));</span></div><div class="token-line"><span class="token plain">                        }</span></div><div class="token-line"><span class="token plain">                    });</span></div><div class="token-line"><span class="token plain">                });</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if (!modifiedProps.isEmpty()) {</span></div><div class="token-line"><span class="token plain">            log.info(&quot;modifiedProps: {}&quot;, modifiedProps);</span></div><div class="token-line"><span class="token plain">            env.getPropertySources().addFirst(new PropertiesPropertySource(&quot;mysql&quot;, modifiedProps));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我在GitHub上第20讲对应的源码中更新了我的实现，你可以点击<a target="_blank" rel="noopener noreferrer" href="https://github.com/JosephZhu1983/java-common-mistakes/blob/master/src/main/java/org/geekbang/time/commonmistakes/springpart2/custompropertysource/CommonMistakesApplication.java">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>查看。有一些同学会问，这么做的意义到底在于什么，为何不直接使用类似Apollo这样的配置框架呢？</p><p>其实，我们的目的就是不希望让开发人员手动配置数据库信息，希望程序启动的时候自动替换占位符实现自动配置（从CMDB直接拿着应用程序ID来换取对应的数据库信息。你可能会问了，一个应用程序ID对应多个数据库怎么办？其实，一般对于微服务系统来说，一个应用就应该对应一个数据库）。这样一来，除了程序其他人都不会接触到生产的数据库信息，会更安全。</p><p>以上，就是咱们这门课的第13~20讲的思考题答案了。</p><p>关于这些题目，以及背后涉及的知识点，如果你还有哪里感觉不清楚的，欢迎在评论区与我留言，也欢迎你把今天的内容分享给你的朋友或同事，一起交流。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/java业务开发常见错误100例/02.代码篇/23.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 09:43:57</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-test/umi.3ded5539.js"></script>
  </body>
</html>
