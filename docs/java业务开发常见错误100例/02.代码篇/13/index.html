<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-java/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-java";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>12 | 异常处理：别让自己在出问题的时候变为瞎子 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/java业务开发常见错误100例/02.代码篇/13" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java业务开发常见错误100例/01.开篇词">01.开篇词</a><ul><li><a href="/blog-java/java业务开发常见错误100例/01.开篇词/01"><span>开篇词 | 业务代码真的会有这么多坑？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例/02.代码篇">02.代码篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/01"><span>01 | 使用了并发工具类库，线程安全就高枕无忧了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/02"><span>02 | 代码加锁：不要让“锁”事成为烦心事</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/03"><span>03 | 线程池：业务代码最常用也最容易犯错的组件</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/04"><span>04 | 连接池：别让连接池帮了倒忙</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/05"><span>05 | HTTP调用：你考虑到超时、重试、并发了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/06"><span>06 | 20%的业务代码的Spring声明式事务，可能都没处理正确</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/07"><span>答疑篇：代码篇思考题集锦（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/08"><span>07 | 数据库索引：索引并不是万能药</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/09"><span>08 | 判等问题：程序里如何确定你就是你？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/10"><span>09 | 数值计算：注意精度、舍入和溢出问题</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/11"><span>10 | 集合类：坑满地的List列表操作</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/12"><span>11 | 空值处理：分不清楚的null和恼人的空指针</span></a></li><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例/02.代码篇/13"><span>12 | 异常处理：别让自己在出问题的时候变为瞎子</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/14"><span>答疑篇：代码篇思考题集锦（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/15"><span>13 | 日志：日志记录真没你想象的那么简单</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/16"><span>14 | 文件IO：实现高效正确的文件读写并非易事</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/17"><span>15 | 序列化：一来一回你还是原来的你吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/18"><span>16 | 用好Java 8的日期时间类，少踩一些“老三样”的坑</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/19"><span>17 | 别以为“自动挡”就不可能出现OOM</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/20"><span>18 | 当反射、注解和泛型遇到OOP时，会有哪些坑？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/21"><span>19 | Spring框架：IoC和AOP是扩展的核心</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/22"><span>20 | Spring框架：框架帮我们做了很多工作也带来了复杂度</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/23"><span>答疑篇：代码篇思考题集锦（三）</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇">03.设计篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/01"><span>21 |  代码重复：搞定代码重复的三个绝招</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/02"><span>22 | 接口设计：系统间对话的语言，一定要统一</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/03"><span>23 | 缓存设计：缓存可以锦上添花也可以落井下石</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/04"><span>24 | 业务代码写完，就意味着生产就绪了？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/05"><span>25 | 异步处理好用，但非常容易用错</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/06"><span>26 | 数据存储：NoSQL与RDBMS如何取长补短、相辅相成？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/07"><span>答疑篇：设计篇思考题答案合集</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇">04.安全篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/01"><span>27 | 数据源头：任何客户端的东西都不可信任</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/02"><span>28 | 安全兜底：涉及钱时，必须考虑防刷、限量和防重</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/03"><span>29 | 数据和代码：数据就是数据，代码就是代码</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/04"><span>30 | 如何正确保存和传输敏感数据？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/05"><span>答疑篇：安全篇思考题答案合集</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐">05.加餐</a><ul><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/01"><span>31 | 加餐1：带你吃透课程中Java 8的那些重要知识点（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/02"><span>32 | 加餐2：带你吃透课程中Java 8的那些重要知识点（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/03"><span>33 | 加餐3：定位应用问题，排错套路很重要</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/04"><span>34 | 加餐4：分析定位Java问题，一定要用好这些工具（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/05"><span>35 | 加餐5：分析定位Java问题，一定要用好这些工具（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/06"><span>36 | 加餐6：这15年来，我是如何在工作中学习技术和英语的？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/07"><span>答疑篇：加餐篇思考题答案合集</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/08"><span>37 | 加餐7：程序员成长28计</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/09"><span>38 | 加餐8：Java程序从虚拟机迁移到Kubernetes的一些坑</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语">06.结束语</a><ul><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/01"><span>结束语 | 写代码时，如何才能尽量避免踩坑？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/02"><span>结课测试 | 关于Java业务开发的100个常见错误，你都明白其中缘由了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/03"><span>结课问卷获奖用户名单</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/summary">java业务开发常见错误100例</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="捕获和处理异常容易犯的错" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/13#捕获和处理异常容易犯的错"><span>捕获和处理异常容易犯的错</span></a></li><li title="小心finally中的异常" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/13#小心finally中的异常"><span>小心finally中的异常</span></a></li><li title="千万别把异常定义为静态变量" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/13#千万别把异常定义为静态变量"><span>千万别把异常定义为静态变量</span></a></li><li title="提交线程池的任务出了异常会怎么样？" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/13#提交线程池的任务出了异常会怎么样"><span>提交线程池的任务出了异常会怎么样？</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/13#重点回顾"><span>重点回顾</span></a></li><li title="思考与讨论" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/13#思考与讨论"><span>思考与讨论</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="12--异常处理别让自己在出问题的时候变为瞎子"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/13#12--异常处理别让自己在出问题的时候变为瞎子"><span class="icon icon-link"></span></a>12 | 异常处理：别让自己在出问题的时候变为瞎子</h1><p>你好，我是朱晔。今天，我来和你聊聊异常处理容易踩的坑。</p><p>应用程序避免不了出异常，捕获和处理异常是考验编程功力的一个精细活。一些业务项目中，我曾看到开发同学在开发业务逻辑时不考虑任何异常处理，项目接近完成时再采用“流水线”的方式进行异常处理，也就是统一为所有方法打上try…catch…捕获所有异常记录日志，有些技巧的同学可能会使用AOP来进行类似的“统一异常处理”。</p><p>其实，这种处理异常的方式非常不可取。那么今天，我就和你分享下不可取的原因、与异常处理相关的坑和最佳实践。</p><h2 id="捕获和处理异常容易犯的错"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/13#捕获和处理异常容易犯的错"><span class="icon icon-link"></span></a>捕获和处理异常容易犯的错</h2><p>“统一异常处理”方式正是我要说的第一个错：<strong>不在业务代码层面考虑异常处理，仅在框架层面粗犷捕获和处理异常</strong>。</p><p>为了理解错在何处，我们先来看看大多数业务应用都采用的三层架构：</p><ul><li>Controller层负责信息收集、参数校验、转换服务层处理的数据适配前端，轻业务逻辑；</li><li>Service层负责核心业务逻辑，包括各种外部服务调用、访问数据库、缓存处理、消息处理等；</li><li>Repository层负责数据访问实现，一般没有业务逻辑。</li></ul><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage2f612f2cfbd86efd3bc140400bcaf2985361.1bde9151.png" alt=""/></p><p>每层架构的工作性质不同，且从业务性质上异常可能分为业务异常和系统异常两大类，这就决定了很难进行统一的异常处理。我们从底向上看一下三层架构：</p><ul><li>Repository层出现异常或许可以忽略，或许可以降级，或许需要转化为一个友好的异常。如果一律捕获异常仅记录日志，很可能业务逻辑已经出错，而用户和程序本身完全感知不到。</li><li>Service层往往涉及数据库事务，出现异常同样不适合捕获，否则事务无法自动回滚。此外Service层涉及业务逻辑，有些业务逻辑执行中遇到业务异常，可能需要在异常后转入分支业务流程。如果业务异常都被框架捕获了，业务功能就会不正常。</li><li>如果下层异常上升到Controller层还是无法处理的话，Controller层往往会给予用户友好提示，或是根据每一个API的异常表返回指定的异常类型，同样无法对所有异常一视同仁。</li></ul><p>因此，我不建议在框架层面进行异常的自动、统一处理，尤其不要随意捕获异常。但，框架可以做兜底工作。如果异常上升到最上层逻辑还是无法处理的话，可以以统一的方式进行异常转换，比如通过@RestControllerAdvice + @ExceptionHandler，来捕获这些“未处理”异常：</p><ul><li>对于自定义的业务异常，以Warn级别的日志记录异常以及当前URL、执行方法等信息后，提取异常中的错误码和消息等信息，转换为合适的API包装体返回给API调用方；</li><li>对于无法处理的系统异常，以Error级别的日志记录异常和上下文信息（比如URL、参数、用户ID）后，转换为普适的“服务器忙，请稍后再试”异常信息，同样以API包装体返回给调用方。</li></ul><p>比如，下面这段代码的做法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RestControllerAdvice</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class RestControllerExceptionHandler {</span></div><div class="token-line"><span class="token plain">        private static int GENERIC_SERVER_ERROR_CODE = 2000;</span></div><div class="token-line"><span class="token plain">        private static String GENERIC_SERVER_ERROR_MESSAGE = &quot;服务器忙，请稍后再试&quot;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @ExceptionHandler</span></div><div class="token-line"><span class="token plain">        public APIResponse handle(HttpServletRequest req, HandlerMethod method, Exception ex) {</span></div><div class="token-line"><span class="token plain">            if (ex instanceof BusinessException) {</span></div><div class="token-line"><span class="token plain">                BusinessException exception = (BusinessException) ex;</span></div><div class="token-line"><span class="token plain">                log.warn(String.format(&quot;访问 %s -&gt; %s 出现业务异常！&quot;, req.getRequestURI(), method.toString()), ex);</span></div><div class="token-line"><span class="token plain">                return new APIResponse(false, null, exception.getCode(), exception.getMessage());</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">                log.error(String.format(&quot;访问 %s -&gt; %s 出现系统异常！&quot;, req.getRequestURI(), method.toString()), ex);</span></div><div class="token-line"><span class="token plain">                return new APIResponse(false, null, GENERIC_SERVER_ERROR_CODE, GENERIC_SERVER_ERROR_MESSAGE);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>出现运行时系统异常后，异常处理程序会直接把异常转换为JSON返回给调用方：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimagec284c215e78f1b23583393649fa89efe9f84.a92cc5b0.png" alt=""/></p><p>要做得更好，你可以把相关出入参、用户信息在脱敏后记录到日志中，方便出现问题时根据上下文进一步排查。</p><p>第二个错，<strong>捕获了异常后直接生吞</strong>。在任何时候，我们捕获了异常都不应该生吞，也就是直接丢弃异常不记录、不抛出。这样的处理方式还不如不捕获异常，因为被生吞掉的异常一旦导致Bug，就很难在程序中找到蛛丝马迹，使得Bug排查工作难上加难。</p><p>通常情况下，生吞异常的原因，可能是不希望自己的方法抛出受检异常，只是为了把异常“处理掉”而捕获并生吞异常，也可能是想当然地认为异常并不重要或不可能产生。但不管是什么原因，不管是你认为多么不重要的异常，都不应该生吞，哪怕是一个日志也好。</p><p>第三个错，<strong>丢弃异常的原始信息</strong>。我们来看两个不太合适的异常处理方式，虽然没有完全生吞异常，但也丢失了宝贵的异常信息。</p><p>比如有这么一个会抛出受检异常的方法readFile：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private void readFile() throws IOException {</span></div><div class="token-line"><span class="token plain">    	Files.readAllLines(Paths.get(&quot;a_file&quot;));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>像这样调用readFile方法，捕获异常后，完全不记录原始异常，直接抛出一个转换后异常，导致出了问题不知道IOException具体是哪里引起的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;wrong1&quot;)</span></div><div class="token-line"><span class="token plain">    public void wrong1(){</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">            readFile();</span></div><div class="token-line"><span class="token plain">        } catch (IOException e) {</span></div><div class="token-line"><span class="token plain">            //原始异常信息丢失  </span></div><div class="token-line"><span class="token plain">            throw new RuntimeException(&quot;系统忙请稍后再试&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>或者是这样，只记录了异常消息，却丢失了异常的类型、栈等重要信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">catch (IOException e) {</span></div><div class="token-line"><span class="token plain">        //只保留了异常消息，栈没有记录</span></div><div class="token-line"><span class="token plain">        log.error(&quot;文件读取错误, {}&quot;, e.getMessage());</span></div><div class="token-line"><span class="token plain">        throw new RuntimeException(&quot;系统忙请稍后再试&quot;);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>留下的日志是这样的，看完一脸茫然，只知道文件读取错误的文件名，至于为什么读取错误、是不存在还是没权限，完全不知道。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[12:57:19.746] [http-nio-45678-exec-1] [ERROR] [.g.t.c.e.d.HandleExceptionController:35  ] - 文件读取错误, a_file</span></div></pre></div><p>这两种处理方式都不太合理，可以改为如下方式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">catch (IOException e) {</span></div><div class="token-line"><span class="token plain">        log.error(&quot;文件读取错误&quot;, e);</span></div><div class="token-line"><span class="token plain">        throw new RuntimeException(&quot;系统忙请稍后再试&quot;);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>或者，把原始异常作为转换后新异常的cause，原始异常信息同样不会丢：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">catch (IOException e) {</span></div><div class="token-line"><span class="token plain">        throw new RuntimeException(&quot;系统忙请稍后再试&quot;, e);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其实，JDK内部也会犯类似的错。之前我遇到一个使用JDK10的应用偶发启动失败的案例，日志中可以看到出现类似的错误信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Caused by: java.lang.SecurityException: Couldn&#x27;t parse jurisdiction policy files in: unlimited</span></div><div class="token-line"><span class="token plain">    	at java.base/javax.crypto.JceSecurity.setupJurisdictionPolicies(JceSecurity.java:355)</span></div><div class="token-line"><span class="token plain">    	at java.base/javax.crypto.JceSecurity.access$000(JceSecurity.java:73)</span></div><div class="token-line"><span class="token plain">    	at java.base/javax.crypto.JceSecurity$1.run(JceSecurity.java:109)</span></div><div class="token-line"><span class="token plain">    	at java.base/javax.crypto.JceSecurity$1.run(JceSecurity.java:106)</span></div><div class="token-line"><span class="token plain">    	at java.base/java.security.AccessController.doPrivileged(Native Method)</span></div><div class="token-line"><span class="token plain">    	at java.base/javax.crypto.JceSecurity.&lt;clinit&gt;(JceSecurity.java:105)</span></div><div class="token-line"><span class="token plain">    	... 20 more</span></div></pre></div><p>查看JDK JceSecurity类setupJurisdictionPolicies方法源码，发现异常e没有记录，也没有作为新抛出异常的cause，当时读取文件具体出现什么异常（权限问题又或是IO问题）可能永远都无法知道了，对问题定位造成了很大困扰：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimageb865b8b581f6130211a19ed66490dbcd0465.7642b873.png" alt=""/></p><p>第四个错，<strong>抛出异常时不指定任何消息</strong>。我见过一些代码中的偷懒做法，直接抛出没有message的异常：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">throw new RuntimeException();</span></div></pre></div><p>这么写的同学可能觉得永远不会走到这个逻辑，永远不会出现这样的异常。但，这样的异常却出现了，被ExceptionHandler拦截到后输出了下面的日志信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[13:25:18.031] [http-nio-45678-exec-3] [ERROR] [c.e.d.RestControllerExceptionHandler:24  ] - 访问 /handleexception/wrong3 -&gt; org.geekbang.time.commonmistakes.exception.demo1.HandleExceptionController#wrong3(String) 出现系统异常！</span></div><div class="token-line"><span class="token plain">    java.lang.RuntimeException: null</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>这里的null非常容易引起误解。按照空指针问题排查半天才发现，其实是异常的message为空。</p><p>总之，如果你捕获了异常打算处理的话，<strong>除了通过日志正确记录异常原始信息外，通常还有三种处理模式</strong>：</p><ul><li>转换，即转换新的异常抛出。对于新抛出的异常，最好具有特定的分类和明确的异常消息，而不是随便抛一个无关或没有任何信息的异常，并最好通过cause关联老异常。</li><li>重试，即重试之前的操作。比如远程调用服务端过载超时的情况，盲目重试会让问题更严重，需要考虑当前情况是否适合重试。</li><li>恢复，即尝试进行降级处理，或使用默认值来替代原始数据。</li></ul><p>以上，就是通过catch捕获处理异常的一些最佳实践。</p><h2 id="小心finally中的异常"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/13#小心finally中的异常"><span class="icon icon-link"></span></a>小心finally中的异常</h2><p>有些时候，我们希望不管是否遇到异常，逻辑完成后都要释放资源，这时可以使用finally代码块而跳过使用catch代码块。</p><p>但要千万小心finally代码块中的异常，因为资源释放处理等收尾操作同样也可能出现异常。比如下面这段代码，我们在finally中抛出一个异常：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;wrong&quot;)</span></div><div class="token-line"><span class="token plain">    public void wrong() {</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">            log.info(&quot;try&quot;);</span></div><div class="token-line"><span class="token plain">            //异常丢失</span></div><div class="token-line"><span class="token plain">            throw new RuntimeException(&quot;try&quot;);</span></div><div class="token-line"><span class="token plain">        } finally {</span></div><div class="token-line"><span class="token plain">            log.info(&quot;finally&quot;);</span></div><div class="token-line"><span class="token plain">            throw new RuntimeException(&quot;finally&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>最后在日志中只能看到finally中的异常，<strong>虽然try中的逻辑出现了异常，但却被finally中的异常覆盖了</strong>。这是非常危险的，特别是finally中出现的异常是偶发的，就会在部分时候覆盖try中的异常，让问题更不明显：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[13:34:42.247] [http-nio-45678-exec-1] [ERROR] [.a.c.c.C.[.[.[/].[dispatcherServlet]:175 ] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.RuntimeException: finally] with root cause</span></div><div class="token-line"><span class="token plain">    java.lang.RuntimeException: finally</span></div></pre></div><p>至于异常为什么被覆盖，原因也很简单，因为一个方法无法出现两个异常。修复方式是，finally代码块自己负责异常捕获和处理：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;right&quot;)</span></div><div class="token-line"><span class="token plain">    public void right() {</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">            log.info(&quot;try&quot;);</span></div><div class="token-line"><span class="token plain">            throw new RuntimeException(&quot;try&quot;);</span></div><div class="token-line"><span class="token plain">        } finally {</span></div><div class="token-line"><span class="token plain">            log.info(&quot;finally&quot;);</span></div><div class="token-line"><span class="token plain">            try {</span></div><div class="token-line"><span class="token plain">                throw new RuntimeException(&quot;finally&quot;);</span></div><div class="token-line"><span class="token plain">            } catch (Exception ex) {</span></div><div class="token-line"><span class="token plain">                log.error(&quot;finally&quot;, ex);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>或者可以把try中的异常作为主异常抛出，使用addSuppressed方法把finally中的异常附加到主异常上：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;right2&quot;)</span></div><div class="token-line"><span class="token plain">    public void right2() throws Exception {</span></div><div class="token-line"><span class="token plain">        Exception e = null;</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">            log.info(&quot;try&quot;);</span></div><div class="token-line"><span class="token plain">            throw new RuntimeException(&quot;try&quot;);</span></div><div class="token-line"><span class="token plain">        } catch (Exception ex) {</span></div><div class="token-line"><span class="token plain">            e = ex;</span></div><div class="token-line"><span class="token plain">        } finally {</span></div><div class="token-line"><span class="token plain">            log.info(&quot;finally&quot;);</span></div><div class="token-line"><span class="token plain">            try {</span></div><div class="token-line"><span class="token plain">                throw new RuntimeException(&quot;finally&quot;);</span></div><div class="token-line"><span class="token plain">            } catch (Exception ex) {</span></div><div class="token-line"><span class="token plain">                if (e!= null) {</span></div><div class="token-line"><span class="token plain">                    e.addSuppressed(ex);</span></div><div class="token-line"><span class="token plain">                } else {</span></div><div class="token-line"><span class="token plain">                    e = ex;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        throw e;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>运行方法可以得到如下异常信息，其中同时包含了主异常和被屏蔽的异常：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">java.lang.RuntimeException: try</span></div><div class="token-line"><span class="token plain">    	at org.geekbang.time.commonmistakes.exception.finallyissue.FinallyIssueController.right2(FinallyIssueController.java:69)</span></div><div class="token-line"><span class="token plain">    	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span></div><div class="token-line"><span class="token plain">    	...</span></div><div class="token-line"><span class="token plain">    	Suppressed: java.lang.RuntimeException: finally</span></div><div class="token-line"><span class="token plain">    		at org.geekbang.time.commonmistakes.exception.finallyissue.FinallyIssueController.right2(FinallyIssueController.java:75)</span></div><div class="token-line"><span class="token plain">    		... 54 common frames omitted</span></div></pre></div><p>其实这正是try-with-resources语句的做法，对于实现了AutoCloseable接口的资源，建议使用try-with-resources来释放资源，否则也可能会产生刚才提到的，释放资源时出现的异常覆盖主异常的问题。比如如下我们定义一个测试资源，其read和close方法都会抛出异常：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class TestResource implements AutoCloseable {</span></div><div class="token-line"><span class="token plain">        public void read() throws Exception{</span></div><div class="token-line"><span class="token plain">            throw new Exception(&quot;read error&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void close() throws Exception {</span></div><div class="token-line"><span class="token plain">            throw new Exception(&quot;close error&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>使用传统的try-finally语句，在try中调用read方法，在finally中调用close方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;useresourcewrong&quot;)</span></div><div class="token-line"><span class="token plain">    public void useresourcewrong() throws Exception {</span></div><div class="token-line"><span class="token plain">        TestResource testResource = new TestResource();</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">            testResource.read();</span></div><div class="token-line"><span class="token plain">        } finally {</span></div><div class="token-line"><span class="token plain">            testResource.close();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，同样出现了finally中的异常覆盖了try中异常的问题：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">java.lang.Exception: close error</span></div><div class="token-line"><span class="token plain">    	at org.geekbang.time.commonmistakes.exception.finallyissue.TestResource.close(TestResource.java:10)</span></div><div class="token-line"><span class="token plain">    	at org.geekbang.time.commonmistakes.exception.finallyissue.FinallyIssueController.useresourcewrong(FinallyIssueController.java:27)</span></div></pre></div><p>而改为try-with-resources模式之后：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;useresourceright&quot;)</span></div><div class="token-line"><span class="token plain">    public void useresourceright() throws Exception {</span></div><div class="token-line"><span class="token plain">        try (TestResource testResource = new TestResource()){</span></div><div class="token-line"><span class="token plain">            testResource.read();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>try和finally中的异常信息都可以得到保留：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">java.lang.Exception: read error</span></div><div class="token-line"><span class="token plain">    	at org.geekbang.time.commonmistakes.exception.finallyissue.TestResource.read(TestResource.java:6)</span></div><div class="token-line"><span class="token plain">    	...</span></div><div class="token-line"><span class="token plain">    	Suppressed: java.lang.Exception: close error</span></div><div class="token-line"><span class="token plain">    		at org.geekbang.time.commonmistakes.exception.finallyissue.TestResource.close(TestResource.java:10)</span></div><div class="token-line"><span class="token plain">    		at org.geekbang.time.commonmistakes.exception.finallyissue.FinallyIssueController.useresourceright(FinallyIssueController.java:35)</span></div><div class="token-line"><span class="token plain">    		... 54 common frames omitted</span></div></pre></div><h2 id="千万别把异常定义为静态变量"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/13#千万别把异常定义为静态变量"><span class="icon icon-link"></span></a>千万别把异常定义为静态变量</h2><p>既然我们通常会自定义一个业务异常类型，来包含更多的异常信息，比如异常错误码、友好的错误提示等，那就需要在业务逻辑各处，手动抛出各种业务异常来返回指定的错误码描述（比如对于下单操作，用户不存在返回2001，商品缺货返回2002等）。</p><p>对于这些异常的错误代码和消息，我们期望能够统一管理，而不是散落在程序各处定义。这个想法很好，但稍有不慎就可能会出现把异常定义为静态变量的坑。</p><p>我在救火排查某项目生产问题时，遇到了一件非常诡异的事情：我发现异常堆信息显示的方法调用路径，在当前入参的情况下根本不可能产生，项目的业务逻辑又很复杂，就始终没往异常信息是错的这方面想，总觉得是因为某个分支流程导致业务没有按照期望的流程进行。</p><p><strong>经过艰难的排查，最终定位到原因是把异常定义为了静态变量，导致异常栈信息错乱</strong>，类似于定义一个Exceptions类来汇总所有的异常，把异常存放在静态字段中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class Exceptions {</span></div><div class="token-line"><span class="token plain">        public static BusinessException ORDEREXISTS = new BusinessException(&quot;订单已经存在&quot;, 3001);</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>把异常定义为静态变量会导致异常信息固化，这就和异常的栈一定是需要根据当前调用来动态获取相矛盾。</p><p>我们写段代码来模拟下这个问题：定义两个方法createOrderWrong和cancelOrderWrong方法，它们内部都会通过Exceptions类来获得一个订单不存在的异常；先后调用两个方法，然后抛出。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;wrong&quot;)</span></div><div class="token-line"><span class="token plain">    public void wrong() {</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">            createOrderWrong();</span></div><div class="token-line"><span class="token plain">        } catch (Exception ex) {</span></div><div class="token-line"><span class="token plain">            log.error(&quot;createOrder got error&quot;, ex);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">            cancelOrderWrong();</span></div><div class="token-line"><span class="token plain">        } catch (Exception ex) {</span></div><div class="token-line"><span class="token plain">            log.error(&quot;cancelOrder got error&quot;, ex);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    private void createOrderWrong() {</span></div><div class="token-line"><span class="token plain">        //这里有问题</span></div><div class="token-line"><span class="token plain">        throw Exceptions.ORDEREXISTS;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    private void cancelOrderWrong() {</span></div><div class="token-line"><span class="token plain">        //这里有问题</span></div><div class="token-line"><span class="token plain">        throw Exceptions.ORDEREXISTS;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>运行程序后看到如下日志，cancelOrder got error的提示对应了createOrderWrong方法。显然，cancelOrderWrong方法在出错后抛出的异常，其实是createOrderWrong方法出错的异常：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[14:05:25.782] [http-nio-45678-exec-1] [ERROR] [.c.e.d.PredefinedExceptionController:25  ] - cancelOrder got error</span></div><div class="token-line"><span class="token plain">    org.geekbang.time.commonmistakes.exception.demo2.BusinessException: 订单已经存在</span></div><div class="token-line"><span class="token plain">    	at org.geekbang.time.commonmistakes.exception.demo2.Exceptions.&lt;clinit&gt;(Exceptions.java:5)</span></div><div class="token-line"><span class="token plain">    	at org.geekbang.time.commonmistakes.exception.demo2.PredefinedExceptionController.createOrderWrong(PredefinedExceptionController.java:50)</span></div><div class="token-line"><span class="token plain">    	at org.geekbang.time.commonmistakes.exception.demo2.PredefinedExceptionController.wrong(PredefinedExceptionController.java:18)</span></div></pre></div><p>修复方式很简单，改一下Exceptions类的实现，通过不同的方法把每一种异常都new出来抛出即可：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class Exceptions {</span></div><div class="token-line"><span class="token plain">        public static BusinessException orderExists(){</span></div><div class="token-line"><span class="token plain">            return new BusinessException(&quot;订单已经存在&quot;, 3001);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="提交线程池的任务出了异常会怎么样"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/13#提交线程池的任务出了异常会怎么样"><span class="icon icon-link"></span></a>提交线程池的任务出了异常会怎么样？</h2><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/210337">第3讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>介绍线程池时我提到，线程池常用作异步处理或并行处理。那么，把任务提交到线程池处理，任务本身出现异常时会怎样呢？</p><p>我们来看一个例子：提交10个任务到线程池异步处理，第5个任务抛出一个RuntimeException，每个任务完成后都会输出一行日志：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;execute&quot;)</span></div><div class="token-line"><span class="token plain">    public void execute() throws InterruptedException {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        String prefix = &quot;test&quot;;</span></div><div class="token-line"><span class="token plain">        ExecutorService threadPool = Executors.newFixedThreadPool(1, new ThreadFactoryBuilder().setNameFormat(prefix+&quot;%d&quot;).get());</span></div><div class="token-line"><span class="token plain">        //提交10个任务到线程池处理，第5个任务会抛出运行时异常</span></div><div class="token-line"><span class="token plain">        IntStream.rangeClosed(1, 10).forEach(i -&gt; threadPool.execute(() -&gt; {</span></div><div class="token-line"><span class="token plain">            if (i == 5) throw new RuntimeException(&quot;error&quot;);</span></div><div class="token-line"><span class="token plain">            log.info(&quot;I&#x27;m done : {}&quot;, i);</span></div><div class="token-line"><span class="token plain">        }));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        threadPool.shutdown();</span></div><div class="token-line"><span class="token plain">        threadPool.awaitTermination(1, TimeUnit.HOURS);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>观察日志可以发现两点：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">    [14:33:55.990] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:26  ] - I&#x27;m done : 4</span></div><div class="token-line"><span class="token plain">    Exception in thread &quot;test0&quot; java.lang.RuntimeException: error</span></div><div class="token-line"><span class="token plain">    	at org.geekbang.time.commonmistakes.exception.demo3.ThreadPoolAndExceptionController.lambda$null$0(ThreadPoolAndExceptionController.java:25)</span></div><div class="token-line"><span class="token plain">    	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span></div><div class="token-line"><span class="token plain">    	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span></div><div class="token-line"><span class="token plain">    	at java.lang.Thread.run(Thread.java:748)</span></div><div class="token-line"><span class="token plain">    [14:33:55.990] [test1] [INFO ] [e.d.ThreadPoolAndExceptionController:26  ] - I&#x27;m done : 6</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><ul><li>任务1到4所在的线程是test0，任务6开始运行在线程test1。由于我的线程池通过线程工厂为线程使用统一的前缀test加上计数器进行命名，因此<strong>从线程名的改变可以知道因为异常的抛出老线程退出了，线程池只能重新创建一个线程</strong>。如果每个异步任务都以异常结束，那么线程池可能完全起不到线程重用的作用。</li><li>因为没有手动捕获异常进行处理，ThreadGroup帮我们进行了未捕获异常的默认处理，向标准错误输出打印了出现异常的线程名称和异常信息。<strong>显然，这种没有以统一的错误日志格式记录错误信息打印出来的形式，对生产级代码是不合适的</strong>，ThreadGroup的相关源码如下所示：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public void uncaughtException(Thread t, Throwable e) {</span></div><div class="token-line"><span class="token plain">            if (parent != null) {</span></div><div class="token-line"><span class="token plain">                parent.uncaughtException(t, e);</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">                Thread.UncaughtExceptionHandler ueh =</span></div><div class="token-line"><span class="token plain">                    Thread.getDefaultUncaughtExceptionHandler();</span></div><div class="token-line"><span class="token plain">                if (ueh != null) {</span></div><div class="token-line"><span class="token plain">                    ueh.uncaughtException(t, e);</span></div><div class="token-line"><span class="token plain">                } else if (!(e instanceof ThreadDeath)) {</span></div><div class="token-line"><span class="token plain">                    System.err.print(&quot;Exception in thread \&quot;&quot;</span></div><div class="token-line"><span class="token plain">                                     + t.getName() + &quot;\&quot; &quot;);</span></div><div class="token-line"><span class="token plain">                    e.printStackTrace(System.err);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div></pre></div><p>修复方式有2步：</p><ol><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">以execute方法提交到线程池的异步任务，最好在任务内部做好异常处理；</span></div></pre></div></li><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">设置自定义的异常处理程序作为保底，比如在声明线程池时自定义线程池的未捕获异常处理程序：</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">new ThreadFactoryBuilder()</span></div><div class="token-line"><span class="token plain">    	.setNameFormat(prefix+&quot;%d&quot;)</span></div><div class="token-line"><span class="token plain">    	.setUncaughtExceptionHandler((thread, throwable)-&gt; log.error(&quot;ThreadPool {} got exception&quot;, thread, throwable))</span></div><div class="token-line"><span class="token plain">    	.get()</span></div></pre></div><p>或者设置全局的默认未捕获异常处理程序：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static {</span></div><div class="token-line"><span class="token plain">        Thread.setDefaultUncaughtExceptionHandler((thread, throwable)-&gt; log.error(&quot;Thread {} got exception&quot;, thread, throwable));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>通过线程池ExecutorService的execute方法提交任务到线程池处理，如果出现异常会导致线程退出，控制台输出中可以看到异常信息。那么，把execute方法改为submit，线程还会退出吗，异常还能被处理程序捕获到吗？</p><p><strong>修改代码后重新执行程序可以看到如下日志，说明线程没退出，异常也没记录被生吞了：</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[15:44:33.769] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&#x27;m done : 1</span></div><div class="token-line"><span class="token plain">    [15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&#x27;m done : 2</span></div><div class="token-line"><span class="token plain">    [15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&#x27;m done : 3</span></div><div class="token-line"><span class="token plain">    [15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&#x27;m done : 4</span></div><div class="token-line"><span class="token plain">    [15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&#x27;m done : 6</span></div><div class="token-line"><span class="token plain">    [15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&#x27;m done : 7</span></div><div class="token-line"><span class="token plain">    [15:44:33.770] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&#x27;m done : 8</span></div><div class="token-line"><span class="token plain">    [15:44:33.771] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&#x27;m done : 9</span></div><div class="token-line"><span class="token plain">    [15:44:33.771] [test0] [INFO ] [e.d.ThreadPoolAndExceptionController:47  ] - I&#x27;m done : 10</span></div></pre></div><p>为什么会这样呢？</p><p>查看FutureTask源码可以发现，在执行任务出现异常之后，异常存到了一个outcome字段中，只有在调用get方法获取FutureTask结果的时候，才会以ExecutionException的形式重新抛出异常：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public void run() {</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">            Callable&lt;V&gt; c = callable;</span></div><div class="token-line"><span class="token plain">            if (c != null &amp;&amp; state == NEW) {</span></div><div class="token-line"><span class="token plain">                V result;</span></div><div class="token-line"><span class="token plain">                boolean ran;</span></div><div class="token-line"><span class="token plain">                try {</span></div><div class="token-line"><span class="token plain">                    result = c.call();</span></div><div class="token-line"><span class="token plain">                    ran = true;</span></div><div class="token-line"><span class="token plain">                } catch (Throwable ex) {</span></div><div class="token-line"><span class="token plain">                    result = null;</span></div><div class="token-line"><span class="token plain">                    ran = false;</span></div><div class="token-line"><span class="token plain">                    setException(ex);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    protected void setException(Throwable t) {</span></div><div class="token-line"><span class="token plain">        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {</span></div><div class="token-line"><span class="token plain">            outcome = t;</span></div><div class="token-line"><span class="token plain">            UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state</span></div><div class="token-line"><span class="token plain">            finishCompletion();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public V get() throws InterruptedException, ExecutionException {</span></div><div class="token-line"><span class="token plain">        int s = state;</span></div><div class="token-line"><span class="token plain">        if (s &lt;= COMPLETING)</span></div><div class="token-line"><span class="token plain">            s = awaitDone(false, 0L);</span></div><div class="token-line"><span class="token plain">        return report(s);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    private V report(int s) throws ExecutionException {</span></div><div class="token-line"><span class="token plain">        Object x = outcome;</span></div><div class="token-line"><span class="token plain">        if (s == NORMAL)</span></div><div class="token-line"><span class="token plain">            return (V)x;</span></div><div class="token-line"><span class="token plain">        if (s &gt;= CANCELLED)</span></div><div class="token-line"><span class="token plain">            throw new CancellationException();</span></div><div class="token-line"><span class="token plain">        throw new ExecutionException((Throwable)x);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>修改后的代码如下所示，我们把submit返回的Future放到了List中，随后遍历List来捕获所有任务的异常。这么做确实合乎情理。既然是以submit方式来提交任务，那么我们应该关心任务的执行结果，否则应该以execute来提交任务：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">List&lt;Future&gt; tasks = IntStream.rangeClosed(1, 10).mapToObj(i -&gt; threadPool.submit(() -&gt; {</span></div><div class="token-line"><span class="token plain">        if (i == 5) throw new RuntimeException(&quot;error&quot;);</span></div><div class="token-line"><span class="token plain">        log.info(&quot;I&#x27;m done : {}&quot;, i);</span></div><div class="token-line"><span class="token plain">    })).collect(Collectors.toList());</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    tasks.forEach(task-&gt; {</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">            task.get();</span></div><div class="token-line"><span class="token plain">        } catch (Exception e) {</span></div><div class="token-line"><span class="token plain">            log.error(&quot;Got exception&quot;, e);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    });</span></div></pre></div><p>执行这段程序可以看到如下的日志输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[15:44:13.543] [http-nio-45678-exec-1] [ERROR] [e.d.ThreadPoolAndExceptionController:69  ] - Got exception</span></div><div class="token-line"><span class="token plain">    java.util.concurrent.ExecutionException: java.lang.RuntimeException: error</span></div></pre></div><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/13#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>在今天的文章中，我介绍了处理异常容易犯的几个错和最佳实践。</p><p>第一，注意捕获和处理异常的最佳实践。首先，不应该用AOP对所有方法进行统一异常处理，异常要么不捕获不处理，要么根据不同的业务逻辑、不同的异常类型进行精细化、针对性处理；其次，处理异常应该杜绝生吞，并确保异常栈信息得到保留；最后，如果需要重新抛出异常的话，请使用具有意义的异常类型和异常消息。</p><p>第二，务必小心finally代码块中资源回收逻辑，确保finally代码块不出现异常，内部把异常处理完毕，避免finally中的异常覆盖try中的异常；或者考虑使用addSuppressed方法把finally中的异常附加到try中的异常上，确保主异常信息不丢失。此外，使用实现了AutoCloseable接口的资源，务必使用try-with-resources模式来使用资源，确保资源可以正确释放，也同时确保异常可以正确处理。</p><p>第三，虽然在统一的地方定义收口所有的业务异常是一个不错的实践，但务必确保异常是每次new出来的，而不能使用一个预先定义的static字段存放异常，否则可能会引起栈信息的错乱。</p><p>第四，确保正确处理了线程池中任务的异常，如果任务通过execute提交，那么出现异常会导致线程退出，大量的异常会导致线程重复创建引起性能问题，我们应该尽可能确保任务不出异常，同时设置默认的未捕获异常处理程序来兜底；如果任务通过submit提交意味着我们关心任务的执行结果，应该通过拿到的Future调用其get方法来获得任务运行结果和可能出现的异常，否则异常可能就被生吞了。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a target="_blank" rel="noopener noreferrer" href="https://github.com/JosephZhu1983/java-common-mistakes">这个链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>查看。</p><h2 id="思考与讨论"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/13#思考与讨论"><span class="icon icon-link"></span></a>思考与讨论</h2><ol><li>关于在finally代码块中抛出异常的坑，如果在finally代码块中返回值，你觉得程序会以try或catch中返回值为准，还是以finally中的返回值为准呢？</li><li>对于手动抛出的异常，不建议直接使用Exception或RuntimeException，通常建议复用JDK中的一些标准异常，比如<a target="_blank" rel="noopener noreferrer" href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalStateException.html">IllegalStateException<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html">UnsupportedOperationException<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，你能说说它们的适用场景，并列出更多常用异常吗？</li></ol><p>不知道针对异常处理，你还遇到过什么坑，还有什么最佳实践的心得吗？我是朱晔，欢迎在评论区与我留言分享，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/java业务开发常见错误100例/02.代码篇/13.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:06:36</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-java/umi.fde43fdb.js"></script>
  </body>
</html>
