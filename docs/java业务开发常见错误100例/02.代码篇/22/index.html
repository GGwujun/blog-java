<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-java/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-java";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>
      20 | Spring框架：框架帮我们做了很多工作也带来了复杂度 - 大师兄
    </title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/java业务开发常见错误100例/02.代码篇/22" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java业务开发常见错误100例/01.开篇词">01.开篇词</a><ul><li><a href="/blog-java/java业务开发常见错误100例/01.开篇词/01"><span>开篇词 | 业务代码真的会有这么多坑？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例/02.代码篇">02.代码篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/01"><span>01 | 使用了并发工具类库，线程安全就高枕无忧了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/02"><span>02 | 代码加锁：不要让“锁”事成为烦心事</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/03"><span>03 | 线程池：业务代码最常用也最容易犯错的组件</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/04"><span>04 | 连接池：别让连接池帮了倒忙</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/05"><span>05 | HTTP调用：你考虑到超时、重试、并发了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/06"><span>06 | 20%的业务代码的Spring声明式事务，可能都没处理正确</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/07"><span>答疑篇：代码篇思考题集锦（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/08"><span>07 | 数据库索引：索引并不是万能药</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/09"><span>08 | 判等问题：程序里如何确定你就是你？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/10"><span>09 | 数值计算：注意精度、舍入和溢出问题</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/11"><span>10 | 集合类：坑满地的List列表操作</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/12"><span>11 | 空值处理：分不清楚的null和恼人的空指针</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/13"><span>12 | 异常处理：别让自己在出问题的时候变为瞎子</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/14"><span>答疑篇：代码篇思考题集锦（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/15"><span>13 | 日志：日志记录真没你想象的那么简单</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/16"><span>14 | 文件IO：实现高效正确的文件读写并非易事</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/17"><span>15 | 序列化：一来一回你还是原来的你吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/18"><span>16 | 用好Java 8的日期时间类，少踩一些“老三样”的坑</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/19"><span>17 | 别以为“自动挡”就不可能出现OOM</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/20"><span>18 | 当反射、注解和泛型遇到OOP时，会有哪些坑？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/21"><span>19 | Spring框架：IoC和AOP是扩展的核心</span></a></li><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例/02.代码篇/22"><span>20 | Spring框架：框架帮我们做了很多工作也带来了复杂度</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/23"><span>答疑篇：代码篇思考题集锦（三）</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇">03.设计篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/01"><span>21 |  代码重复：搞定代码重复的三个绝招</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/02"><span>22 | 接口设计：系统间对话的语言，一定要统一</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/03"><span>23 | 缓存设计：缓存可以锦上添花也可以落井下石</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/04"><span>24 | 业务代码写完，就意味着生产就绪了？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/05"><span>25 | 异步处理好用，但非常容易用错</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/06"><span>26 | 数据存储：NoSQL与RDBMS如何取长补短、相辅相成？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/07"><span>答疑篇：设计篇思考题答案合集</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇">04.安全篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/01"><span>27 | 数据源头：任何客户端的东西都不可信任</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/02"><span>28 | 安全兜底：涉及钱时，必须考虑防刷、限量和防重</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/03"><span>29 | 数据和代码：数据就是数据，代码就是代码</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/04"><span>30 | 如何正确保存和传输敏感数据？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/05"><span>答疑篇：安全篇思考题答案合集</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐">05.加餐</a><ul><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/01"><span>31 | 加餐1：带你吃透课程中Java 8的那些重要知识点（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/02"><span>32 | 加餐2：带你吃透课程中Java 8的那些重要知识点（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/03"><span>33 | 加餐3：定位应用问题，排错套路很重要</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/04"><span>34 | 加餐4：分析定位Java问题，一定要用好这些工具（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/05"><span>35 | 加餐5：分析定位Java问题，一定要用好这些工具（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/06"><span>36 | 加餐6：这15年来，我是如何在工作中学习技术和英语的？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/07"><span>答疑篇：加餐篇思考题答案合集</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/08"><span>37 | 加餐7：程序员成长28计</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/09"><span>38 | 加餐8：Java程序从虚拟机迁移到Kubernetes的一些坑</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语">06.结束语</a><ul><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/01"><span>结束语 | 写代码时，如何才能尽量避免踩坑？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/02"><span>结课测试 | 关于Java业务开发的100个常见错误，你都明白其中缘由了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/03"><span>结课问卷获奖用户名单</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/summary">java业务开发常见错误100例</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="Feign AOP切不到的诡异案例" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/22#feign-aop切不到的诡异案例"><span>Feign AOP切不到的诡异案例</span></a></li><li title="Spring程序配置的优先级问题" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/22#spring程序配置的优先级问题"><span>Spring程序配置的优先级问题</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/22#重点回顾"><span>重点回顾</span></a></li><li title="思考与讨论" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/02.代码篇/22#思考与讨论"><span>思考与讨论</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="20--spring框架框架帮我们做了很多工作也带来了复杂度"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/22#20--spring框架框架帮我们做了很多工作也带来了复杂度"><span class="icon icon-link"></span></a>20 | Spring框架：框架帮我们做了很多工作也带来了复杂度</h1><p>你好，我是朱晔。今天，我们聊聊Spring框架给业务代码带来的复杂度，以及与之相关的坑。</p><p>在上一讲，通过AOP实现统一的监控组件的案例，我们看到了IoC和AOP配合使用的威力：当对象由Spring容器管理成为Bean之后，我们不但可以通过容器管理配置Bean的属性，还可以方便地对感兴趣的方法做AOP。</p><p>不过，前提是对象必须是Bean。你可能会觉得这个结论很明显，也很容易理解啊。但就和上一讲提到的Bean默认是单例一样，理解起来简单，实践的时候却非常容易踩坑。其中原因，一方面是，理解Spring的体系结构和使用方式有一定曲线；另一方面是，Spring多年发展堆积起来的内部结构非常复杂，这也是更重要的原因。</p><p>在我看来，Spring框架内部的复杂度主要表现为三点：</p><ul><li>第一，Spring框架借助IoC和AOP的功能，实现了修改、拦截Bean的定义和实例的灵活性，因此真正执行的代码流程并不是串行的。</li><li>第二，Spring Boot根据当前依赖情况实现了自动配置，虽然省去了手动配置的麻烦，但也因此多了一些黑盒、提升了复杂度。</li><li>第三，Spring Cloud模块多版本也多，Spring Boot 1.x和2.x的区别也很大。如果要对Spring Cloud或Spring Boot进行二次开发的话，考虑兼容性的成本会很高。</li></ul><p>今天，我们就通过配置AOP切入Spring Cloud Feign组件失败、Spring Boot程序的文件配置被覆盖这两个案例，感受一下Spring的复杂度。我希望这一讲的内容，能帮助你面对Spring这个复杂框架出现的问题时，可以非常自信地找到解决方案。</p><h2 id="feign-aop切不到的诡异案例"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/22#feign-aop切不到的诡异案例"><span class="icon icon-link"></span></a>Feign AOP切不到的诡异案例</h2><p>我曾遇到过这么一个案例：使用Spring Cloud做微服务调用，为方便统一处理Feign，想到了用AOP实现，即使用within指示器匹配feign.Client接口的实现进行AOP切入。</p><p>代码如下，通过@Before注解在执行方法前打印日志，并在代码中定义了一个标记了@FeignClient注解的Client类，让其成为一个Feign接口：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//测试Feign</span></div><div class="token-line"><span class="token plain">    @FeignClient(name = &quot;client&quot;)</span></div><div class="token-line"><span class="token plain">    public interface Client {</span></div><div class="token-line"><span class="token plain">        @GetMapping(&quot;/feignaop/server&quot;)</span></div><div class="token-line"><span class="token plain">        String api();</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    //AOP切入feign.Client的实现</span></div><div class="token-line"><span class="token plain">    @Aspect</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    @Component</span></div><div class="token-line"><span class="token plain">    public class WrongAspect {</span></div><div class="token-line"><span class="token plain">        @Before(&quot;within(feign.Client+)&quot;)</span></div><div class="token-line"><span class="token plain">        public void before(JoinPoint pjp) {</span></div><div class="token-line"><span class="token plain">            log.info(&quot;within(feign.Client+) pjp {}, args:{}&quot;, pjp, pjp.getArgs());</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    //配置扫描Feign</span></div><div class="token-line"><span class="token plain">    @Configuration</span></div><div class="token-line"><span class="token plain">    @EnableFeignClients(basePackages = &quot;org.geekbang.time.commonmistakes.spring.demo4.feign&quot;)</span></div><div class="token-line"><span class="token plain">    public class Config {</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>通过Feign调用服务后可以看到日志中有输出，的确实现了feign.Client的切入，切入的是execute方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[15:48:32.850] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo4.WrongAspect        :20  ] - within(feign.Client+) pjp execution(Response feign.Client.execute(Request,Options)), args:[GET http://client/feignaop/server HTTP/1.1</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Binary data, feign.Request$Options@5c16561a]</span></div></pre></div><p>一开始这个项目使用的是客户端的负载均衡，也就是让Ribbon来做负载均衡，代码没啥问题。后来因为后端服务通过Nginx实现服务端负载均衡，所以开发同学把@FeignClient的配置设置了URL属性，直接通过一个固定URL调用后端服务：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@FeignClient(name = &quot;anotherClient&quot;,url = &quot;http://localhost:45678&quot;)</span></div><div class="token-line"><span class="token plain">    public interface ClientWithUrl {</span></div><div class="token-line"><span class="token plain">        @GetMapping(&quot;/feignaop/server&quot;)</span></div><div class="token-line"><span class="token plain">        String api();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>但这样配置后，之前的AOP切面竟然失效了，也就是within(feign.Client+)无法切入ClientWithUrl的调用了。</p><p>为了还原这个场景，我写了一段代码，定义两个方法分别通过Client和ClientWithUrl这两个Feign进行接口调用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Autowired</span></div><div class="token-line"><span class="token plain">    private Client client;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Autowired</span></div><div class="token-line"><span class="token plain">    private ClientWithUrl clientWithUrl;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @GetMapping(&quot;client&quot;)</span></div><div class="token-line"><span class="token plain">    public String client() {</span></div><div class="token-line"><span class="token plain">        return client.api();</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @GetMapping(&quot;clientWithUrl&quot;)</span></div><div class="token-line"><span class="token plain">    public String clientWithUrl() {</span></div><div class="token-line"><span class="token plain">        return clientWithUrl.api();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，调用Client后AOP有日志输出，调用ClientWithUrl后却没有：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[15:50:32.850] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo4.WrongAspect        :20  ] - within(feign.Client+) pjp execution(Response feign.Client.execute(Request,Options)), args:[GET http://client/feignaop/server HTTP/1.1</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Binary data, feign.Request$Options@5c16561</span></div></pre></div><p>这就很费解了。难道为Feign指定了URL，其实现就不是feign.Clinet了吗？</p><p>要明白原因，我们需要分析一下FeignClient的创建过程，也就是分析FeignClientFactoryBean类的getTarget方法。源码第4行有一个if判断，当URL没有内容也就是为空或者不配置时调用loadBalance方法，在其内部通过FeignContext从容器获取feign.Client的实例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;T&gt; T getTarget() {</span></div><div class="token-line"><span class="token plain">    	FeignContext context = this.applicationContext.getBean(FeignContext.class);</span></div><div class="token-line"><span class="token plain">    	Feign.Builder builder = feign(context);</span></div><div class="token-line"><span class="token plain">    	if (!StringUtils.hasText(this.url)) {</span></div><div class="token-line"><span class="token plain">    		...</span></div><div class="token-line"><span class="token plain">    		return (T) loadBalance(builder, context,</span></div><div class="token-line"><span class="token plain">    				new HardCodedTarget&lt;&gt;(this.type, this.name, this.url));</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	...</span></div><div class="token-line"><span class="token plain">    	String url = this.url + cleanPath();</span></div><div class="token-line"><span class="token plain">    	Client client = getOptional(context, Client.class);</span></div><div class="token-line"><span class="token plain">    	if (client != null) {</span></div><div class="token-line"><span class="token plain">    		if (client instanceof LoadBalancerFeignClient) {</span></div><div class="token-line"><span class="token plain">    			// not load balancing because we have a url,</span></div><div class="token-line"><span class="token plain">    			// but ribbon is on the classpath, so unwrap</span></div><div class="token-line"><span class="token plain">    			client = ((LoadBalancerFeignClient) client).getDelegate();</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    		builder.client(client);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	...</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    protected &lt;T&gt; T loadBalance(Feign.Builder builder, FeignContext context,</span></div><div class="token-line"><span class="token plain">    		HardCodedTarget&lt;T&gt; target) {</span></div><div class="token-line"><span class="token plain">    	Client client = getOptional(context, Client.class);</span></div><div class="token-line"><span class="token plain">    	if (client != null) {</span></div><div class="token-line"><span class="token plain">    		builder.client(client);</span></div><div class="token-line"><span class="token plain">    		Targeter targeter = get(context, Targeter.class);</span></div><div class="token-line"><span class="token plain">    		return targeter.target(this, builder, context, target);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    protected &lt;T&gt; T getOptional(FeignContext context, Class&lt;T&gt; type) {</span></div><div class="token-line"><span class="token plain">    	return context.getInstance(this.contextId, type);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>调试一下可以看到，client是LoadBalanceFeignClient，已经是经过代理增强的，明显是一个Bean：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage05fd0510e28cd764aaf7f1b4b4ca03049ffd.5c415704.png" alt=""/></p><p>所以，没有指定URL的@FeignClient对应的LoadBalanceFeignClient，是可以通过feign.Client切入的。</p><p>在我们上面贴出来的源码的16行可以看到，当URL不为空的时候，client设置为了LoadBalanceFeignClient的delegate属性。其原因注释中有提到，因为有了URL就不需要客户端负载均衡了，但因为Ribbon在classpath中，所以需要从LoadBalanceFeignClient提取出真正的Client。断点调试下可以看到，这时client是一个ApacheHttpClient：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage1b301b872a900be7327f74bc09bde4c54230.14fa3341.png" alt=""/></p><p>那么，这个ApacheHttpClient是从哪里来的呢？这里，我教你一个小技巧：如果你希望知道一个类是怎样调用栈初始化的，可以在构造方法中设置一个断点进行调试。这样，你就可以在IDE的栈窗口看到整个方法调用栈，然后点击每一个栈帧看到整个过程。</p><p>用这种方式，我们可以看到，是HttpClientFeignLoadBalancedConfiguration类实例化的ApacheHttpClient：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage7b9a7b712acf6d7062ae82f1fd04b954ff9a.92fb3a82.png" alt=""/></p><p>进一步查看HttpClientFeignLoadBalancedConfiguration的源码可以发现，LoadBalancerFeignClient这个Bean在实例化的时候，new出来一个ApacheHttpClient作为delegate放到了LoadBalancerFeignClient中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Bean</span></div><div class="token-line"><span class="token plain">    @ConditionalOnMissingBean(Client.class)</span></div><div class="token-line"><span class="token plain">    public Client feignClient(CachingSpringLoadBalancerFactory cachingFactory,</span></div><div class="token-line"><span class="token plain">          SpringClientFactory clientFactory, HttpClient httpClient) {</span></div><div class="token-line"><span class="token plain">       ApacheHttpClient delegate = new ApacheHttpClient(httpClient);</span></div><div class="token-line"><span class="token plain">       return new LoadBalancerFeignClient(delegate, cachingFactory, clientFactory);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public LoadBalancerFeignClient(Client delegate,</span></div><div class="token-line"><span class="token plain">          CachingSpringLoadBalancerFactory lbClientFactory,</span></div><div class="token-line"><span class="token plain">          SpringClientFactory clientFactory) {</span></div><div class="token-line"><span class="token plain">       this.delegate = delegate;</span></div><div class="token-line"><span class="token plain">       this.lbClientFactory = lbClientFactory;</span></div><div class="token-line"><span class="token plain">       this.clientFactory = clientFactory;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>显然，ApacheHttpClient是new出来的，并不是Bean，而LoadBalancerFeignClient是一个Bean。</p><p>有了这个信息，我们再来捋一下，为什么within(feign.Client+)无法切入设置过URL的@FeignClient ClientWithUrl：</p><ul><li>表达式声明的是切入feign.Client的实现类。</li><li>Spring只能切入由自己管理的Bean。</li><li><strong>虽然LoadBalancerFeignClient和ApacheHttpClient都是feign.Client接口的实现，但是HttpClientFeignLoadBalancedConfiguration的自动配置只是把前者定义为Bean，后者是new出来的、作为了LoadBalancerFeignClient的delegate，不是Bean</strong>。</li><li>在定义了FeignClient的URL属性后，我们获取的是LoadBalancerFeignClient的delegate，它不是Bean。</li></ul><p>因此，定义了URL的FeignClient采用within(feign.Client+)无法切入。</p><p>那，如何解决这个问题呢？有一位同学提出，修改一下切点表达式，通过@FeignClient注解来切：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Before(&quot;@within(org.springframework.cloud.openfeign.FeignClient)&quot;)</span></div><div class="token-line"><span class="token plain">    public void before(JoinPoint pjp){</span></div><div class="token-line"><span class="token plain">        log.info(&quot;@within(org.springframework.cloud.openfeign.FeignClient) pjp {}, args:{}&quot;, pjp, pjp.getArgs());</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>修改后通过日志看到，AOP的确切成功了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[15:53:39.093] [http-nio-45678-exec-3] [INFO ] [o.g.t.c.spring.demo4.Wrong2Aspect       :17  ] - @within(org.springframework.cloud.openfeign.FeignClient) pjp execution(String org.geekbang.time.commonmistakes.spring.demo4.feign.ClientWithUrl.api()), args:[]</span></div></pre></div><p>但仔细一看就会发现，<strong>这次切入的是ClientWithUrl接口的API方法，并不是client.Feign接口的execute方法，显然不符合预期</strong>。</p><p>这位同学犯的错误是，没有弄清楚真正希望切的是什么对象。@FeignClient注解标记在Feign Client接口上，所以切的是Feign定义的接口，也就是每一个实际的API接口。而通过feign.Client接口切的是客户端实现类，切到的是通用的、执行所有Feign调用的execute方法。</p><p>那么问题来了，ApacheHttpClient不是Bean无法切入，切Feign接口本身又不符合要求。怎么办呢？</p><p>经过一番研究发现，ApacheHttpClient其实有机会独立成为Bean。查看HttpClientFeignConfiguration的源码可以发现，当没有ILoadBalancer类型的时候，自动装配会把ApacheHttpClient设置为Bean。</p><p>这么做的原因很明确，如果我们不希望做客户端负载均衡的话，应该不会引用Ribbon组件的依赖，自然没有LoadBalancerFeignClient，只有ApacheHttpClient：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Configuration</span></div><div class="token-line"><span class="token plain">    @ConditionalOnClass(ApacheHttpClient.class)</span></div><div class="token-line"><span class="token plain">    @ConditionalOnMissingClass(&quot;com.netflix.loadbalancer.ILoadBalancer&quot;)</span></div><div class="token-line"><span class="token plain">    @ConditionalOnMissingBean(CloseableHttpClient.class)</span></div><div class="token-line"><span class="token plain">    @ConditionalOnProperty(value = &quot;feign.httpclient.enabled&quot;, matchIfMissing = true)</span></div><div class="token-line"><span class="token plain">    protected static class HttpClientFeignConfiguration {</span></div><div class="token-line"><span class="token plain">    	@Bean</span></div><div class="token-line"><span class="token plain">    	@ConditionalOnMissingBean(Client.class)</span></div><div class="token-line"><span class="token plain">    	public Client feignClient(HttpClient httpClient) {</span></div><div class="token-line"><span class="token plain">    		return new ApacheHttpClient(httpClient);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>那，把pom.xml中的ribbon模块注释之后，是不是可以解决问题呢？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;dependency&gt;</span></div><div class="token-line"><span class="token plain">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></div><div class="token-line"><span class="token plain">      &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/dependency&gt;</span></div></pre></div><p>但，问题并没解决，启动出错误了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Caused by: java.lang.IllegalArgumentException: Cannot subclass final class feign.httpclient.ApacheHttpClient</span></div><div class="token-line"><span class="token plain">    	at org.springframework.cglib.proxy.Enhancer.generateClass(Enhancer.java:657)</span></div><div class="token-line"><span class="token plain">    	at org.springframework.cglib.core.DefaultGeneratorStrategy.generate(DefaultGeneratorStrategy.java:25)</span></div></pre></div><p>这里，又涉及了Spring实现动态代理的两种方式：</p><ul><li>JDK动态代理，通过反射实现，只支持对实现接口的类进行代理；</li><li>CGLIB动态字节码注入方式，通过继承实现代理，没有这个限制。</li></ul><p><strong>Spring Boot 2.x默认使用CGLIB的方式，但通过继承实现代理有个问题是，无法继承final的类。因为，ApacheHttpClient类就是定义为了final</strong>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public final class ApacheHttpClient implements Client {</span></div></pre></div><p>为解决这个问题，我们把配置参数proxy-target-class的值修改为false，以切换到使用JDK动态代理的方式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">spring.aop.proxy-target-class=false</span></div></pre></div><p>修改后执行clientWithUrl接口可以看到，通过within(feign.Client+)方式可以切入feign.Client子类了。以下日志显示了@within和within的两次切入：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[16:29:55.303] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo4.Wrong2Aspect       :16  ] - @within(org.springframework.cloud.openfeign.FeignClient) pjp execution(String org.geekbang.time.commonmistakes.spring.demo4.feign.ClientWithUrl.api()), args:[]</span></div><div class="token-line"><span class="token plain">    [16:29:55.310] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.spring.demo4.WrongAspect        :15  ] - within(feign.Client+) pjp execution(Response feign.Client.execute(Request,Options)), args:[GET http://localhost:45678/feignaop/server HTTP/1.1</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Binary data, feign.Request$Options@387550b0]</span></div></pre></div><p>这下我们就明白了，Spring Cloud使用了自动装配来根据依赖装配组件，组件是否成为Bean决定了AOP是否可以切入，在尝试通过AOP切入Spring Bean的时候要注意。</p><p>加上上一讲的两个案例，我就把IoC和AOP相关的坑点和你说清楚了。除此之外，我们在业务开发时，还有一个绕不开的点是，Spring程序的配置问题。接下来，我们就具体看看吧。</p><h2 id="spring程序配置的优先级问题"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/22#spring程序配置的优先级问题"><span class="icon icon-link"></span></a>Spring程序配置的优先级问题</h2><p>我们知道，通过配置文件application.properties，可以实现Spring Boot应用程序的参数配置。但我们可能不知道的是，Spring程序配置是有优先级的，即当两个不同的配置源包含相同的配置项时，其中一个配置项很可能会被覆盖掉。这，也是为什么我们会遇到些看似诡异的配置失效问题。</p><p>我们来通过一个实际案例，研究下配置源以及配置源的优先级问题。</p><p>对于Spring Boot应用程序，一般我们会通过设置management.server.port参数，来暴露独立的actuator管理端口。这样做更安全，也更方便监控系统统一监控程序是否健康。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">management.server.port=45679</span></div></pre></div><p>有一天程序重新发布后，监控系统显示程序离线。但排查下来发现，程序是正常工作的，只是actuator管理端口的端口号被改了，不是配置文件中定义的45679了。</p><p>后来发现，运维同学在服务器上定义了两个环境变量MANAGEMENT_SERVER_IP和MANAGEMENT_SERVER_PORT，目的是方便监控Agent把监控数据上报到统一的管理服务上：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">MANAGEMENT_SERVER_IP=192.168.0.2</span></div><div class="token-line"><span class="token plain">    MANAGEMENT_SERVER_PORT=12345</span></div></pre></div><p>问题就是出在这里。MANAGEMENT_SERVER_PORT覆盖了配置文件中的management.server.port，修改了应用程序本身的端口。当然，监控系统也就无法通过老的管理端口访问到应用的health端口了。如下图所示，actuator的端口号变成了12345：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimageb2e6b287b7ad823a39bb604fa69e02c720e6.da0a561c.png" alt=""/></p><p>到这里坑还没完，为了方便用户登录，需要在页面上显示默认的管理员用户名，于是开发同学在配置文件中定义了一个user.name属性，并设置为defaultadminname：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">user.name=defaultadminname</span></div></pre></div><p>后来发现，程序读取出来的用户名根本就不是配置文件中定义的。这，又是咋回事？</p><p>带着这个问题，以及之前环境变量覆盖配置文件配置的问题，我们写段代码看看，从Spring中到底能读取到几个management.server.port和user.name配置项。</p><p>要想查询Spring中所有的配置，我们需要以环境Environment接口为入口。接下来，我就与你说说Spring通过环境Environment抽象出的Property和Profile：</p><ul><li>针对Property，又抽象出各种PropertySource类代表配置源。一个环境下可能有多个配置源，每个配置源中有诸多配置项。在查询配置信息时，需要按照配置源优先级进行查询。</li><li>Profile定义了场景的概念。通常，我们会定义类似dev、test、stage和prod等环境作为不同的Profile，用于按照场景对Bean进行逻辑归属。同时，Profile和配置文件也有关系，每个环境都有独立的配置文件，但我们只会激活某一个环境来生效特定环境的配置文件。</li></ul><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage2cc02c68da94d31182cad34c965f878196c0.5e995315.png" alt=""/></p><p>接下来，我们重点看看Property的查询过程。</p><p>对于非Web应用，Spring对于Environment接口的实现是StandardEnvironment类。我们通过Spring注入StandardEnvironment后循环getPropertySources获得的PropertySource，来查询所有的PropertySource中key是user.name或management.server.port的属性值；然后遍历getPropertySources方法，获得所有配置源并打印出来：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Autowired</span></div><div class="token-line"><span class="token plain">    private StandardEnvironment env;</span></div><div class="token-line"><span class="token plain">    @PostConstruct</span></div><div class="token-line"><span class="token plain">    public void init(){</span></div><div class="token-line"><span class="token plain">        Arrays.asList(&quot;user.name&quot;, &quot;management.server.port&quot;).forEach(key -&gt; {</span></div><div class="token-line"><span class="token plain">             env.getPropertySources().forEach(propertySource -&gt; {</span></div><div class="token-line"><span class="token plain">                        if (propertySource.containsProperty(key)) {</span></div><div class="token-line"><span class="token plain">                            log.info(&quot;{} -&gt; {} 实际取值：{}&quot;, propertySource, propertySource.getProperty(key), env.getProperty(key));</span></div><div class="token-line"><span class="token plain">                        }</span></div><div class="token-line"><span class="token plain">                    });</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        System.out.println(&quot;配置优先级：&quot;);</span></div><div class="token-line"><span class="token plain">        env.getPropertySources().stream().forEach(System.out::println);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们研究下输出的日志：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">2020-01-15 16:08:34.054  INFO 40123 --- [           main] o.g.t.c.s.d.CommonMistakesApplication    : ConfigurationPropertySourcesPropertySource {name=&#x27;configurationProperties&#x27;} -&gt; zhuye 实际取值：zhuye</span></div><div class="token-line"><span class="token plain">    2020-01-15 16:08:34.054  INFO 40123 --- [           main] o.g.t.c.s.d.CommonMistakesApplication    : PropertiesPropertySource {name=&#x27;systemProperties&#x27;} -&gt; zhuye 实际取值：zhuye</span></div><div class="token-line"><span class="token plain">    2020-01-15 16:08:34.054  INFO 40123 --- [           main] o.g.t.c.s.d.CommonMistakesApplication    : OriginTrackedMapPropertySource {name=&#x27;applicationConfig: [classpath:/application.properties]&#x27;} -&gt; defaultadminname 实际取值：zhuye</span></div><div class="token-line"><span class="token plain">    2020-01-15 16:08:34.054  INFO 40123 --- [           main] o.g.t.c.s.d.CommonMistakesApplication    : ConfigurationPropertySourcesPropertySource {name=&#x27;configurationProperties&#x27;} -&gt; 12345 实际取值：12345</span></div><div class="token-line"><span class="token plain">    2020-01-15 16:08:34.054  INFO 40123 --- [           main] o.g.t.c.s.d.CommonMistakesApplication    : OriginAwareSystemEnvironmentPropertySource {name=&#x27;&#x27;} -&gt; 12345 实际取值：12345</span></div><div class="token-line"><span class="token plain">    2020-01-15 16:08:34.054  INFO 40123 --- [           main] o.g.t.c.s.d.CommonMistakesApplication    : OriginTrackedMapPropertySource {name=&#x27;applicationConfig: [classpath:/application.properties]&#x27;} -&gt; 45679 实际取值：12345</span></div><div class="token-line"><span class="token plain">    配置优先级：</span></div><div class="token-line"><span class="token plain">    ConfigurationPropertySourcesPropertySource {name=&#x27;configurationProperties&#x27;}</span></div><div class="token-line"><span class="token plain">    StubPropertySource {name=&#x27;servletConfigInitParams&#x27;}</span></div><div class="token-line"><span class="token plain">    ServletContextPropertySource {name=&#x27;servletContextInitParams&#x27;}</span></div><div class="token-line"><span class="token plain">    PropertiesPropertySource {name=&#x27;systemProperties&#x27;}</span></div><div class="token-line"><span class="token plain">    OriginAwareSystemEnvironmentPropertySource {name=&#x27;systemEnvironment&#x27;}</span></div><div class="token-line"><span class="token plain">    RandomValuePropertySource {name=&#x27;random&#x27;}</span></div><div class="token-line"><span class="token plain">    OriginTrackedMapPropertySource {name=&#x27;applicationConfig: [classpath:/application.properties]&#x27;}</span></div><div class="token-line"><span class="token plain">    MapPropertySource {name=&#x27;springCloudClientHostInfo&#x27;}</span></div><div class="token-line"><span class="token plain">    MapPropertySource {name=&#x27;defaultProperties&#x27;}</span></div></pre></div><ul><li>有三处定义了user.name：第一个是configurationProperties，值是zhuye；第二个是systemProperties，代表系统配置，值是zhuye；第三个是applicationConfig，也就是我们的配置文件，值是配置文件中定义的defaultadminname。</li><li>同样地，也有三处定义了management.server.port：第一个是configurationProperties，值是12345；第二个是systemEnvironment代表系统环境，值是12345；第三个是applicationConfig，也就是我们的配置文件，值是配置文件中定义的45679。</li><li>第7到16行的输出显示，Spring中有9个配置源，值得关注是ConfigurationPropertySourcesPropertySource、PropertiesPropertySource、OriginAwareSystemEnvironmentPropertySource和我们的配置文件。</li></ul><p>那么，Spring真的是按这个顺序查询配置吗？最前面的configurationProperties，又是什么？为了回答这2个问题，我们需要分析下源码。我先说明下，下面源码分析的逻辑有些复杂，你可以结合着下面的整体流程图来理解：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage3ef93e6dc6456f6d1354da58fb260775c0f9.6f3de395.png" alt=""/></p><p>Demo中注入的StandardEnvironment，继承的是AbstractEnvironment（图中紫色类）。AbstractEnvironment的源码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public abstract class AbstractEnvironment implements ConfigurableEnvironment {</span></div><div class="token-line"><span class="token plain">    	private final MutablePropertySources propertySources = new MutablePropertySources();</span></div><div class="token-line"><span class="token plain">    	private final ConfigurablePropertyResolver propertyResolver =</span></div><div class="token-line"><span class="token plain">    			new PropertySourcesPropertyResolver(this.propertySources);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	public String getProperty(String key) {</span></div><div class="token-line"><span class="token plain">    		return this.propertyResolver.getProperty(key);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到：</p><ul><li>MutablePropertySources类型的字段propertySources，看起来代表了所有配置源；</li><li>getProperty方法，通过PropertySourcesPropertyResolver类进行查询配置；</li><li>实例化PropertySourcesPropertyResolver的时候，传入了当前的MutablePropertySources。</li></ul><p>接下来，我们继续分析MutablePropertySources和PropertySourcesPropertyResolver。先看看MutablePropertySources的源码（图中蓝色类）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class MutablePropertySources implements PropertySources {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	private final List&lt;PropertySource&lt;?&gt;&gt; propertySourceList = new CopyOnWriteArrayList&lt;&gt;();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	public void addFirst(PropertySource&lt;?&gt; propertySource) {</span></div><div class="token-line"><span class="token plain">    		removeIfPresent(propertySource);</span></div><div class="token-line"><span class="token plain">    		this.propertySourceList.add(0, propertySource);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	public void addLast(PropertySource&lt;?&gt; propertySource) {</span></div><div class="token-line"><span class="token plain">    		removeIfPresent(propertySource);</span></div><div class="token-line"><span class="token plain">    		this.propertySourceList.add(propertySource);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	public void addBefore(String relativePropertySourceName, PropertySource&lt;?&gt; propertySource) {</span></div><div class="token-line"><span class="token plain">    		...</span></div><div class="token-line"><span class="token plain">    		int index = assertPresentAndGetIndex(relativePropertySourceName);</span></div><div class="token-line"><span class="token plain">    		addAtIndex(index, propertySource);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">        public void addAfter(String relativePropertySourceName, PropertySource&lt;?&gt; propertySource) {</span></div><div class="token-line"><span class="token plain">           ...</span></div><div class="token-line"><span class="token plain">           int index = assertPresentAndGetIndex(relativePropertySourceName);</span></div><div class="token-line"><span class="token plain">           addAtIndex(index + 1, propertySource);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        private void addAtIndex(int index, PropertySource&lt;?&gt; propertySource) {</span></div><div class="token-line"><span class="token plain">           removeIfPresent(propertySource);</span></div><div class="token-line"><span class="token plain">           this.propertySourceList.add(index, propertySource);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以发现：</p><ul><li>propertySourceList字段用来真正保存PropertySource的List，且这个List是一个CopyOnWriteArrayList。</li><li>类中定义了addFirst、addLast、addBefore、addAfter等方法，来精确控制PropertySource加入propertySourceList的顺序。这也说明了顺序的重要性。</li></ul><p>继续看下PropertySourcesPropertyResolver（图中绿色类）的源码，找到真正查询配置的方法getProperty。</p><p>这里，我们重点看一下第9行代码：遍历的propertySources是PropertySourcesPropertyResolver构造方法传入的，再结合AbstractEnvironment的源码可以发现，这个propertySources正是AbstractEnvironment中的MutablePropertySources对象。遍历时，如果发现配置源中有对应的Key值，则使用这个值。因此，MutablePropertySources中配置源的次序尤为重要。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class PropertySourcesPropertyResolver extends AbstractPropertyResolver {</span></div><div class="token-line"><span class="token plain">    	private final PropertySources propertySources;</span></div><div class="token-line"><span class="token plain">    	public PropertySourcesPropertyResolver(@Nullable PropertySources propertySources) {</span></div><div class="token-line"><span class="token plain">    		this.propertySources = propertySources;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">    	protected &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetValueType, boolean resolveNestedPlaceholders) {</span></div><div class="token-line"><span class="token plain">    		if (this.propertySources != null) {</span></div><div class="token-line"><span class="token plain">    			for (PropertySource&lt;?&gt; propertySource : this.propertySources) {</span></div><div class="token-line"><span class="token plain">    				if (logger.isTraceEnabled()) {</span></div><div class="token-line"><span class="token plain">    					logger.trace(&quot;Searching for key &#x27;&quot; + key + &quot;&#x27; in PropertySource &#x27;&quot; +</span></div><div class="token-line"><span class="token plain">    							propertySource.getName() + &quot;&#x27;&quot;);</span></div><div class="token-line"><span class="token plain">    				}</span></div><div class="token-line"><span class="token plain">    				Object value = propertySource.getProperty(key);</span></div><div class="token-line"><span class="token plain">    				if (value != null) {</span></div><div class="token-line"><span class="token plain">    					if (resolveNestedPlaceholders &amp;&amp; value instanceof String) {</span></div><div class="token-line"><span class="token plain">    						value = resolveNestedPlaceholders((String) value);</span></div><div class="token-line"><span class="token plain">    					}</span></div><div class="token-line"><span class="token plain">    					logKeyFound(key, propertySource, value);</span></div><div class="token-line"><span class="token plain">    					return convertValueIfNecessary(value, targetValueType);</span></div><div class="token-line"><span class="token plain">    				}</span></div><div class="token-line"><span class="token plain">    			}</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    		...</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>回到之前的问题，在查询所有配置源的时候，我们注意到处在第一位的是ConfigurationPropertySourcesPropertySource，这是什么呢？</p><p>其实，它不是一个实际存在的配置源，扮演的是一个代理的角色。但通过调试你会发现，我们获取的值竟然是由它提供并且返回的，且没有循环遍历后面的PropertySource：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage73fb7380c93e743e3fc41d8cc58b77895bfb.287db7a7.png" alt=""/></p><p>继续查看ConfigurationPropertySourcesPropertySource（图中红色类）的源码可以发现，getProperty方法其实是通过findConfigurationProperty方法查询配置的。如第25行代码所示，这其实还是在遍历所有的配置源：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class ConfigurationPropertySourcesPropertySource extends PropertySource&lt;Iterable&lt;ConfigurationPropertySource&gt;&gt;</span></div><div class="token-line"><span class="token plain">    		implements OriginLookup&lt;String&gt; {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	ConfigurationPropertySourcesPropertySource(String name, Iterable&lt;ConfigurationPropertySource&gt; source) {</span></div><div class="token-line"><span class="token plain">    		super(name, source);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	@Override</span></div><div class="token-line"><span class="token plain">    	public Object getProperty(String name) {</span></div><div class="token-line"><span class="token plain">    		ConfigurationProperty configurationProperty = findConfigurationProperty(name);</span></div><div class="token-line"><span class="token plain">    		return (configurationProperty != null) ? configurationProperty.getValue() : null;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	private ConfigurationProperty findConfigurationProperty(String name) {</span></div><div class="token-line"><span class="token plain">    		try {</span></div><div class="token-line"><span class="token plain">    			return findConfigurationProperty(ConfigurationPropertyName.of(name, true));</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    		catch (Exception ex) {</span></div><div class="token-line"><span class="token plain">    			return null;</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	private ConfigurationProperty findConfigurationProperty(ConfigurationPropertyName name) {</span></div><div class="token-line"><span class="token plain">    		if (name == null) {</span></div><div class="token-line"><span class="token plain">    			return null;</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    		for (ConfigurationPropertySource configurationPropertySource : getSource()) {</span></div><div class="token-line"><span class="token plain">    			ConfigurationProperty configurationProperty = configurationPropertySource.getConfigurationProperty(name);</span></div><div class="token-line"><span class="token plain">    			if (configurationProperty != null) {</span></div><div class="token-line"><span class="token plain">    				return configurationProperty;</span></div><div class="token-line"><span class="token plain">    			}</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    		return null;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>调试可以发现，这个循环遍历（getSource()的结果）的配置源，其实是SpringConfigurationPropertySources（图中黄色类），其中包含的配置源列表就是之前看到的9个配置源，而第一个就是ConfigurationPropertySourcesPropertySource。看到这里，我们的第一感觉是会不会产生死循环，它在遍历的时候怎么排除自己呢？</p><p>同时观察configurationProperty可以看到，这个ConfigurationProperty其实类似代理的角色，实际配置是从系统属性中获得的：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage950a9551d5b5acada84262b7ddeae989750a.e70d8a20.png" alt=""/></p><p>继续查看SpringConfigurationPropertySources可以发现，它返回的迭代器是内部类SourcesIterator，在fetchNext方法获取下一个项时，通过isIgnored方法排除了ConfigurationPropertySourcesPropertySource（源码第38行）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class SpringConfigurationPropertySources implements Iterable&lt;ConfigurationPropertySource&gt; {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	private final Iterable&lt;PropertySource&lt;?&gt;&gt; sources;</span></div><div class="token-line"><span class="token plain">    	private final Map&lt;PropertySource&lt;?&gt;, ConfigurationPropertySource&gt; cache = new ConcurrentReferenceHashMap&lt;&gt;(16,</span></div><div class="token-line"><span class="token plain">    			ReferenceType.SOFT);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	SpringConfigurationPropertySources(Iterable&lt;PropertySource&lt;?&gt;&gt; sources) {</span></div><div class="token-line"><span class="token plain">    		Assert.notNull(sources, &quot;Sources must not be null&quot;);</span></div><div class="token-line"><span class="token plain">    		this.sources = sources;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	@Override</span></div><div class="token-line"><span class="token plain">    	public Iterator&lt;ConfigurationPropertySource&gt; iterator() {</span></div><div class="token-line"><span class="token plain">    		return new SourcesIterator(this.sources.iterator(), this::adapt);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	private static class SourcesIterator implements Iterator&lt;ConfigurationPropertySource&gt; {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		@Override</span></div><div class="token-line"><span class="token plain">    		public boolean hasNext() {</span></div><div class="token-line"><span class="token plain">    			return fetchNext() != null;</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		private ConfigurationPropertySource fetchNext() {</span></div><div class="token-line"><span class="token plain">    			if (this.next == null) {</span></div><div class="token-line"><span class="token plain">    				if (this.iterators.isEmpty()) {</span></div><div class="token-line"><span class="token plain">    					return null;</span></div><div class="token-line"><span class="token plain">    				}</span></div><div class="token-line"><span class="token plain">    				if (!this.iterators.peek().hasNext()) {</span></div><div class="token-line"><span class="token plain">    					this.iterators.pop();</span></div><div class="token-line"><span class="token plain">    					return fetchNext();</span></div><div class="token-line"><span class="token plain">    				}</span></div><div class="token-line"><span class="token plain">    				PropertySource&lt;?&gt; candidate = this.iterators.peek().next();</span></div><div class="token-line"><span class="token plain">    				if (candidate.getSource() instanceof ConfigurableEnvironment) {</span></div><div class="token-line"><span class="token plain">    					push((ConfigurableEnvironment) candidate.getSource());</span></div><div class="token-line"><span class="token plain">    					return fetchNext();</span></div><div class="token-line"><span class="token plain">    				}</span></div><div class="token-line"><span class="token plain">    				if (isIgnored(candidate)) {</span></div><div class="token-line"><span class="token plain">    					return fetchNext();</span></div><div class="token-line"><span class="token plain">    				}</span></div><div class="token-line"><span class="token plain">    				this.next = this.adapter.apply(candidate);</span></div><div class="token-line"><span class="token plain">    			}</span></div><div class="token-line"><span class="token plain">    			return this.next;</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		private void push(ConfigurableEnvironment environment) {</span></div><div class="token-line"><span class="token plain">    			this.iterators.push(environment.getPropertySources().iterator());</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		private boolean isIgnored(PropertySource&lt;?&gt; candidate) {</span></div><div class="token-line"><span class="token plain">    			return (candidate instanceof StubPropertySource</span></div><div class="token-line"><span class="token plain">    					|| candidate instanceof ConfigurationPropertySourcesPropertySource);</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们已经了解了ConfigurationPropertySourcesPropertySource是所有配置源中的第一个，实现了对PropertySourcesPropertyResolver中遍历逻辑的“劫持”，并且知道了其遍历逻辑。最后一个问题是，它如何让自己成为第一个配置源呢？</p><p>再次运用之前我们学到的那个小技巧，来查看实例化ConfigurationPropertySourcesPropertySource的地方：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimagef45df43c15a2f491d88a0383023a42cebd5d.bdbe2d7a.png" alt=""/></p><p>可以看到，ConfigurationPropertySourcesPropertySource类是由ConfigurationPropertySources的attach方法实例化的。查阅源码可以发现，这个方法的确从环境中获得了原始的MutablePropertySources，把自己加入成为一个元素：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public final class ConfigurationPropertySources {</span></div><div class="token-line"><span class="token plain">    	public static void attach(Environment environment) {</span></div><div class="token-line"><span class="token plain">    		MutablePropertySources sources = ((ConfigurableEnvironment) environment).getPropertySources();</span></div><div class="token-line"><span class="token plain">    		PropertySource&lt;?&gt; attached = sources.get(ATTACHED_PROPERTY_SOURCE_NAME);</span></div><div class="token-line"><span class="token plain">    		if (attached == null) {</span></div><div class="token-line"><span class="token plain">    			sources.addFirst(new ConfigurationPropertySourcesPropertySource(ATTACHED_PROPERTY_SOURCE_NAME,</span></div><div class="token-line"><span class="token plain">    					new SpringConfigurationPropertySources(sources)));</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>而这个attach方法，是Spring应用程序启动时准备环境的时候调用的。在SpringApplication的run方法中调用了prepareEnvironment方法，然后又调用了ConfigurationPropertySources.attach方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class SpringApplication {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public ConfigurableApplicationContext run(String... args) {</span></div><div class="token-line"><span class="token plain">    		...</span></div><div class="token-line"><span class="token plain">    		try {</span></div><div class="token-line"><span class="token plain">    			ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span></div><div class="token-line"><span class="token plain">    			ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span></div><div class="token-line"><span class="token plain">    			...</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,</span></div><div class="token-line"><span class="token plain">    			ApplicationArguments applicationArguments) {</span></div><div class="token-line"><span class="token plain">    		...</span></div><div class="token-line"><span class="token plain">    		ConfigurationPropertySources.attach(environment);</span></div><div class="token-line"><span class="token plain">    		...</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>看到这里你是否彻底理清楚Spring劫持PropertySourcesPropertyResolver的实现方式，以及配置源有优先级的原因了呢？如果你想知道Spring各种预定义的配置源的优先级，可以参考<a target="_blank" rel="noopener noreferrer" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config">官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/22#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>今天，我用两个业务开发中的实际案例，带你进一步学习了Spring的AOP和配置优先级这两大知识点。现在，你应该也感受到Spring实现的复杂度了。</p><p>对于AOP切Feign的案例，我们在实现功能时走了一些弯路。Spring Cloud会使用Spring Boot的特性，根据当前引入包的情况做各种自动装配。如果我们要扩展Spring的组件，那么只有清晰了解Spring自动装配的运作方式，才能鉴别运行时对象在Spring容器中的情况，不能想当然认为代码中能看到的所有Spring的类都是Bean。</p><p>对于配置优先级的案例，分析配置源优先级时，如果我们以为看到PropertySourcesPropertyResolver就看到了真相，后续进行扩展开发时就可能会踩坑。我们一定要注意，<strong>分析Spring源码时，你看到的表象不一定是实际运行时的情况，还需要借助日志或调试工具来理清整个过程</strong>。如果没有调试工具，你可以借助<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/216830">第11讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>用到的Arthas，来分析代码调用路径。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a target="_blank" rel="noopener noreferrer" href="https://github.com/JosephZhu1983/java-common-mistakes">这个链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>查看。</p><h2 id="思考与讨论"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/02.代码篇/22#思考与讨论"><span class="icon icon-link"></span></a>思考与讨论</h2><ol><li>除了我们这两讲用到execution、within、@within、@annotation四个指示器外，Spring AOP还支持this、target、args、@target、@args。你能说说后面五种指示器的作用吗？</li><li>Spring的Environment中的PropertySources属性可以包含多个PropertySource，越往前优先级越高。那，我们能否利用这个特点实现配置文件中属性值的自动赋值呢？比如，我们可以定义%%MYSQL.URL%%、%%MYSQL.USERNAME%%和%%MYSQL.PASSWORD%%，分别代表数据库连接字符串、用户名和密码。在配置数据源时，我们只要设置其值为占位符，框架就可以自动根据当前应用程序名application.name，统一把占位符替换为真实的数据库信息。这样，生产的数据库信息就不需要放在配置文件中了，会更安全。</li></ol><p>关于Spring Core、Spring Boot和Spring Cloud，你还遇到过其他坑吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把今天的内容分享给你的朋友或同事，一起交流。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/java业务开发常见错误100例/02.代码篇/22.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:06:36</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-java/umi.fde43fdb.js"></script>
  </body>
</html>
