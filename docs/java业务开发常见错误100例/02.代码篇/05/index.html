<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-test/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-test";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>05 | HTTP调用：你考虑到超时、重试、并发了吗？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/java业务开发常见错误100例/02.代码篇/05" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a aria-current="page" class="active" href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-test/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-test/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a aria-current="page" class="active" href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-test/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-test/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java业务开发常见错误100例/01.开篇词">01.开篇词</a><ul><li><a href="/blog-test/java业务开发常见错误100例/01.开篇词/01"><span>开篇词 | 业务代码真的会有这么多坑？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-test/java业务开发常见错误100例/02.代码篇">02.代码篇</a><ul><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/01"><span>01 | 使用了并发工具类库，线程安全就高枕无忧了吗？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/02"><span>02 | 代码加锁：不要让“锁”事成为烦心事</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/03"><span>03 | 线程池：业务代码最常用也最容易犯错的组件</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/04"><span>04 | 连接池：别让连接池帮了倒忙</span></a></li><li><a aria-current="page" class="active" href="/blog-test/java业务开发常见错误100例/02.代码篇/05"><span>05 | HTTP调用：你考虑到超时、重试、并发了吗？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/06"><span>06 | 20%的业务代码的Spring声明式事务，可能都没处理正确</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/07"><span>答疑篇：代码篇思考题集锦（一）</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/08"><span>07 | 数据库索引：索引并不是万能药</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/09"><span>08 | 判等问题：程序里如何确定你就是你？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/10"><span>09 | 数值计算：注意精度、舍入和溢出问题</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/11"><span>10 | 集合类：坑满地的List列表操作</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/12"><span>11 | 空值处理：分不清楚的null和恼人的空指针</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/13"><span>12 | 异常处理：别让自己在出问题的时候变为瞎子</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/14"><span>答疑篇：代码篇思考题集锦（二）</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/15"><span>13 | 日志：日志记录真没你想象的那么简单</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/16"><span>14 | 文件IO：实现高效正确的文件读写并非易事</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/17"><span>15 | 序列化：一来一回你还是原来的你吗？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/18"><span>16 | 用好Java 8的日期时间类，少踩一些“老三样”的坑</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/19"><span>17 | 别以为“自动挡”就不可能出现OOM</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/20"><span>18 | 当反射、注解和泛型遇到OOP时，会有哪些坑？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/21"><span>19 | Spring框架：IoC和AOP是扩展的核心</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/22"><span>20 | Spring框架：框架帮我们做了很多工作也带来了复杂度</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/02.代码篇/23"><span>答疑篇：代码篇思考题集锦（三）</span></a></li></ul></li><li><a href="/blog-test/java业务开发常见错误100例/03.设计篇">03.设计篇</a><ul><li><a href="/blog-test/java业务开发常见错误100例/03.设计篇/01"><span>21 |  代码重复：搞定代码重复的三个绝招</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/03.设计篇/02"><span>22 | 接口设计：系统间对话的语言，一定要统一</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/03.设计篇/03"><span>23 | 缓存设计：缓存可以锦上添花也可以落井下石</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/03.设计篇/04"><span>24 | 业务代码写完，就意味着生产就绪了？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/03.设计篇/05"><span>25 | 异步处理好用，但非常容易用错</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/03.设计篇/06"><span>26 | 数据存储：NoSQL与RDBMS如何取长补短、相辅相成？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/03.设计篇/07"><span>答疑篇：设计篇思考题答案合集</span></a></li></ul></li><li><a href="/blog-test/java业务开发常见错误100例/04.安全篇">04.安全篇</a><ul><li><a href="/blog-test/java业务开发常见错误100例/04.安全篇/01"><span>27 | 数据源头：任何客户端的东西都不可信任</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/04.安全篇/02"><span>28 | 安全兜底：涉及钱时，必须考虑防刷、限量和防重</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/04.安全篇/03"><span>29 | 数据和代码：数据就是数据，代码就是代码</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/04.安全篇/04"><span>30 | 如何正确保存和传输敏感数据？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/04.安全篇/05"><span>答疑篇：安全篇思考题答案合集</span></a></li></ul></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐">05.加餐</a><ul><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/01"><span>31 | 加餐1：带你吃透课程中Java 8的那些重要知识点（一）</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/02"><span>32 | 加餐2：带你吃透课程中Java 8的那些重要知识点（二）</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/03"><span>33 | 加餐3：定位应用问题，排错套路很重要</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/04"><span>34 | 加餐4：分析定位Java问题，一定要用好这些工具（一）</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/05"><span>35 | 加餐5：分析定位Java问题，一定要用好这些工具（二）</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/06"><span>36 | 加餐6：这15年来，我是如何在工作中学习技术和英语的？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/07"><span>答疑篇：加餐篇思考题答案合集</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/08"><span>37 | 加餐7：程序员成长28计</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/05.加餐/09"><span>38 | 加餐8：Java程序从虚拟机迁移到Kubernetes的一些坑</span></a></li></ul></li><li><a href="/blog-test/java业务开发常见错误100例/06.结束语">06.结束语</a><ul><li><a href="/blog-test/java业务开发常见错误100例/06.结束语/01"><span>结束语 | 写代码时，如何才能尽量避免踩坑？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/06.结束语/02"><span>结课测试 | 关于Java业务开发的100个常见错误，你都明白其中缘由了吗？</span></a></li><li><a href="/blog-test/java业务开发常见错误100例/06.结束语/03"><span>结课问卷获奖用户名单</span></a></li></ul></li><li><a href="/blog-test/java业务开发常见错误100例/summary">java业务开发常见错误100例</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="配置连接超时和读取超时参数的学问" data-depth="2"><a href="/blog-test/java业务开发常见错误100例/02.代码篇/05#配置连接超时和读取超时参数的学问"><span>配置连接超时和读取超时参数的学问</span></a></li><li title="Feign和Ribbon配合使用，你知道怎么配置超时吗？" data-depth="2"><a href="/blog-test/java业务开发常见错误100例/02.代码篇/05#feign和ribbon配合使用你知道怎么配置超时吗"><span>Feign和Ribbon配合使用，你知道怎么配置超时吗？</span></a></li><li title="你是否知道Ribbon会自动重试请求呢？" data-depth="2"><a href="/blog-test/java业务开发常见错误100例/02.代码篇/05#你是否知道ribbon会自动重试请求呢"><span>你是否知道Ribbon会自动重试请求呢？</span></a></li><li title="并发限制了爬虫的抓取能力" data-depth="2"><a href="/blog-test/java业务开发常见错误100例/02.代码篇/05#并发限制了爬虫的抓取能力"><span>并发限制了爬虫的抓取能力</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-test/java业务开发常见错误100例/02.代码篇/05#重点回顾"><span>重点回顾</span></a></li><li title="思考与讨论" data-depth="2"><a href="/blog-test/java业务开发常见错误100例/02.代码篇/05#思考与讨论"><span>思考与讨论</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="05--http调用你考虑到超时重试并发了吗"><a aria-hidden="true" tabindex="-1" href="/blog-test/java业务开发常见错误100例/02.代码篇/05#05--http调用你考虑到超时重试并发了吗"><span class="icon icon-link"></span></a>05 | HTTP调用：你考虑到超时、重试、并发了吗？</h1><p>你好，我是朱晔。今天，我们一起聊聊进行HTTP调用需要注意的超时、重试、并发等问题。</p><p>与执行本地方法不同，进行HTTP调用本质上是通过HTTP协议进行一次网络请求。网络请求必然有超时的可能性，因此我们必须考虑到这三点：</p><ul><li>首先，框架设置的默认超时是否合理；</li><li>其次，考虑到网络的不稳定，超时后的请求重试是一个不错的选择，但需要考虑服务端接口的幂等性设计是否允许我们重试；</li><li>最后，需要考虑框架是否会像浏览器那样限制并发连接数，以免在服务并发很大的情况下，HTTP调用的并发数限制成为瓶颈。</li></ul><p>Spring Cloud是Java微服务架构的代表性框架。如果使用Spring Cloud进行微服务开发，就会使用Feign进行声明式的服务调用。如果不使用Spring Cloud，而直接使用Spring Boot进行微服务开发的话，可能会直接使用Java中最常用的HTTP客户端Apache HttpClient进行服务调用。</p><p>接下来，我们就看看使用Feign和Apache HttpClient进行HTTP接口调用时，可能会遇到的超时、重试和并发方面的坑。</p><h2 id="配置连接超时和读取超时参数的学问"><a aria-hidden="true" tabindex="-1" href="/blog-test/java业务开发常见错误100例/02.代码篇/05#配置连接超时和读取超时参数的学问"><span class="icon icon-link"></span></a>配置连接超时和读取超时参数的学问</h2><p>对于HTTP调用，虽然应用层走的是HTTP协议，但网络层面始终是TCP/IP协议。TCP/IP是面向连接的协议，在传输数据之前需要建立连接。几乎所有的网络框架都会提供这么两个超时参数：</p><ul><li>连接超时参数ConnectTimeout，让用户配置建连阶段的最长等待时间；</li><li>读取超时参数ReadTimeout，用来控制从Socket上读取数据的最长等待时间。</li></ul><p>这两个参数看似是网络层偏底层的配置参数，不足以引起开发同学的重视。但，正确理解和配置这两个参数，对业务应用特别重要，毕竟超时不是单方面的事情，需要客户端和服务端对超时有一致的估计，协同配合方能平衡吞吐量和错误率。</p><p><strong>连接超时参数和连接超时的误区有这么两个：</strong></p><ul><li>**连接超时配置得特别长，比如60秒。**一般来说，TCP三次握手建立连接需要的时间非常短，通常在毫秒级最多到秒级，不可能需要十几秒甚至几十秒。如果很久都无法建连，很可能是网络或防火墙配置的问题。这种情况下，如果几秒连接不上，那么可能永远也连接不上。因此，设置特别长的连接超时意义不大，将其配置得短一些（比如1~5秒）即可。如果是纯内网调用的话，这个参数可以设置得更短，在下游服务离线无法连接的时候，可以快速失败。</li><li>**排查连接超时问题，却没理清连的是哪里。**通常情况下，我们的服务会有多个节点，如果别的客户端通过客户端负载均衡技术来连接服务端，那么客户端和服务端会直接建立连接，此时出现连接超时大概率是服务端的问题；而如果服务端通过类似Nginx的反向代理来负载均衡，客户端连接的其实是Nginx，而不是服务端，此时出现连接超时应该排查Nginx。</li></ul><p><strong>读取超时参数和读取超时则会有更多的误区，我将其归纳为如下三个。</strong></p><p>**第一个误区：**认为出现了读取超时，服务端的执行就会中断。</p><p>我们来简单测试下。定义一个client接口，内部通过HttpClient调用服务端接口server，客户端读取超时2秒，服务端接口执行耗时5秒。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RestController</span></div><div class="token-line"><span class="token plain">    @RequestMapping(&quot;clientreadtimeout&quot;)</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class ClientReadTimeoutController {</span></div><div class="token-line"><span class="token plain">        private String getResponse(String url, int connectTimeout, int readTimeout) throws IOException {</span></div><div class="token-line"><span class="token plain">            return Request.Get(&quot;http://localhost:45678/clientreadtimeout&quot; + url)</span></div><div class="token-line"><span class="token plain">                    .connectTimeout(connectTimeout)</span></div><div class="token-line"><span class="token plain">                    .socketTimeout(readTimeout)</span></div><div class="token-line"><span class="token plain">                    .execute()</span></div><div class="token-line"><span class="token plain">                    .returnContent()</span></div><div class="token-line"><span class="token plain">                    .asString();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        @GetMapping(&quot;client&quot;)</span></div><div class="token-line"><span class="token plain">        public String client() throws IOException {</span></div><div class="token-line"><span class="token plain">            log.info(&quot;client1 called&quot;);</span></div><div class="token-line"><span class="token plain">            //服务端5s超时，客户端读取超时2秒</span></div><div class="token-line"><span class="token plain">            return getResponse(&quot;/server?timeout=5000&quot;, 1000, 2000);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @GetMapping(&quot;server&quot;)</span></div><div class="token-line"><span class="token plain">        public void server(@RequestParam(&quot;timeout&quot;) int timeout) throws InterruptedException {</span></div><div class="token-line"><span class="token plain">            log.info(&quot;server called&quot;);</span></div><div class="token-line"><span class="token plain">            TimeUnit.MILLISECONDS.sleep(timeout);</span></div><div class="token-line"><span class="token plain">            log.info(&quot;Done&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>调用client接口后，从日志中可以看到，客户端2秒后出现了SocketTimeoutException，原因是读取超时，服务端却丝毫没受影响在3秒后执行完成。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[11:35:11.943] [http-nio-45678-exec-1] [INFO ] [.t.c.c.d.ClientReadTimeoutController:29  ] - client1 called</span></div><div class="token-line"><span class="token plain">    [11:35:12.032] [http-nio-45678-exec-2] [INFO ] [.t.c.c.d.ClientReadTimeoutController:36  ] - server called</span></div><div class="token-line"><span class="token plain">    [11:35:14.042] [http-nio-45678-exec-1] [ERROR] [.a.c.c.C.[.[.[/].[dispatcherServlet]:175 ] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception</span></div><div class="token-line"><span class="token plain">    java.net.SocketTimeoutException: Read timed out</span></div><div class="token-line"><span class="token plain">    	at java.net.SocketInputStream.socketRead0(Native Method)</span></div><div class="token-line"><span class="token plain">    	...</span></div><div class="token-line"><span class="token plain">    [11:35:17.036] [http-nio-45678-exec-2] [INFO ] [.t.c.c.d.ClientReadTimeoutController:38  ] - Done</span></div></pre></div><p>我们知道，类似Tomcat的Web服务器都是把服务端请求提交到线程池处理的，只要服务端收到了请求，网络层面的超时和断开便不会影响服务端的执行。因此，出现读取超时不能随意假设服务端的处理情况，需要根据业务状态考虑如何进行后续处理。</p><p>**第二个误区：**认为读取超时只是Socket网络层面的概念，是数据传输的最长耗时，故将其配置得非常短，比如100毫秒。</p><p>其实，发生了读取超时，网络层面无法区分是服务端没有把数据返回给客户端，还是数据在网络上耗时较久或丢包。</p><p>但，因为TCP是先建立连接后传输数据，对于网络情况不是特别糟糕的服务调用，通常可以认为出现连接超时是网络问题或服务不在线，而出现读取超时是服务处理超时。确切地说，读取超时指的是，向Socket写入数据后，我们等到Socket返回数据的超时时间，其中包含的时间或者说绝大部分的时间，是服务端处理业务逻辑的时间。</p><p>**第三个误区：**认为超时时间越长任务接口成功率就越高，将读取超时参数配置得太长。</p><p>进行HTTP请求一般是需要获得结果的，属于同步调用。如果超时时间很长，在等待服务端返回数据的同时，客户端线程（通常是Tomcat线程）也在等待，当下游服务出现大量超时的时候，程序可能也会受到拖累创建大量线程，最终崩溃。</p><p>对定时任务或异步任务来说，读取超时配置得长些问题不大。但面向用户响应的请求或是微服务短平快的同步接口调用，并发量一般较大，我们应该设置一个较短的读取超时时间，以防止被下游服务拖慢，通常不会设置超过30秒的读取超时。</p><p>你可能会说，如果把读取超时设置为2秒，服务端接口需要3秒，岂不是永远都拿不到执行结果了？的确是这样，因此设置读取超时一定要根据实际情况，过长可能会让下游抖动影响到自己，过短又可能影响成功率。甚至，有些时候我们还要根据下游服务的SLA，为不同的服务端接口设置不同的客户端读取超时。</p><h2 id="feign和ribbon配合使用你知道怎么配置超时吗"><a aria-hidden="true" tabindex="-1" href="/blog-test/java业务开发常见错误100例/02.代码篇/05#feign和ribbon配合使用你知道怎么配置超时吗"><span class="icon icon-link"></span></a>Feign和Ribbon配合使用，你知道怎么配置超时吗？</h2><p>刚才我强调了根据自己的需求配置连接超时和读取超时的重要性，你是否尝试过为Spring Cloud的Feign配置超时参数呢，有没有被网上的各种资料绕晕呢？</p><p>在我看来，为Feign配置超时参数的复杂之处在于，Feign自己有两个超时参数，它使用的负载均衡组件Ribbon本身还有相关配置。那么，这些配置的优先级是怎样的，又哪些什么坑呢？接下来，我们做一些实验吧。</p><p>为测试服务端的超时，假设有这么一个服务端接口，什么都不干只休眠10分钟：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@PostMapping(&quot;/server&quot;)</span></div><div class="token-line"><span class="token plain">    public void server() throws InterruptedException {</span></div><div class="token-line"><span class="token plain">        TimeUnit.MINUTES.sleep(10);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>首先，定义一个Feign来调用这个接口：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@FeignClient(name = &quot;clientsdk&quot;)</span></div><div class="token-line"><span class="token plain">    public interface Client {</span></div><div class="token-line"><span class="token plain">        @PostMapping(&quot;/feignandribbon/server&quot;)</span></div><div class="token-line"><span class="token plain">        void server();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后，通过Feign Client进行接口调用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;client&quot;)</span></div><div class="token-line"><span class="token plain">    public void timeout() {</span></div><div class="token-line"><span class="token plain">        long begin=System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">        try{</span></div><div class="token-line"><span class="token plain">            client.server();</span></div><div class="token-line"><span class="token plain">        }catch (Exception ex){</span></div><div class="token-line"><span class="token plain">            log.warn(&quot;执行耗时：{}ms 错误：{}&quot;, System.currentTimeMillis() - begin, ex.getMessage());</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在配置文件仅指定服务端地址的情况下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">clientsdk.ribbon.listOfServers=localhost:45678</span></div></pre></div><p>得到如下输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[15:40:16.094] [http-nio-45678-exec-3] [WARN ] [o.g.t.c.h.f.FeignAndRibbonController    :26  ] - 执行耗时：1007ms 错误：Read timed out executing POST http://clientsdk/feignandribbon/server</span></div></pre></div><p>从这个输出中，我们可以得到<strong>结论一，默认情况下Feign的读取超时是1秒，如此短的读取超时算是坑点一</strong>。</p><p>我们来分析一下源码。打开RibbonClientConfiguration类后，会看到DefaultClientConfigImpl被创建出来之后，ReadTimeout和ConnectTimeout被设置为1s：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/**</span></div><div class="token-line"><span class="token plain">     * Ribbon client default connect timeout.</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    public static final int DEFAULT_CONNECT_TIMEOUT = 1000;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * Ribbon client default read timeout.</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    public static final int DEFAULT_READ_TIMEOUT = 1000;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Bean</span></div><div class="token-line"><span class="token plain">    @ConditionalOnMissingBean</span></div><div class="token-line"><span class="token plain">    public IClientConfig ribbonClientConfig() {</span></div><div class="token-line"><span class="token plain">       DefaultClientConfigImpl config = new DefaultClientConfigImpl();</span></div><div class="token-line"><span class="token plain">       config.loadProperties(this.name);</span></div><div class="token-line"><span class="token plain">       config.set(CommonClientConfigKey.ConnectTimeout, DEFAULT_CONNECT_TIMEOUT);</span></div><div class="token-line"><span class="token plain">       config.set(CommonClientConfigKey.ReadTimeout, DEFAULT_READ_TIMEOUT);</span></div><div class="token-line"><span class="token plain">       config.set(CommonClientConfigKey.GZipPayload, DEFAULT_GZIP_PAYLOAD);</span></div><div class="token-line"><span class="token plain">       return config;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果要修改Feign客户端默认的两个全局超时时间，你可以设置feign.client.config.default.readTimeout和feign.client.config.default.connectTimeout参数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">feign.client.config.default.readTimeout=3000</span></div><div class="token-line"><span class="token plain">    feign.client.config.default.connectTimeout=3000</span></div></pre></div><p>修改配置后重试，得到如下日志：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[15:43:39.955] [http-nio-45678-exec-3] [WARN ] [o.g.t.c.h.f.FeignAndRibbonController    :26  ] - 执行耗时：3006ms 错误：Read timed out executing POST http://clientsdk/feignandribbon/server</span></div></pre></div><p>可见，3秒读取超时生效了。注意：这里有一个大坑，如果你希望只修改读取超时，可能会只配置这么一行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">feign.client.config.default.readTimeout=3000</span></div></pre></div><p>测试一下你就会发现，这样的配置是无法生效的！</p><p><strong>结论二，也是坑点二，如果要配置Feign的读取超时，就必须同时配置连接超时，才能生效</strong>。</p><p>打开FeignClientFactoryBean可以看到，只有同时设置ConnectTimeout和ReadTimeout，Request.Options才会被覆盖：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if (config.getConnectTimeout() != null &amp;&amp; config.getReadTimeout() != null) {</span></div><div class="token-line"><span class="token plain">       builder.options(new Request.Options(config.getConnectTimeout(),</span></div><div class="token-line"><span class="token plain">             config.getReadTimeout()));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>更进一步，如果你希望针对单独的Feign Client设置超时时间，可以把default替换为Client的name：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">feign.client.config.default.readTimeout=3000</span></div><div class="token-line"><span class="token plain">    feign.client.config.default.connectTimeout=3000</span></div><div class="token-line"><span class="token plain">    feign.client.config.clientsdk.readTimeout=2000</span></div><div class="token-line"><span class="token plain">    feign.client.config.clientsdk.connectTimeout=2000</span></div></pre></div><p>可以得出<strong>结论三，单独的超时可以覆盖全局超时，这符合预期，不算坑</strong>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[15:45:51.708] [http-nio-45678-exec-3] [WARN ] [o.g.t.c.h.f.FeignAndRibbonController    :26  ] - 执行耗时：2006ms 错误：Read timed out executing POST http://clientsdk/feignandribbon/server</span></div></pre></div><p><strong>结论四，除了可以配置Feign，也可以配置Ribbon组件的参数来修改两个超时时间。这里的坑点三是，参数首字母要大写，和Feign的配置不同</strong>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ribbon.ReadTimeout=4000</span></div><div class="token-line"><span class="token plain">    ribbon.ConnectTimeout=4000</span></div></pre></div><p>可以通过日志证明参数生效：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[15:55:18.019] [http-nio-45678-exec-3] [WARN ] [o.g.t.c.h.f.FeignAndRibbonController    :26  ] - 执行耗时：4003ms 错误：Read timed out executing POST http://clientsdk/feignandribbon/server</span></div></pre></div><p>最后，我们来看看同时配置Feign和Ribbon的参数，最终谁会生效？如下代码的参数配置：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">clientsdk.ribbon.listOfServers=localhost:45678</span></div><div class="token-line"><span class="token plain">    feign.client.config.default.readTimeout=3000</span></div><div class="token-line"><span class="token plain">    feign.client.config.default.connectTimeout=3000</span></div><div class="token-line"><span class="token plain">    ribbon.ReadTimeout=4000</span></div><div class="token-line"><span class="token plain">    ribbon.ConnectTimeout=4000</span></div></pre></div><p>日志输出证明，最终生效的是Feign的超时：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[16:01:19.972] [http-nio-45678-exec-3] [WARN ] [o.g.t.c.h.f.FeignAndRibbonController    :26  ] - 执行耗时：3006ms 错误：Read timed out executing POST http://clientsdk/feignandribbon/server</span></div></pre></div><p><strong>结论五，同时配置Feign和Ribbon的超时，以Feign为准</strong>。这有点反直觉，因为Ribbon更底层所以你会觉得后者的配置会生效，但其实不是这样的。</p><p>在LoadBalancerFeignClient源码中可以看到，如果Request.Options不是默认值，就会创建一个FeignOptionsClientConfig代替原来Ribbon的DefaultClientConfigImpl，导致Ribbon的配置被Feign覆盖：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">IClientConfig getClientConfig(Request.Options options, String clientName) {</span></div><div class="token-line"><span class="token plain">       IClientConfig requestConfig;</span></div><div class="token-line"><span class="token plain">       if (options == DEFAULT_OPTIONS) {</span></div><div class="token-line"><span class="token plain">          requestConfig = this.clientFactory.getClientConfig(clientName);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       else {</span></div><div class="token-line"><span class="token plain">          requestConfig = new FeignOptionsClientConfig(options);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return requestConfig;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>但如果这么配置最终生效的还是Ribbon的超时（4秒），这容易让人产生Ribbon覆盖了Feign的错觉，其实这还是因为坑二所致，单独配置Feign的读取超时并不能生效：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">clientsdk.ribbon.listOfServers=localhost:45678</span></div><div class="token-line"><span class="token plain">    feign.client.config.default.readTimeout=3000</span></div><div class="token-line"><span class="token plain">    feign.client.config.clientsdk.readTimeout=2000</span></div><div class="token-line"><span class="token plain">    ribbon.ReadTimeout=4000</span></div></pre></div><h2 id="你是否知道ribbon会自动重试请求呢"><a aria-hidden="true" tabindex="-1" href="/blog-test/java业务开发常见错误100例/02.代码篇/05#你是否知道ribbon会自动重试请求呢"><span class="icon icon-link"></span></a>你是否知道Ribbon会自动重试请求呢？</h2><p>一些HTTP客户端往往会内置一些重试策略，其初衷是好的，毕竟因为网络问题导致丢包虽然频繁但持续时间短，往往重试下第二次就能成功，但一定要小心这种自作主张是否符合我们的预期。</p><p>之前遇到过一个短信重复发送的问题，但短信服务的调用方用户服务，反复确认代码里没有重试逻辑。那问题究竟出在哪里了？我们来重现一下这个案例。</p><p>首先，定义一个Get请求的发送短信接口，里面没有任何逻辑，休眠2秒模拟耗时：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RestController</span></div><div class="token-line"><span class="token plain">    @RequestMapping(&quot;ribbonretryissueserver&quot;)</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class RibbonRetryIssueServerController {</span></div><div class="token-line"><span class="token plain">        @GetMapping(&quot;sms&quot;)</span></div><div class="token-line"><span class="token plain">        public void sendSmsWrong(@RequestParam(&quot;mobile&quot;) String mobile, @RequestParam(&quot;message&quot;) String message, HttpServletRequest request) throws InterruptedException {</span></div><div class="token-line"><span class="token plain">            //输出调用参数后休眠2秒</span></div><div class="token-line"><span class="token plain">            log.info(&quot;{} is called, {}=&gt;{}&quot;, request.getRequestURL().toString(), mobile, message);</span></div><div class="token-line"><span class="token plain">            TimeUnit.SECONDS.sleep(2);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>配置一个Feign供客户端调用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@FeignClient(name = &quot;SmsClient&quot;)</span></div><div class="token-line"><span class="token plain">    public interface SmsClient {</span></div><div class="token-line"><span class="token plain">        @GetMapping(&quot;/ribbonretryissueserver/sms&quot;)</span></div><div class="token-line"><span class="token plain">        void sendSmsWrong(@RequestParam(&quot;mobile&quot;) String mobile, @RequestParam(&quot;message&quot;) String message);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>Feign内部有一个Ribbon组件负责客户端负载均衡，通过配置文件设置其调用的服务端为两个节点：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">SmsClient.ribbon.listOfServers=localhost:45679,localhost:45678</span></div></pre></div><p>写一个客户端接口，通过Feign调用服务端：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RestController</span></div><div class="token-line"><span class="token plain">    @RequestMapping(&quot;ribbonretryissueclient&quot;)</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class RibbonRetryIssueClientController {</span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private SmsClient smsClient;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @GetMapping(&quot;wrong&quot;)</span></div><div class="token-line"><span class="token plain">        public String wrong() {</span></div><div class="token-line"><span class="token plain">            log.info(&quot;client is called&quot;);</span></div><div class="token-line"><span class="token plain">            try{</span></div><div class="token-line"><span class="token plain">                //通过Feign调用发送短信接口</span></div><div class="token-line"><span class="token plain">                smsClient.sendSmsWrong(&quot;13600000000&quot;, UUID.randomUUID().toString());</span></div><div class="token-line"><span class="token plain">            } catch (Exception ex) {</span></div><div class="token-line"><span class="token plain">                //捕获可能出现的网络错误</span></div><div class="token-line"><span class="token plain">                log.error(&quot;send sms failed : {}&quot;, ex.getMessage());</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            return &quot;done&quot;;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在45678和45679两个端口上分别启动服务端，然后访问45678的客户端接口进行测试。因为客户端和服务端控制器在一个应用中，所以45678同时扮演了客户端和服务端的角色。</p><p>在45678日志中可以看到，29秒时客户端收到请求开始调用服务端接口发短信，同时服务端收到了请求，2秒后（注意对比第一条日志和第三条日志）客户端输出了读取超时的错误信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[12:49:29.020] [http-nio-45678-exec-4] [INFO ] [c.d.RibbonRetryIssueClientController:23  ] - client is called</span></div><div class="token-line"><span class="token plain">    [12:49:29.026] [http-nio-45678-exec-5] [INFO ] [c.d.RibbonRetryIssueServerController:16  ] - http://localhost:45678/ribbonretryissueserver/sms is called, 13600000000=&gt;a2aa1b32-a044-40e9-8950-7f0189582418</span></div><div class="token-line"><span class="token plain">    [12:49:31.029] [http-nio-45678-exec-4] [ERROR] [c.d.RibbonRetryIssueClientController:27  ] - send sms failed : Read timed out executing GET http://SmsClient/ribbonretryissueserver/sms?mobile=13600000000&amp;message=a2aa1b32-a044-40e9-8950-7f0189582418</span></div></pre></div><p>而在另一个服务端45679的日志中还可以看到一条请求，30秒时收到请求，也就是客户端接口调用后的1秒：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[12:49:30.029] [http-nio-45679-exec-2] [INFO ] [c.d.RibbonRetryIssueServerController:16  ] - http://localhost:45679/ribbonretryissueserver/sms is called, 13600000000=&gt;a2aa1b32-a044-40e9-8950-7f0189582418</span></div></pre></div><p>客户端接口被调用的日志只输出了一次，而服务端的日志输出了两次。虽然Feign的默认读取超时时间是1秒，但客户端2秒后才出现超时错误。<strong>显然，这说明客户端自作主张进行了一次重试，导致短信重复发送。</strong></p><p>翻看Ribbon的源码可以发现，MaxAutoRetriesNextServer参数默认为1，也就是Get请求在某个服务端节点出现问题（比如读取超时）时，Ribbon会自动重试一次：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// DefaultClientConfigImpl</span></div><div class="token-line"><span class="token plain">    public static final int DEFAULT_MAX_AUTO_RETRIES_NEXT_SERVER = 1;</span></div><div class="token-line"><span class="token plain">    public static final int DEFAULT_MAX_AUTO_RETRIES = 0;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // RibbonLoadBalancedRetryPolicy</span></div><div class="token-line"><span class="token plain">    public boolean canRetry(LoadBalancedRetryContext context) {</span></div><div class="token-line"><span class="token plain">       HttpMethod method = context.getRequest().getMethod();</span></div><div class="token-line"><span class="token plain">       return HttpMethod.GET == method || lbContext.isOkToRetryOnAllOperations();</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Override</span></div><div class="token-line"><span class="token plain">    public boolean canRetrySameServer(LoadBalancedRetryContext context) {</span></div><div class="token-line"><span class="token plain">       return sameServerCount &lt; lbContext.getRetryHandler().getMaxRetriesOnSameServer()</span></div><div class="token-line"><span class="token plain">             &amp;&amp; canRetry(context);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Override</span></div><div class="token-line"><span class="token plain">    public boolean canRetryNextServer(LoadBalancedRetryContext context) {</span></div><div class="token-line"><span class="token plain">       // this will be called after a failure occurs and we increment the counter</span></div><div class="token-line"><span class="token plain">       // so we check that the count is less than or equals to too make sure</span></div><div class="token-line"><span class="token plain">       // we try the next server the right number of times</span></div><div class="token-line"><span class="token plain">       return nextServerCount &lt;= lbContext.getRetryHandler().getMaxRetriesOnNextServer()</span></div><div class="token-line"><span class="token plain">             &amp;&amp; canRetry(context);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>解决办法有两个：</p><ul><li>一是，把发短信接口从Get改为Post。其实，这里还有一个API设计问题，有状态的API接口不应该定义为Get。根据HTTP协议的规范，Get请求用于数据查询，而Post才是把数据提交到服务端用于修改或新增。选择Get还是Post的依据，应该是API的行为，而不是参数大小。<strong>这里的一个误区是，Get请求的参数包含在Url QueryString中，会受浏览器长度限制，所以一些同学会选择使用JSON以Post提交大参数，使用Get提交小参数。</strong></li><li>二是，将MaxAutoRetriesNextServer参数配置为0，禁用服务调用失败后在下一个服务端节点的自动重试。在配置文件中添加一行即可：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ribbon.MaxAutoRetriesNextServer=0</span></div></pre></div><p>看到这里，你觉得问题出在用户服务还是短信服务呢？</p><p>在我看来，双方都有问题。就像之前说的，Get请求应该是无状态或者幂等的，短信接口可以设计为支持幂等调用的；而用户服务的开发同学，如果对Ribbon的重试机制有所了解的话，或许就能在排查问题上少走些弯路。</p><h2 id="并发限制了爬虫的抓取能力"><a aria-hidden="true" tabindex="-1" href="/blog-test/java业务开发常见错误100例/02.代码篇/05#并发限制了爬虫的抓取能力"><span class="icon icon-link"></span></a>并发限制了爬虫的抓取能力</h2><p>除了超时和重试的坑，进行HTTP请求调用还有一个常见的问题是，并发数的限制导致程序的处理能力上不去。</p><p>我之前遇到过一个爬虫项目，整体爬取数据的效率很低，增加线程池数量也无济于事，只能堆更多的机器做分布式的爬虫。现在，我们就来模拟下这个场景，看看问题出在了哪里。</p><p>假设要爬取的服务端是这样的一个简单实现，休眠1秒返回数字1：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;server&quot;)</span></div><div class="token-line"><span class="token plain">    public int server() throws InterruptedException {</span></div><div class="token-line"><span class="token plain">        TimeUnit.SECONDS.sleep(1);</span></div><div class="token-line"><span class="token plain">        return 1;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>爬虫需要多次调用这个接口进行数据抓取，为了确保线程池不是并发的瓶颈，我们使用一个没有线程上限的newCachedThreadPool作为爬取任务的线程池（再次强调，除非你非常清楚自己的需求，否则一般不要使用没有线程数量上限的线程池），然后使用HttpClient实现HTTP请求，把请求任务循环提交到线程池处理，最后等待所有任务执行完成后输出执行耗时：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private int sendRequest(int count, Supplier&lt;CloseableHttpClient&gt; client) throws InterruptedException {</span></div><div class="token-line"><span class="token plain">        //用于计数发送的请求个数</span></div><div class="token-line"><span class="token plain">        AtomicInteger atomicInteger = new AtomicInteger();</span></div><div class="token-line"><span class="token plain">        //使用HttpClient从server接口查询数据的任务提交到线程池并行处理</span></div><div class="token-line"><span class="token plain">        ExecutorService threadPool = Executors.newCachedThreadPool();</span></div><div class="token-line"><span class="token plain">        long begin = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">        IntStream.rangeClosed(1, count).forEach(i -&gt; {</span></div><div class="token-line"><span class="token plain">            threadPool.execute(() -&gt; {</span></div><div class="token-line"><span class="token plain">                try (CloseableHttpResponse response = client.get().execute(new HttpGet(&quot;http://127.0.0.1:45678/routelimit/server&quot;))) {</span></div><div class="token-line"><span class="token plain">                    atomicInteger.addAndGet(Integer.parseInt(EntityUtils.toString(response.getEntity())));</span></div><div class="token-line"><span class="token plain">                } catch (Exception ex) {</span></div><div class="token-line"><span class="token plain">                    ex.printStackTrace();</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            });</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">        //等到count个任务全部执行完毕</span></div><div class="token-line"><span class="token plain">        threadPool.shutdown();</span></div><div class="token-line"><span class="token plain">        threadPool.awaitTermination(1, TimeUnit.HOURS);</span></div><div class="token-line"><span class="token plain">        log.info(&quot;发送 {} 次请求，耗时 {} ms&quot;, atomicInteger.get(), System.currentTimeMillis() - begin);</span></div><div class="token-line"><span class="token plain">        return atomicInteger.get();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>首先，使用默认的PoolingHttpClientConnectionManager构造的CloseableHttpClient，测试一下爬取10次的耗时：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static CloseableHttpClient httpClient1;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static {</span></div><div class="token-line"><span class="token plain">        httpClient1 = HttpClients.custom().setConnectionManager(new PoolingHttpClientConnectionManager()).build();</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @GetMapping(&quot;wrong&quot;)</span></div><div class="token-line"><span class="token plain">    public int wrong(@RequestParam(value = &quot;count&quot;, defaultValue = &quot;10&quot;) int count) throws InterruptedException {</span></div><div class="token-line"><span class="token plain">        return sendRequest(count, () -&gt; httpClient1);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>虽然一个请求需要1秒执行完成，但我们的线程池是可以扩张使用任意数量线程的。按道理说，10个请求并发处理的时间基本相当于1个请求的处理时间，也就是1秒，但日志中显示实际耗时5秒：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[12:48:48.122] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.h.r.RouteLimitController        :54  ] - 发送 10 次请求，耗时 5265 ms</span></div></pre></div><p>查看PoolingHttpClientConnectionManager源码，可以注意到有两个重要参数：</p><ul><li><strong>defaultMaxPerRoute=2，也就是同一个主机/域名的最大并发请求数为2。我们的爬虫需要10个并发，显然是默认值太小限制了爬虫的效率。</strong></li><li>maxTotal=20，也就是所有主机整体最大并发为20，这也是HttpClient整体的并发度。目前，我们请求数是10最大并发是10，20不会成为瓶颈。举一个例子，使用同一个HttpClient访问10个域名，defaultMaxPerRoute设置为10，为确保每一个域名都能达到10并发，需要把maxTotal设置为100。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public PoolingHttpClientConnectionManager(</span></div><div class="token-line"><span class="token plain">        final HttpClientConnectionOperator httpClientConnectionOperator,</span></div><div class="token-line"><span class="token plain">        final HttpConnectionFactory&lt;HttpRoute, ManagedHttpClientConnection&gt; connFactory,</span></div><div class="token-line"><span class="token plain">        final long timeToLive, final TimeUnit timeUnit) {</span></div><div class="token-line"><span class="token plain">        ...    </span></div><div class="token-line"><span class="token plain">        this.pool = new CPool(new InternalConnectionFactory(</span></div><div class="token-line"><span class="token plain">                this.configData, connFactory), 2, 20, timeToLive, timeUnit);</span></div><div class="token-line"><span class="token plain">       ...</span></div><div class="token-line"><span class="token plain">    } </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public CPool(</span></div><div class="token-line"><span class="token plain">            final ConnFactory&lt;HttpRoute, ManagedHttpClientConnection&gt; connFactory,</span></div><div class="token-line"><span class="token plain">            final int defaultMaxPerRoute, final int maxTotal,</span></div><div class="token-line"><span class="token plain">            final long timeToLive, final TimeUnit timeUnit) {</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">    }}</span></div></pre></div><p>HttpClient是Java非常常用的HTTP客户端，这个问题经常出现。你可能会问，为什么默认值限制得这么小。</p><p>其实，这不能完全怪HttpClient，很多早期的浏览器也限制了同一个域名两个并发请求。对于同一个域名并发连接的限制，其实是HTTP 1.1协议要求的，<a target="_blank" rel="noopener noreferrer" href="http://w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1.4">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>有这么一段话：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Clients that use persistent connections SHOULD limit the number of simultaneous connections that they maintain to a given server. A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy. A proxy SHOULD use up to 2*N connections to another server or proxy, where N is the number of simultaneously active users. These guidelines are intended to improve HTTP response times and avoid congestion.</span></div></pre></div><p>HTTP 1.1协议是20年前制定的，现在HTTP服务器的能力强很多了，所以有些新的浏览器没有完全遵从2并发这个限制，放开并发数到了8甚至更大。如果需要通过HTTP客户端发起大量并发请求，不管使用什么客户端，请务必确认客户端的实现默认的并发度是否满足需求。</p><p>既然知道了问题所在，我们就尝试声明一个新的HttpClient放开相关限制，设置maxPerRoute为50、maxTotal为100，然后修改一下刚才的wrong方法，使用新的客户端进行测试：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">httpClient2 = HttpClients.custom().setMaxConnPerRoute(10).setMaxConnTotal(20).build();</span></div></pre></div><p>输出如下，10次请求在1秒左右执行完成。可以看到，因为放开了一个Host 2个并发的默认限制，爬虫效率得到了大幅提升：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[12:58:11.333] [http-nio-45678-exec-3] [INFO ] [o.g.t.c.h.r.RouteLimitController        :54  ] - 发送 10 次请求，耗时 1023 ms</span></div></pre></div><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-test/java业务开发常见错误100例/02.代码篇/05#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>今天，我和你分享了HTTP调用最常遇到的超时、重试和并发问题。</p><p>连接超时代表建立TCP连接的时间，读取超时代表了等待远端返回数据的时间，也包括远端程序处理的时间。在解决连接超时问题时，我们要搞清楚连的是谁；在遇到读取超时问题的时候，我们要综合考虑下游服务的服务标准和自己的服务标准，设置合适的读取超时时间。此外，在使用诸如Spring Cloud Feign等框架时务必确认，连接和读取超时参数的配置是否正确生效。</p><p>对于重试，因为HTTP协议认为Get请求是数据查询操作，是无状态的，又考虑到网络出现丢包是比较常见的事情，有些HTTP客户端或代理服务器会自动重试Get/Head请求。如果你的接口设计不支持幂等，需要关闭自动重试。但，更好的解决方案是，<a target="_blank" rel="noopener noreferrer" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">遵从HTTP协议<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的建议来使用合适的HTTP方法。</p><p>最后我们看到，包括HttpClient在内的HTTP客户端以及浏览器，都会限制客户端调用的最大并发数。如果你的客户端有比较大的请求调用并发，比如做爬虫，或是扮演类似代理的角色，又或者是程序本身并发较高，如此小的默认值很容易成为吞吐量的瓶颈，需要及时调整。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a target="_blank" rel="noopener noreferrer" href="https://github.com/JosephZhu1983/java-common-mistakes">这个链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>查看。</p><h2 id="思考与讨论"><a aria-hidden="true" tabindex="-1" href="/blog-test/java业务开发常见错误100例/02.代码篇/05#思考与讨论"><span class="icon icon-link"></span></a>思考与讨论</h2><ol><li>第一节中我们强调了要注意连接超时和读取超时参数的配置，大多数的HTTP客户端也都有这两个参数。有读就有写，但为什么我们很少看到“写入超时”的概念呢？</li><li>除了Ribbon的AutoRetriesNextServer重试机制，Nginx也有类似的重试功能。你了解Nginx相关的配置吗？</li></ol><p>针对HTTP调用，你还遇到过什么坑吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/java业务开发常见错误100例/02.代码篇/05.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 09:43:57</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-test/umi.3ded5539.js"></script>
  </body>
</html>
