<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-java/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-java";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>
      34 | 加餐4：分析定位Java问题，一定要用好这些工具（一） - 大师兄
    </title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/java业务开发常见错误100例/05.加餐/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java业务开发常见错误100例/01.开篇词">01.开篇词</a><ul><li><a href="/blog-java/java业务开发常见错误100例/01.开篇词/01"><span>开篇词 | 业务代码真的会有这么多坑？</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇">02.代码篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/01"><span>01 | 使用了并发工具类库，线程安全就高枕无忧了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/02"><span>02 | 代码加锁：不要让“锁”事成为烦心事</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/03"><span>03 | 线程池：业务代码最常用也最容易犯错的组件</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/04"><span>04 | 连接池：别让连接池帮了倒忙</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/05"><span>05 | HTTP调用：你考虑到超时、重试、并发了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/06"><span>06 | 20%的业务代码的Spring声明式事务，可能都没处理正确</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/07"><span>答疑篇：代码篇思考题集锦（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/08"><span>07 | 数据库索引：索引并不是万能药</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/09"><span>08 | 判等问题：程序里如何确定你就是你？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/10"><span>09 | 数值计算：注意精度、舍入和溢出问题</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/11"><span>10 | 集合类：坑满地的List列表操作</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/12"><span>11 | 空值处理：分不清楚的null和恼人的空指针</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/13"><span>12 | 异常处理：别让自己在出问题的时候变为瞎子</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/14"><span>答疑篇：代码篇思考题集锦（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/15"><span>13 | 日志：日志记录真没你想象的那么简单</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/16"><span>14 | 文件IO：实现高效正确的文件读写并非易事</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/17"><span>15 | 序列化：一来一回你还是原来的你吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/18"><span>16 | 用好Java 8的日期时间类，少踩一些“老三样”的坑</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/19"><span>17 | 别以为“自动挡”就不可能出现OOM</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/20"><span>18 | 当反射、注解和泛型遇到OOP时，会有哪些坑？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/21"><span>19 | Spring框架：IoC和AOP是扩展的核心</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/22"><span>20 | Spring框架：框架帮我们做了很多工作也带来了复杂度</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/23"><span>答疑篇：代码篇思考题集锦（三）</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇">03.设计篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/01"><span>21 |  代码重复：搞定代码重复的三个绝招</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/02"><span>22 | 接口设计：系统间对话的语言，一定要统一</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/03"><span>23 | 缓存设计：缓存可以锦上添花也可以落井下石</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/04"><span>24 | 业务代码写完，就意味着生产就绪了？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/05"><span>25 | 异步处理好用，但非常容易用错</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/06"><span>26 | 数据存储：NoSQL与RDBMS如何取长补短、相辅相成？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/07"><span>答疑篇：设计篇思考题答案合集</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇">04.安全篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/01"><span>27 | 数据源头：任何客户端的东西都不可信任</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/02"><span>28 | 安全兜底：涉及钱时，必须考虑防刷、限量和防重</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/03"><span>29 | 数据和代码：数据就是数据，代码就是代码</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/04"><span>30 | 如何正确保存和传输敏感数据？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/05"><span>答疑篇：安全篇思考题答案合集</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例/05.加餐">05.加餐</a><ul><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/01"><span>31 | 加餐1：带你吃透课程中Java 8的那些重要知识点（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/02"><span>32 | 加餐2：带你吃透课程中Java 8的那些重要知识点（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/03"><span>33 | 加餐3：定位应用问题，排错套路很重要</span></a></li><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例/05.加餐/04"><span>34 | 加餐4：分析定位Java问题，一定要用好这些工具（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/05"><span>35 | 加餐5：分析定位Java问题，一定要用好这些工具（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/06"><span>36 | 加餐6：这15年来，我是如何在工作中学习技术和英语的？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/07"><span>答疑篇：加餐篇思考题答案合集</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/08"><span>37 | 加餐7：程序员成长28计</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/09"><span>38 | 加餐8：Java程序从虚拟机迁移到Kubernetes的一些坑</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语">06.结束语</a><ul><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/01"><span>结束语 | 写代码时，如何才能尽量避免踩坑？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/02"><span>结课测试 | 关于Java业务开发的100个常见错误，你都明白其中缘由了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/03"><span>结课问卷获奖用户名单</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/summary">java业务开发常见错误100例</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="使用JDK自带工具查看JVM情况" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/05.加餐/04#使用jdk自带工具查看jvm情况"><span>使用JDK自带工具查看JVM情况</span></a></li><li title="jps" data-depth="3"><a href="/blog-java/java业务开发常见错误100例/05.加餐/04#jps"><span>jps</span></a></li><li title="jinfo" data-depth="3"><a href="/blog-java/java业务开发常见错误100例/05.加餐/04#jinfo"><span>jinfo</span></a></li><li title="jvisualvm" data-depth="3"><a href="/blog-java/java业务开发常见错误100例/05.加餐/04#jvisualvm"><span>jvisualvm</span></a></li><li title="jconsole" data-depth="3"><a href="/blog-java/java业务开发常见错误100例/05.加餐/04#jconsole"><span>jconsole</span></a></li><li title="jstat" data-depth="3"><a href="/blog-java/java业务开发常见错误100例/05.加餐/04#jstat"><span>jstat</span></a></li><li title="jstack" data-depth="3"><a href="/blog-java/java业务开发常见错误100例/05.加餐/04#jstack"><span>jstack</span></a></li><li title="jcmd" data-depth="3"><a href="/blog-java/java业务开发常见错误100例/05.加餐/04#jcmd"><span>jcmd</span></a></li><li title="使用Wireshark分析SQL批量插入慢的问题" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/05.加餐/04#使用wireshark分析sql批量插入慢的问题"><span>使用Wireshark分析SQL批量插入慢的问题</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/05.加餐/04#重点回顾"><span>重点回顾</span></a></li><li title="思考与讨论" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/05.加餐/04#思考与讨论"><span>思考与讨论</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="34--加餐4分析定位java问题一定要用好这些工具一"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/05.加餐/04#34--加餐4分析定位java问题一定要用好这些工具一"><span class="icon icon-link"></span></a>34 | 加餐4：分析定位Java问题，一定要用好这些工具（一）</h1><p>你好，我是朱晔。今天，我要和你分享的内容是分析定位Java问题常用的一些工具。</p><p>到这里，我们的课程更新17讲了，已经更新过半了。在学习过程中，你会发现我在介绍各种坑的时候，并不是直接给出问题的结论，而是通过工具来亲眼看到问题。</p><p>为什么这么做呢？因为我始终认为，遇到问题尽量不要去猜，一定要眼见为实。只有通过日志、监控或工具真正看到问题，然后再回到代码中进行比对确认，我们才能认为是找到了根本原因。</p><p>你可能一开始会比较畏惧使用复杂的工具去排查问题，又或者是打开了工具感觉无从下手，但是随着实践越来越多，对Java程序和各种框架的运作越来越熟悉，你会发现使用这些工具越来越顺手。</p><p>其实呢，工具只是我们定位问题的手段，要用好工具主要还是得对程序本身的运作有大概的认识，这需要长期的积累。</p><p>因此，我会通过两篇加餐，和你分享4个案例，分别展示使用JDK自带的工具来排查JVM参数配置问题、使用Wireshark来分析网络问题、通过MAT来分析内存问题，以及使用Arthas来分析CPU使用高的问题。这些案例也只是冰山一角，你可以自己再通过些例子进一步学习和探索。</p><p>在今天这篇加餐中，我们就先学习下如何使用JDK自带工具、Wireshark来分析和定位Java程序的问题吧。</p><h2 id="使用jdk自带工具查看jvm情况"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/05.加餐/04#使用jdk自带工具查看jvm情况"><span class="icon icon-link"></span></a>使用JDK自带工具查看JVM情况</h2><p>JDK自带了很多命令行甚至是图形界面工具，帮助我们查看JVM的一些信息。比如，在我的机器上运行ls命令，可以看到JDK 8提供了非常多的工具或程序：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage22bd22456d9186a4f36f83209168b782dbbd.007963b2.png" alt=""/></p><p>接下来，我会与你介绍些常用的监控工具。你也可以先通过下面这张图了解下各种工具的基本作用：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimageb40db4e8ab0a76a8665879e0fc13964ebc0d.4a4a82e0.jpg" alt=""/></p><p>为了测试这些工具，我们先来写一段代码：启动10个死循环的线程，每个线程分配一个10MB左右的字符串，然后休眠10秒。可以想象到，这个程序会对GC造成压力。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//启动10个线程</span></div><div class="token-line"><span class="token plain">    IntStream.rangeClosed(1, 10).mapToObj(i -&gt; new Thread(() -&gt; {</span></div><div class="token-line"><span class="token plain">        while (true) {</span></div><div class="token-line"><span class="token plain">            //每一个线程都是一个死循环，休眠10秒，打印10M数据</span></div><div class="token-line"><span class="token plain">            String payload = IntStream.rangeClosed(1, 10000000)</span></div><div class="token-line"><span class="token plain">                    .mapToObj(__ -&gt; &quot;a&quot;)</span></div><div class="token-line"><span class="token plain">                    .collect(Collectors.joining(&quot;&quot;)) + UUID.randomUUID().toString();</span></div><div class="token-line"><span class="token plain">            try {</span></div><div class="token-line"><span class="token plain">                TimeUnit.SECONDS.sleep(10);</span></div><div class="token-line"><span class="token plain">            } catch (InterruptedException e) {</span></div><div class="token-line"><span class="token plain">                e.printStackTrace();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            System.out.println(payload.length());</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    })).forEach(Thread::start);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    TimeUnit.HOURS.sleep(1);</span></div></pre></div><p>修改pom.xml，配置spring-boot-maven-plugin插件打包的Java程序的main方法类：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;plugin&gt;</span></div><div class="token-line"><span class="token plain">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></div><div class="token-line"><span class="token plain">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span></div><div class="token-line"><span class="token plain">        &lt;configuration&gt;</span></div><div class="token-line"><span class="token plain">            &lt;mainClass&gt;org.geekbang.time.commonmistakes.troubleshootingtools.jdktool.CommonMistakesApplication</span></div><div class="token-line"><span class="token plain">            &lt;/mainClass&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/configuration&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/plugin&gt;</span></div></pre></div><p>然后使用java -jar启动进程，设置JVM参数，让堆最小最大都是1GB：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">java -jar common-mistakes-0.0.1-SNAPSHOT.jar -Xms1g -Xmx1g</span></div></pre></div><p>完成这些准备工作后，我们就可以使用JDK提供的工具，来观察分析这个测试程序了。</p><h3 id="jps"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/05.加餐/04#jps"><span class="icon icon-link"></span></a>jps</h3><p>首先，使用jps得到Java进程列表，这会比使用ps来的方便：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">➜  ~ jps</span></div><div class="token-line"><span class="token plain">    12707</span></div><div class="token-line"><span class="token plain">    22261 Launcher</span></div><div class="token-line"><span class="token plain">    23864 common-mistakes-0.0.1-SNAPSHOT.jar</span></div><div class="token-line"><span class="token plain">    15608 RemoteMavenServer36</span></div><div class="token-line"><span class="token plain">    23243 Main</span></div><div class="token-line"><span class="token plain">    23868 Jps</span></div><div class="token-line"><span class="token plain">    22893 KotlinCompileDaemon</span></div></pre></div><h3 id="jinfo"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/05.加餐/04#jinfo"><span class="icon icon-link"></span></a>jinfo</h3><p>然后，可以使用jinfo打印JVM的各种参数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">➜  ~ jinfo 23864</span></div><div class="token-line"><span class="token plain">    Java System Properties:</span></div><div class="token-line"><span class="token plain">    #Wed Jan 29 12:49:47 CST 2020</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    user.name=zhuye</span></div><div class="token-line"><span class="token plain">    path.separator=\:</span></div><div class="token-line"><span class="token plain">    os.version=10.15.2</span></div><div class="token-line"><span class="token plain">    java.runtime.name=Java(TM) SE Runtime Environment</span></div><div class="token-line"><span class="token plain">    file.encoding=UTF-8</span></div><div class="token-line"><span class="token plain">    java.vm.name=Java HotSpot(TM) 64-Bit Server VM</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    VM Flags:</span></div><div class="token-line"><span class="token plain">    -XX:CICompilerCount=4 -XX:ConcGCThreads=2 -XX:G1ConcRefinementThreads=8 -XX:G1HeapRegionSize=1048576 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=268435456 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=4294967296 -XX:MaxNewSize=2576351232 -XX:MinHeapDeltaBytes=1048576 -XX:NonNMethodCodeHeapSize=5835340 -XX:NonProfiledCodeHeapSize=122911450 -XX:ProfiledCodeHeapSize=122911450 -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    VM Arguments:</span></div><div class="token-line"><span class="token plain">    java_command: common-mistakes-0.0.1-SNAPSHOT.jar -Xms1g -Xmx1g</span></div><div class="token-line"><span class="token plain">    java_class_path (initial): common-mistakes-0.0.1-SNAPSHOT.jar</span></div><div class="token-line"><span class="token plain">    Launcher Type: SUN_STANDARD</span></div></pre></div><p>查看第15行和19行可以发现，<strong>我们设置JVM参数的方式不对，-Xms1g和-Xmx1g这两个参数被当成了Java程序的启动参数</strong>，整个JVM目前最大内存是4GB左右，而不是1GB。</p><p>因此，当我们怀疑JVM的配置很不正常的时候，要第一时间使用工具来确认参数。除了使用工具确认JVM参数外，你也可以打印VM参数和程序参数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">System.out.println(&quot;VM options&quot;);</span></div><div class="token-line"><span class="token plain">    System.out.println(ManagementFactory.getRuntimeMXBean().getInputArguments().stream().collect(Collectors.joining(System.lineSeparator())));</span></div><div class="token-line"><span class="token plain">    System.out.println(&quot;Program arguments&quot;);</span></div><div class="token-line"><span class="token plain">    System.out.println(Arrays.stream(args).collect(Collectors.joining(System.lineSeparator())));</span></div></pre></div><p>把JVM参数放到-jar之前，重新启动程序，可以看到如下输出，从输出也可以确认这次JVM参数的配置正确了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">➜  target git:(master) ✗ java -Xms1g -Xmx1g -jar common-mistakes-0.0.1-SNAPSHOT.jar test</span></div><div class="token-line"><span class="token plain">    VM options</span></div><div class="token-line"><span class="token plain">    -Xms1g</span></div><div class="token-line"><span class="token plain">    -Xmx1g</span></div><div class="token-line"><span class="token plain">    Program arguments</span></div><div class="token-line"><span class="token plain">    test</span></div></pre></div><h3 id="jvisualvm"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/05.加餐/04#jvisualvm"><span class="icon icon-link"></span></a>jvisualvm</h3><p>然后，启动另一个重量级工具jvisualvm观察一下程序，可以在概述面板再次确认JVM参数设置成功了：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage4de44d8a600072b0b1aea3943dee584c72e4.b0ccfdde.png" alt=""/></p><p>继续观察监视面板可以看到，JVM的GC活动基本是10秒发生一次，堆内存在250MB到900MB之间波动，活动线程数是22。我们可以在监视面板看到JVM的基本情况，也可以直接在这里进行手动GC和堆Dump操作：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage5b025be531e51f6e49d5511d419c90b29302.8c096986.png" alt=""/></p><h3 id="jconsole"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/05.加餐/04#jconsole"><span class="icon icon-link"></span></a>jconsole</h3><p>如果希望看到各个内存区的GC曲线图，可以使用jconsole观察。jconsole也是一个综合性图形界面监控工具，比jvisualvm更方便的一点是，可以用曲线的形式监控各种数据，包括MBean中的属性值：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage6b126b4c08d384eea532842d386638dddb12.994aeb5a.png" alt=""/></p><h3 id="jstat"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/05.加餐/04#jstat"><span class="icon icon-link"></span></a>jstat</h3><p>同样，如果没有条件使用图形界面（毕竟在Linux服务器上，我们主要使用命令行工具），又希望看到GC趋势的话，我们可以使用jstat工具。</p><p>jstat工具允许以固定的监控频次输出JVM的各种监控指标，比如使用-gcutil输出GC和内存占用汇总信息，每隔5秒输出一次，输出100次，可以看到Young GC比较频繁，而Full GC基本10秒一次：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">➜  ~ jstat -gcutil 23940 5000 100</span></div><div class="token-line"><span class="token plain">      S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT</span></div><div class="token-line"><span class="token plain">      0.00 100.00   0.36  87.63  94.30  81.06    539   14.021    33    3.972   837    0.976   18.968</span></div><div class="token-line"><span class="token plain">      0.00 100.00   0.60  69.51  94.30  81.06    540   14.029    33    3.972   839    0.978   18.979</span></div><div class="token-line"><span class="token plain">      0.00   0.00   0.50  99.81  94.27  81.03    548   14.143    34    4.002   840    0.981   19.126</span></div><div class="token-line"><span class="token plain">      0.00 100.00   0.59  70.47  94.27  81.03    549   14.177    34    4.002   844    0.985   19.164</span></div><div class="token-line"><span class="token plain">      0.00 100.00   0.57  99.85  94.32  81.09    550   14.204    34    4.002   845    0.990   19.196</span></div><div class="token-line"><span class="token plain">      0.00 100.00   0.65  77.69  94.32  81.09    559   14.469    36    4.198   847    0.993   19.659</span></div><div class="token-line"><span class="token plain">      0.00 100.00   0.65  77.69  94.32  81.09    559   14.469    36    4.198   847    0.993   19.659</span></div><div class="token-line"><span class="token plain">      0.00 100.00   0.70  35.54  94.32  81.09    567   14.763    37    4.378   853    1.001   20.142</span></div><div class="token-line"><span class="token plain">      0.00 100.00   0.70  41.22  94.32  81.09    567   14.763    37    4.378   853    1.001   20.142</span></div><div class="token-line"><span class="token plain">      0.00 100.00   1.89  96.76  94.32  81.09    574   14.943    38    4.487   859    1.007   20.438</span></div><div class="token-line"><span class="token plain">      0.00 100.00   1.39  39.20  94.32  81.09    575   14.946    38    4.487   861    1.010   20.442</span></div></pre></div><blockquote><p>其中，S0表示Survivor0区占用百分比，S1表示Survivor1区占用百分比，E表示Eden区占用百分比，O表示老年代占用百分比，M表示元数据区占用百分比，YGC表示年轻代回收次数，YGCT表示年轻代回收耗时，FGC表示老年代回收次数，FGCT表示老年代回收耗时。</p></blockquote><p>jstat命令的参数众多，包含-class、-compiler、-gc等。Java 8、Linux/Unix平台jstat工具的完整介绍，你可以查看<a target="_blank" rel="noopener noreferrer" href="https://docs.oracle.com/javase/8/docs/technotes/tools/#monitor">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。jstat定时输出的特性，可以方便我们持续观察程序的各项指标。</p><p>继续来到线程面板可以看到，大量以Thread开头的线程基本都是有节奏的10秒运行一下，其他时间都在休眠，和我们的代码逻辑匹配：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage7a857a1616295b4ec51c56437d2a92652185.6ac72acd.png" alt=""/></p><p>点击面板的线程Dump按钮，可以查看线程瞬时的线程栈：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage0d000ddcd3348d1c8b0bba16736f9221a900.d6c11e03.png" alt=""/></p><h3 id="jstack"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/05.加餐/04#jstack"><span class="icon icon-link"></span></a>jstack</h3><p>通过命令行工具jstack，也可以实现抓取线程栈的操作：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">➜  ~ jstack 23940</span></div><div class="token-line"><span class="token plain">    2020-01-29 13:08:15</span></div><div class="token-line"><span class="token plain">    Full thread dump Java HotSpot(TM) 64-Bit Server VM (11.0.3+12-LTS mixed mode):</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &quot;main&quot; #1 prio=5 os_prio=31 cpu=440.66ms elapsed=574.86s tid=0x00007ffdd9800000 nid=0x2803 waiting on condition  [0x0000700003849000]</span></div><div class="token-line"><span class="token plain">       java.lang.Thread.State: TIMED_WAITING (sleeping)</span></div><div class="token-line"><span class="token plain">    	at java.lang.Thread.sleep(java.base@11.0.3/Native Method)</span></div><div class="token-line"><span class="token plain">    	at java.lang.Thread.sleep(java.base@11.0.3/Thread.java:339)</span></div><div class="token-line"><span class="token plain">    	at java.util.concurrent.TimeUnit.sleep(java.base@11.0.3/TimeUnit.java:446)</span></div><div class="token-line"><span class="token plain">    	at org.geekbang.time.commonmistakes.troubleshootingtools.jdktool.CommonMistakesApplication.main(CommonMistakesApplication.java:41)</span></div><div class="token-line"><span class="token plain">    	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(java.base@11.0.3/Native Method)</span></div><div class="token-line"><span class="token plain">    	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(java.base@11.0.3/NativeMethodAccessorImpl.java:62)</span></div><div class="token-line"><span class="token plain">    	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(java.base@11.0.3/DelegatingMethodAccessorImpl.java:43)</span></div><div class="token-line"><span class="token plain">    	at java.lang.reflect.Method.invoke(java.base@11.0.3/Method.java:566)</span></div><div class="token-line"><span class="token plain">    	at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48)</span></div><div class="token-line"><span class="token plain">    	at org.springframework.boot.loader.Launcher.launch(Launcher.java:87)</span></div><div class="token-line"><span class="token plain">    	at org.springframework.boot.loader.Launcher.launch(Launcher.java:51)</span></div><div class="token-line"><span class="token plain">    	at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:52)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &quot;Thread-1&quot; #13 prio=5 os_prio=31 cpu=17851.77ms elapsed=574.41s tid=0x00007ffdda029000 nid=0x9803 waiting on condition  [0x000070000539d000]</span></div><div class="token-line"><span class="token plain">       java.lang.Thread.State: TIMED_WAITING (sleeping)</span></div><div class="token-line"><span class="token plain">    	at java.lang.Thread.sleep(java.base@11.0.3/Native Method)</span></div><div class="token-line"><span class="token plain">    	at java.lang.Thread.sleep(java.base@11.0.3/Thread.java:339)</span></div><div class="token-line"><span class="token plain">    	at java.util.concurrent.TimeUnit.sleep(java.base@11.0.3/TimeUnit.java:446)</span></div><div class="token-line"><span class="token plain">    	at org.geekbang.time.commonmistakes.troubleshootingtools.jdktool.CommonMistakesApplication.lambda$null$1(CommonMistakesApplication.java:33)</span></div><div class="token-line"><span class="token plain">    	at org.geekbang.time.commonmistakes.troubleshootingtools.jdktool.CommonMistakesApplication$$Lambda$41/0x00000008000a8c40.run(Unknown Source)</span></div><div class="token-line"><span class="token plain">    	at java.lang.Thread.run(java.base@11.0.3/Thread.java:834)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>抓取后可以使用类似<a target="_blank" rel="noopener noreferrer" href="https://fastthread.io/">fastthread<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>这样的在线分析工具来分析线程栈。</p><h3 id="jcmd"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/05.加餐/04#jcmd"><span class="icon icon-link"></span></a>jcmd</h3><p>最后，我们来看一下Java HotSpot虚拟机的NMT功能。</p><p>通过NMT，我们可以观察细粒度内存使用情况，设置-XX:NativeMemoryTracking=summary/detail可以开启NMT功能，开启后可以使用jcmd工具查看NMT数据。</p><p>我们重新启动一次程序，这次加上JVM参数以detail方式开启NMT：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">-Xms1g -Xmx1g -XX:ThreadStackSize=256k -XX:NativeMemoryTracking=detail</span></div></pre></div><p>在这里，我们还增加了-XX:ThreadStackSize参数，并将其值设置为256k，也就是期望把线程栈设置为256KB。我们通过NMT观察一下设置是否成功。</p><p>启动程序后执行如下jcmd命令，以概要形式输出NMT结果。可以看到，<strong>当前有32个线程，线程栈总共保留了差不多4GB左右的内存</strong>。我们明明配置线程栈最大256KB啊，为什么会出现4GB这么夸张的数字呢，到底哪里出了问题呢？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">➜  ~ jcmd 24404 VM.native_memory summary</span></div><div class="token-line"><span class="token plain">    24404:</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Native Memory Tracking:</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Total: reserved=6635310KB, committed=5337110KB</span></div><div class="token-line"><span class="token plain">    -                 Java Heap (reserved=1048576KB, committed=1048576KB)</span></div><div class="token-line"><span class="token plain">                                (mmap: reserved=1048576KB, committed=1048576KB)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    -                     Class (reserved=1066233KB, committed=15097KB)</span></div><div class="token-line"><span class="token plain">                                (classes #902)</span></div><div class="token-line"><span class="token plain">                                (malloc=9465KB #908)</span></div><div class="token-line"><span class="token plain">                                (mmap: reserved=1056768KB, committed=5632KB)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    -                    Thread (reserved=4209797KB, committed=4209797KB)</span></div><div class="token-line"><span class="token plain">                                (thread #32)</span></div><div class="token-line"><span class="token plain">                                (stack: reserved=4209664KB, committed=4209664KB)</span></div><div class="token-line"><span class="token plain">                                (malloc=96KB #165)</span></div><div class="token-line"><span class="token plain">                                (arena=37KB #59)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    -                      Code (reserved=249823KB, committed=2759KB)</span></div><div class="token-line"><span class="token plain">                                (malloc=223KB #730)</span></div><div class="token-line"><span class="token plain">                                (mmap: reserved=249600KB, committed=2536KB)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    -                        GC (reserved=48700KB, committed=48700KB)</span></div><div class="token-line"><span class="token plain">                                (malloc=10384KB #135)</span></div><div class="token-line"><span class="token plain">                                (mmap: reserved=38316KB, committed=38316KB)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    -                  Compiler (reserved=186KB, committed=186KB)</span></div><div class="token-line"><span class="token plain">                                (malloc=56KB #105)</span></div><div class="token-line"><span class="token plain">                                (arena=131KB #7)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    -                  Internal (reserved=9693KB, committed=9693KB)</span></div><div class="token-line"><span class="token plain">                                (malloc=9661KB #2585)</span></div><div class="token-line"><span class="token plain">                                (mmap: reserved=32KB, committed=32KB)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    -                    Symbol (reserved=2021KB, committed=2021KB)</span></div><div class="token-line"><span class="token plain">                                (malloc=1182KB #334)</span></div><div class="token-line"><span class="token plain">                                (arena=839KB #1)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    -    Native Memory Tracking (reserved=85KB, committed=85KB)</span></div><div class="token-line"><span class="token plain">                                (malloc=5KB #53)</span></div><div class="token-line"><span class="token plain">                                (tracking overhead=80KB)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    -               Arena Chunk (reserved=196KB, committed=196KB)</span></div><div class="token-line"><span class="token plain">                                (malloc=196KB)</span></div></pre></div><p>重新以VM.native_memory detail参数运行jcmd：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">jcmd 24404 VM.native_memory detail</span></div></pre></div><p>可以看到，<strong>有16个可疑线程，每一个线程保留了262144KB内存，也就是256MB</strong>（通过下图红框可以看到，使用关键字262144KB for Thread Stack from搜索到了16个结果）：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimagef26bf24869cbd1190c508e085c9f3400d06b.88d53a63.png" alt=""/></p><p>其实，ThreadStackSize参数的单位是KB，<strong>所以我们如果要设置线程栈256KB，那么应该设置256而不是256k</strong>。重新设置正确的参数后，使用jcmd再次验证下：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimaged7c9d7228ec216003d31064698e7e16c81c9.d9eaa2cf.png" alt=""/></p><p>除了用于查看NMT外，jcmd还有许多功能。我们可以通过help，看到它的所有功能：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">jcmd 24781 help</span></div></pre></div><p>对于其中每一种功能，我们都可以进一步使用help来查看介绍。比如，使用GC.heap_info命令可以打印Java堆的一些信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">jcmd 24781 help GC.heap_info</span></div></pre></div><p>除了jps、jinfo、jcmd、jstack、jstat、jconsole、jvisualvm外，JDK中还有一些工具，你可以通过<a target="_blank" rel="noopener noreferrer" href="https://docs.oracle.com/javase/8/docs/technotes/tools/">官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>查看完整介绍。</p><h2 id="使用wireshark分析sql批量插入慢的问题"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/05.加餐/04#使用wireshark分析sql批量插入慢的问题"><span class="icon icon-link"></span></a>使用Wireshark分析SQL批量插入慢的问题</h2><p>我之前遇到过这样一个案例：有一个数据导入程序需要导入大量的数据，开发同学就想到了使用Spring JdbcTemplate的批量操作功能进行数据批量导入，但是发现性能非常差，和普通的单条SQL执行性能差不多。</p><p>我们重现下这个案例。启动程序后，首先创建一个testuser表，其中只有一列name，然后使用JdbcTemplate的batchUpdate方法，批量插入10000条记录到testuser表：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@SpringBootApplication</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class BatchInsertAppliation implements CommandLineRunner {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private JdbcTemplate jdbcTemplate;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">            SpringApplication.run(BatchInsertApplication.class, args);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @PostConstruct</span></div><div class="token-line"><span class="token plain">        public void init() {</span></div><div class="token-line"><span class="token plain">            //初始化表</span></div><div class="token-line"><span class="token plain">            jdbcTemplate.execute(&quot;drop table IF EXISTS `testuser`;&quot;);</span></div><div class="token-line"><span class="token plain">            jdbcTemplate.execute(&quot;create TABLE `testuser` (\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;  `name` varchar(255) NOT NULL,\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;  PRIMARY KEY (`id`)\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void run(String... args) {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            long begin = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">            String sql = &quot;INSERT INTO `testuser` (`name`) VALUES (?)&quot;;</span></div><div class="token-line"><span class="token plain">            //使用JDBC批量更新</span></div><div class="token-line"><span class="token plain">            jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {</span></div><div class="token-line"><span class="token plain">                @Override</span></div><div class="token-line"><span class="token plain">                public void setValues(PreparedStatement preparedStatement, int i) throws SQLException {</span></div><div class="token-line"><span class="token plain">                    //第一个参数(索引从1开始)，也就是name列赋值</span></div><div class="token-line"><span class="token plain">                    preparedStatement.setString(1, &quot;usera&quot; + i);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                @Override</span></div><div class="token-line"><span class="token plain">                public int getBatchSize() {</span></div><div class="token-line"><span class="token plain">                    //批次大小为10000</span></div><div class="token-line"><span class="token plain">                    return 10000;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            });</span></div><div class="token-line"><span class="token plain">            log.info(&quot;took : {} ms&quot;, System.currentTimeMillis() - begin);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>执行程序后可以看到，1万条数据插入耗时26秒：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[14:44:19.094] [main] [INFO ] [o.g.t.c.t.network.BatchInsertApplication:52  ] - took : 26144 ms</span></div></pre></div><p>其实，对于批量操作，我们希望程序可以把多条insert SQL语句合并成一条，或至少是一次性提交多条语句到数据库，以减少和MySQL交互次数、提高性能。那么，我们的程序是这样运作的吗？</p><p>我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/221982">加餐3<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中提到一条原则，“分析问题一定是需要依据的，靠猜是猜不出来的”。现在，我们就使用网络分析工具Wireshark来分析一下这个案例，眼见为实。</p><p>首先，我们可以在<a target="_blank" rel="noopener noreferrer" href="https://www.wireshark.org/download.html">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>下载Wireshark，启动后选择某个需要捕获的网卡。由于我们连接的是本地的MySQL，因此选择loopback回环网卡：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimaged79bd7c3cc2d997990d0c4b94f72f1679c9b.b9fc7107.png" alt=""/></p><p>然后，Wireshark捕捉这个网卡的所有网络流量。我们可以在上方的显示过滤栏输入tcp.port == 6657，来过滤出所有6657端口的TCP请求（因为我们是通过6657端口连接MySQL的）。</p><p>可以看到，程序运行期间和MySQL有大量交互。因为Wireshark直接把TCP数据包解析为了MySQL协议，所以下方窗口可以直接显示MySQL请求的SQL查询语句。<strong>我们看到，testuser表的每次insert操作，插入的都是一行记录</strong>：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimagebca2bcb987cab3cccf4d8729cfe44f01a2a2.83a8ebc9.png" alt=""/></p><p>如果列表中的Protocol没有显示MySQL的话，你可以手动点击Analyze菜单的Decode As菜单，然后加一条规则，把6657端口设置为MySQL协议：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage6af26ae982e2013cf1c60300332068b58cf2.0cbf5181.png" alt=""/></p><p>这就说明，我们的程序并不是在做批量插入操作，和普通的单条循环插入没有区别。调试程序进入ClientPreparedStatement类，可以看到执行批量操作的是executeBatchInternal方法。executeBatchInternal方法的源码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Override</span></div><div class="token-line"><span class="token plain">    protected long[] executeBatchInternal() throws SQLException {</span></div><div class="token-line"><span class="token plain">        synchronized (checkClosed().getConnectionMutex()) {</span></div><div class="token-line"><span class="token plain">            if (this.connection.isReadOnly()) {</span></div><div class="token-line"><span class="token plain">                throw new SQLException(Messages.getString(&quot;PreparedStatement.25&quot;) + Messages.getString(&quot;PreparedStatement.26&quot;),</span></div><div class="token-line"><span class="token plain">                        MysqlErrorNumbers.SQL_STATE_ILLEGAL_ARGUMENT);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            if (this.query.getBatchedArgs() == null || this.query.getBatchedArgs().size() == 0) {</span></div><div class="token-line"><span class="token plain">                return new long[0];</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            // we timeout the entire batch, not individual statements</span></div><div class="token-line"><span class="token plain">            int batchTimeout = getTimeoutInMillis();</span></div><div class="token-line"><span class="token plain">            setTimeoutInMillis(0);</span></div><div class="token-line"><span class="token plain">            resetCancelledState();</span></div><div class="token-line"><span class="token plain">            try {</span></div><div class="token-line"><span class="token plain">                statementBegins();</span></div><div class="token-line"><span class="token plain">                clearWarnings();</span></div><div class="token-line"><span class="token plain">                if (!this.batchHasPlainStatements &amp;&amp; this.rewriteBatchedStatements.getValue()) {</span></div><div class="token-line"><span class="token plain">                    if (((PreparedQuery&lt;?&gt;) this.query).getParseInfo().canRewriteAsMultiValueInsertAtSqlLevel()) {</span></div><div class="token-line"><span class="token plain">                        return executeBatchedInserts(batchTimeout);</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                    if (!this.batchHasPlainStatements &amp;&amp; this.query.getBatchedArgs() != null</span></div><div class="token-line"><span class="token plain">                            &amp;&amp; this.query.getBatchedArgs().size() &gt; 3 /* cost of option setting rt-wise */) {</span></div><div class="token-line"><span class="token plain">                        return executePreparedBatchAsMultiStatement(batchTimeout);</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">                return executeBatchSerially(batchTimeout);</span></div><div class="token-line"><span class="token plain">            } finally {</span></div><div class="token-line"><span class="token plain">                this.query.getStatementExecuting().set(false);</span></div><div class="token-line"><span class="token plain">                clearBatch();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>注意第18行，判断了rewriteBatchedStatements参数是否为true，是才会开启批量的优化。优化方式有2种：</p><ul><li>如果有条件的话，优先把insert语句优化为一条语句，也就是executeBatchedInserts方法；</li><li>如果不行的话，再尝试把insert语句优化为多条语句一起提交，也就是executePreparedBatchAsMultiStatement方法。</li></ul><p>到这里就明朗了，实现批量提交优化的关键，在于rewriteBatchedStatements参数。我们修改连接字符串，并将其值设置为true：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">spring.datasource.url=jdbc:mysql://localhost:6657/common_mistakes?characterEncoding=UTF-8&amp;useSSL=false&amp;rewriteBatchedStatements=true</span></div></pre></div><p>重新按照之前的步骤打开Wireshark验证，可以看到：</p><ul><li>这次insert SQL语句被拼接成了一条语句（如第二个红框所示）；</li><li>这个TCP包因为太大被分割成了11个片段传输，#699请求是最后一个片段，其实际内容是insert语句的最后一部分内容（如第一和第三个红框显示）。</li></ul><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage3bbc3b7406c96a90e454a00e3c8ba82ecfbc.8ef8c314.png" alt=""/></p><p>为了查看整个TCP连接的所有数据包，你可以在请求上点击右键，选择Follow-&gt;TCP Stream：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage5bc25b18a8c6c227df50ad493f5aa546f9c2.ef66de18.png" alt=""/></p><p>打开后可以看到，从MySQL认证开始到insert语句的所有数据包的内容：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimagee15ae154da637a2b44a65f9257beb842575a.0c521d4e.png" alt=""/></p><p>查看最开始的握手数据包可以发现，TCP的最大分段大小（MSS）是16344字节，而我们的MySQL超长insert的数据一共138933字节，因此被分成了11段传输，其中最大的一段是16332字节，低于MSS要求的16344字节。</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage3e9e3e66a004fd4b7dba14047751a57e089e.820ee102.png" alt=""/></p><p>最后可以看到插入1万条数据仅耗时253毫秒，性能提升了100倍：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[20:19:30.185] [main] [INFO ] [o.g.t.c.t.network.BatchInsertApplication:52  ] - took : 253 ms</span></div></pre></div><p>虽然我们一直在使用MySQL，但我们很少会考虑MySQL Connector Java是怎么和MySQL交互的，实际发送给MySQL的SQL语句又是怎样的。有没有感觉到，MySQL协议其实并不遥远，我们完全可以使用Wireshark来观察、分析应用程序与MySQL交互的整个流程。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/05.加餐/04#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>今天，我就使用JDK自带工具查看JVM情况、使用Wireshark分析SQL批量插入慢的问题，和你展示了一些工具及其用法。</p><p>首先，JDK自带的一些监控和故障诊断工具中，有命令行工具也有图形工具。其中，命令行工具更适合在服务器上使用，图形界面工具用于本地观察数据更直观。为了帮助你用好这些工具，我们带你使用这些工具，分析了程序错误设置JVM参数的两个问题，并且观察了GC工作的情况。</p><p>然后，我们使用Wireshark分析了MySQL批量insert操作慢的问题。我们看到，通过Wireshark分析网络包可以让一切变得如此透明。因此，学好Wireshark，对我们排查C/S网络程序的Bug或性能问题，会有非常大的帮助。</p><p>比如，遇到诸如Connection reset、Broken pipe等网络问题的时候，你可以利用Wireshark来定位问题，观察客户端和服务端之间到底出了什么问题。</p><p>此外，如果你需要开发网络程序的话，Wireshark更是分析协议、确认程序是否正确实现的必备工具。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a target="_blank" rel="noopener noreferrer" href="https://github.com/JosephZhu1983/java-common-mistakes">这个链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>查看。</p><h2 id="思考与讨论"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/05.加餐/04#思考与讨论"><span class="icon icon-link"></span></a>思考与讨论</h2><ol><li>JDK中还有一个jmap工具，我们会使用jmap -dump命令来进行堆转储。那么，这条命令和jmap -dump:live有什么区别呢？你能否设计一个实验，来证明下它们的区别呢？</li><li>你有没有想过，客户端是如何和MySQL进行认证的呢？你能否对照<a target="_blank" rel="noopener noreferrer" href="https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::Handshake">MySQL的文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，使用Wireshark观察分析这一过程呢？</li></ol><p>在平时工作中，你还会使用什么工具来分析排查Java应用程序的问题呢？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把今天的内容分享给你的朋友或同事，一起交流。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/java业务开发常见错误100例/05.加餐/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:06:36</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-java/umi.fde43fdb.js"></script>
  </body>
</html>
