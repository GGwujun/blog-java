<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-java/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-java";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>26 | 数据存储：NoSQL与RDBMS如何取长补短、相辅相成？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/java业务开发常见错误100例/03.设计篇/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java业务开发常见错误100例/01.开篇词">01.开篇词</a><ul><li><a href="/blog-java/java业务开发常见错误100例/01.开篇词/01"><span>开篇词 | 业务代码真的会有这么多坑？</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇">02.代码篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/01"><span>01 | 使用了并发工具类库，线程安全就高枕无忧了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/02"><span>02 | 代码加锁：不要让“锁”事成为烦心事</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/03"><span>03 | 线程池：业务代码最常用也最容易犯错的组件</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/04"><span>04 | 连接池：别让连接池帮了倒忙</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/05"><span>05 | HTTP调用：你考虑到超时、重试、并发了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/06"><span>06 | 20%的业务代码的Spring声明式事务，可能都没处理正确</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/07"><span>答疑篇：代码篇思考题集锦（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/08"><span>07 | 数据库索引：索引并不是万能药</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/09"><span>08 | 判等问题：程序里如何确定你就是你？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/10"><span>09 | 数值计算：注意精度、舍入和溢出问题</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/11"><span>10 | 集合类：坑满地的List列表操作</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/12"><span>11 | 空值处理：分不清楚的null和恼人的空指针</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/13"><span>12 | 异常处理：别让自己在出问题的时候变为瞎子</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/14"><span>答疑篇：代码篇思考题集锦（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/15"><span>13 | 日志：日志记录真没你想象的那么简单</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/16"><span>14 | 文件IO：实现高效正确的文件读写并非易事</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/17"><span>15 | 序列化：一来一回你还是原来的你吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/18"><span>16 | 用好Java 8的日期时间类，少踩一些“老三样”的坑</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/19"><span>17 | 别以为“自动挡”就不可能出现OOM</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/20"><span>18 | 当反射、注解和泛型遇到OOP时，会有哪些坑？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/21"><span>19 | Spring框架：IoC和AOP是扩展的核心</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/22"><span>20 | Spring框架：框架帮我们做了很多工作也带来了复杂度</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/02.代码篇/23"><span>答疑篇：代码篇思考题集锦（三）</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例/03.设计篇">03.设计篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/01"><span>21 |  代码重复：搞定代码重复的三个绝招</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/02"><span>22 | 接口设计：系统间对话的语言，一定要统一</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/03"><span>23 | 缓存设计：缓存可以锦上添花也可以落井下石</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/04"><span>24 | 业务代码写完，就意味着生产就绪了？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/05"><span>25 | 异步处理好用，但非常容易用错</span></a></li><li><a aria-current="page" class="active" href="/blog-java/java业务开发常见错误100例/03.设计篇/06"><span>26 | 数据存储：NoSQL与RDBMS如何取长补短、相辅相成？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/03.设计篇/07"><span>答疑篇：设计篇思考题答案合集</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇">04.安全篇</a><ul><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/01"><span>27 | 数据源头：任何客户端的东西都不可信任</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/02"><span>28 | 安全兜底：涉及钱时，必须考虑防刷、限量和防重</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/03"><span>29 | 数据和代码：数据就是数据，代码就是代码</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/04"><span>30 | 如何正确保存和传输敏感数据？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/04.安全篇/05"><span>答疑篇：安全篇思考题答案合集</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐">05.加餐</a><ul><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/01"><span>31 | 加餐1：带你吃透课程中Java 8的那些重要知识点（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/02"><span>32 | 加餐2：带你吃透课程中Java 8的那些重要知识点（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/03"><span>33 | 加餐3：定位应用问题，排错套路很重要</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/04"><span>34 | 加餐4：分析定位Java问题，一定要用好这些工具（一）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/05"><span>35 | 加餐5：分析定位Java问题，一定要用好这些工具（二）</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/06"><span>36 | 加餐6：这15年来，我是如何在工作中学习技术和英语的？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/07"><span>答疑篇：加餐篇思考题答案合集</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/08"><span>37 | 加餐7：程序员成长28计</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/05.加餐/09"><span>38 | 加餐8：Java程序从虚拟机迁移到Kubernetes的一些坑</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语">06.结束语</a><ul><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/01"><span>结束语 | 写代码时，如何才能尽量避免踩坑？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/02"><span>结课测试 | 关于Java业务开发的100个常见错误，你都明白其中缘由了吗？</span></a></li><li><a href="/blog-java/java业务开发常见错误100例/06.结束语/03"><span>结课问卷获奖用户名单</span></a></li></ul></li><li><a href="/blog-java/java业务开发常见错误100例/summary">java业务开发常见错误100例</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="取长补短之 Redis vs MySQL" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/03.设计篇/06#取长补短之-redis-vs-mysql"><span>取长补短之 Redis vs MySQL</span></a></li><li title="取长补短之 InfluxDB vs MySQL" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/03.设计篇/06#取长补短之-influxdb-vs-mysql"><span>取长补短之 InfluxDB vs MySQL</span></a></li><li title="取长补短之 Elasticsearch vs MySQL" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/03.设计篇/06#取长补短之-elasticsearch-vs-mysql"><span>取长补短之 Elasticsearch vs MySQL</span></a></li><li title="结合NoSQL和MySQL应对高并发的复合数据库架构" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/03.设计篇/06#结合nosql和mysql应对高并发的复合数据库架构"><span>结合NoSQL和MySQL应对高并发的复合数据库架构</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/03.设计篇/06#重点回顾"><span>重点回顾</span></a></li><li title="思考与讨论" data-depth="2"><a href="/blog-java/java业务开发常见错误100例/03.设计篇/06#思考与讨论"><span>思考与讨论</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="26--数据存储nosql与rdbms如何取长补短相辅相成"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/03.设计篇/06#26--数据存储nosql与rdbms如何取长补短相辅相成"><span class="icon icon-link"></span></a>26 | 数据存储：NoSQL与RDBMS如何取长补短、相辅相成？</h1><p>你好，我是朱晔。今天，我来和你聊聊数据存储的常见错误。</p><p>近几年，各种非关系型数据库，也就是NoSQL发展迅猛，在项目中也非常常见。其中不乏一些使用上的极端情况，比如直接把关系型数据库（RDBMS）全部替换为NoSQL，或是在不合适的场景下错误地使用NoSQL。</p><p>其实，每种NoSQL的特点不同，都有其要着重解决的某一方面的问题。因此，我们在使用NoSQL的时候，要尽量让它去处理擅长的场景，否则不但发挥不出它的功能和优势，还可能会导致性能问题。</p><p>NoSQL一般可以分为缓存数据库、时间序列数据库、全文搜索数据库、文档数据库、图数据库等。今天，我会以缓存数据库Redis、时间序列数据库InfluxDB、全文搜索数据库ElasticSearch为例，通过一些测试案例，和你聊聊这些常见NoSQL的特点，以及它们擅长和不擅长的地方。最后，我也还会和你说说NoSQL如何与RDBMS相辅相成，来构成一套可以应对高并发的复合数据库体系。</p><h2 id="取长补短之-redis-vs-mysql"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/03.设计篇/06#取长补短之-redis-vs-mysql"><span class="icon icon-link"></span></a>取长补短之 Redis vs MySQL</h2><p>Redis是一款设计简洁的缓存数据库，数据都保存在内存中，所以读写单一Key的性能非常高。</p><p>我们来做一个简单测试，分别填充10万条数据到Redis和MySQL中。MySQL中的name字段做了索引，相当于Redis的Key，data字段为100字节的数据，相当于Redis的Value：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@SpringBootApplication</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class CommonMistakesApplication {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //模拟10万条数据存到Redis和MySQL</span></div><div class="token-line"><span class="token plain">        public static final int ROWS = 100000;</span></div><div class="token-line"><span class="token plain">        public static final String PAYLOAD = IntStream.rangeClosed(1, 100).mapToObj(__ -&gt; &quot;a&quot;).collect(Collectors.joining(&quot;&quot;));</span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private StringRedisTemplate stringRedisTemplate;</span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private JdbcTemplate jdbcTemplate;</span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private StandardEnvironment standardEnvironment;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">            SpringApplication.run(CommonMistakesApplication.class, args);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @PostConstruct</span></div><div class="token-line"><span class="token plain">        public void init() {</span></div><div class="token-line"><span class="token plain">            //使用-Dspring.profiles.active=init启动程序进行初始化</span></div><div class="token-line"><span class="token plain">            if (Arrays.stream(standardEnvironment.getActiveProfiles()).anyMatch(s -&gt; s.equalsIgnoreCase(&quot;init&quot;))) {</span></div><div class="token-line"><span class="token plain">                initRedis();</span></div><div class="token-line"><span class="token plain">                initMySQL();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //填充数据到MySQL</span></div><div class="token-line"><span class="token plain">        private void initMySQL() {</span></div><div class="token-line"><span class="token plain">            //删除表</span></div><div class="token-line"><span class="token plain">            jdbcTemplate.execute(&quot;DROP TABLE IF EXISTS `r`;&quot;);</span></div><div class="token-line"><span class="token plain">            //新建表，name字段做了索引</span></div><div class="token-line"><span class="token plain">            jdbcTemplate.execute(&quot;CREATE TABLE `r` (\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;  `data` varchar(2000) NOT NULL,\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;  `name` varchar(20) NOT NULL,\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;  PRIMARY KEY (`id`),\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;  KEY `name` (`name`) USING BTREE\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            //批量插入数据</span></div><div class="token-line"><span class="token plain">            String sql = &quot;INSERT INTO `r` (`data`,`name`) VALUES (?,?)&quot;;</span></div><div class="token-line"><span class="token plain">            jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {</span></div><div class="token-line"><span class="token plain">                @Override</span></div><div class="token-line"><span class="token plain">                public void setValues(PreparedStatement preparedStatement, int i) throws SQLException {</span></div><div class="token-line"><span class="token plain">                    preparedStatement.setString(1, PAYLOAD);</span></div><div class="token-line"><span class="token plain">                    preparedStatement.setString(2, &quot;item&quot; + i);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                @Override</span></div><div class="token-line"><span class="token plain">                public int getBatchSize() {</span></div><div class="token-line"><span class="token plain">                    return ROWS;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            });</span></div><div class="token-line"><span class="token plain">            log.info(&quot;init mysql finished with count {}&quot;, jdbcTemplate.queryForObject(&quot;SELECT COUNT(*) FROM `r`&quot;, Long.class));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //填充数据到Redis</span></div><div class="token-line"><span class="token plain">        private void initRedis() {</span></div><div class="token-line"><span class="token plain">            IntStream.rangeClosed(1, ROWS).forEach(i -&gt; stringRedisTemplate.opsForValue().set(&quot;item&quot; + i, PAYLOAD));</span></div><div class="token-line"><span class="token plain">            log.info(&quot;init redis finished with count {}&quot;, stringRedisTemplate.keys(&quot;item*&quot;));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>启动程序后，输出了如下日志，数据全部填充完毕：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[14:22:47.195] [main] [INFO ] [o.g.t.c.n.r.CommonMistakesApplication:80  ] - init redis finished with count 100000</span></div><div class="token-line"><span class="token plain">    [14:22:50.030] [main] [INFO ] [o.g.t.c.n.r.CommonMistakesApplication:74  ] - init mysql finished with count 100000</span></div></pre></div><p>然后，比较一下从MySQL和Redis随机读取单条数据的性能。“公平”起见，像Redis那样，我们使用MySQL时也根据Key来查Value，也就是根据name字段来查data字段，并且我们给name字段做了索引：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Autowired</span></div><div class="token-line"><span class="token plain">    private JdbcTemplate jdbcTemplate;</span></div><div class="token-line"><span class="token plain">    @Autowired</span></div><div class="token-line"><span class="token plain">    private StringRedisTemplate stringRedisTemplate;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @GetMapping(&quot;redis&quot;)</span></div><div class="token-line"><span class="token plain">    public void redis() {</span></div><div class="token-line"><span class="token plain">        //使用随机的Key来查询Value，结果应该等于PAYLOAD</span></div><div class="token-line"><span class="token plain">        Assert.assertTrue(stringRedisTemplate.opsForValue().get(&quot;item&quot; + (ThreadLocalRandom.current().nextInt(CommonMistakesApplication.ROWS) + 1)).equals(CommonMistakesApplication.PAYLOAD));</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @GetMapping(&quot;mysql&quot;)</span></div><div class="token-line"><span class="token plain">    public void mysql() {</span></div><div class="token-line"><span class="token plain">        //根据随机name来查data，name字段有索引，结果应该等于PAYLOAD</span></div><div class="token-line"><span class="token plain">        Assert.assertTrue(jdbcTemplate.queryForObject(&quot;SELECT data FROM `r` WHERE name=?&quot;, new Object[]{(&quot;item&quot; + (ThreadLocalRandom.current().nextInt(CommonMistakesApplication.ROWS) + 1))}, String.class)</span></div><div class="token-line"><span class="token plain">                .equals(CommonMistakesApplication.PAYLOAD));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在我的电脑上，使用wrk 加10个线程50个并发连接做压测。可以看到，MySQL 90%的请求需要61ms，QPS为1460；<strong>而Redis 90%的请求在5ms左右，QPS达到了14008，几乎是MySQL的十倍</strong>：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage2d4e2d289cc94097c2e62aa97a6602d0554e.bf0353ad.png" alt=""/></p><p>但Redis薄弱的地方是，不擅长做Key的搜索。对MySQL，我们可以使用LIKE操作前匹配走B+树索引实现快速搜索；但对Redis，我们使用Keys命令对Key的搜索，其实相当于在MySQL里做全表扫描。</p><p>我写一段代码来对比一下性能：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;redis2&quot;)</span></div><div class="token-line"><span class="token plain">    public void redis2() {</span></div><div class="token-line"><span class="token plain">        Assert.assertTrue(stringRedisTemplate.keys(&quot;item71*&quot;).size() == 1111);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    @GetMapping(&quot;mysql2&quot;)</span></div><div class="token-line"><span class="token plain">    public void mysql2() {</span></div><div class="token-line"><span class="token plain">        Assert.assertTrue(jdbcTemplate.queryForList(&quot;SELECT name FROM `r` WHERE name LIKE &#x27;item71%&#x27;&quot;, String.class).size() == 1111);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，在QPS方面，<strong>MySQL的QPS达到了Redis的157倍；在延迟方面，MySQL的延迟只有Redis的十分之一。</strong></p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage5de85de7a4a7bf27f8736b0ac09ba0dd1fe8.7855b351.png" alt=""/></p><p>Redis慢的原因有两个：</p><ul><li>Redis的Keys命令是O(n)时间复杂度。如果数据库中Key的数量很多，就会非常慢。</li><li>Redis是单线程的，对于慢的命令如果有并发，串行执行就会非常耗时。</li></ul><p>一般而言，我们使用Redis都是针对某一个Key来使用，而不能在业务代码中使用Keys命令从Redis中“搜索数据”，因为这不是Redis的擅长。对于Key的搜索，我们可以先通过关系型数据库进行，然后再从Redis存取数据（如果实在需要搜索Key可以使用SCAN命令）。在生产环境中，我们一般也会配置Redis禁用类似Keys这种比较危险的命令，你可以<a target="_blank" rel="noopener noreferrer" href="https://redis.io/topics/security">参考这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>总结一下，正如“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/231501">缓存设计<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”一讲中提到的，对于业务开发来说，大多数业务场景下Redis是作为关系型数据库的辅助用于缓存的，我们一般不会把它当作数据库独立使用。</p><p>此外值得一提的是，Redis提供了丰富的数据结构（Set、SortedSet、Hash、List），并围绕这些数据结构提供了丰富的API。如果我们好好利用这个特点的话，可以直接在Redis中完成一部分服务端计算，避免“读取缓存-&gt;计算数据-&gt;保存缓存”三部曲中的读取和保存缓存的开销，进一步提高性能。</p><h2 id="取长补短之-influxdb-vs-mysql"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/03.设计篇/06#取长补短之-influxdb-vs-mysql"><span class="icon icon-link"></span></a>取长补短之 InfluxDB vs MySQL</h2><p>InfluxDB是一款优秀的时序数据库。在“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/231568">生产就绪<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”这一讲中，我们就是使用InfluxDB来做的Metrics打点。时序数据库的优势，在于处理指标数据的聚合，并且读写效率非常高。</p><p>同样的，我们使用一些测试来对比下InfluxDB和MySQL的性能。</p><p>在如下代码中，我们分别填充了1000万条数据到MySQL和InfluxDB中。其中，每条数据只有ID、时间戳、10000以内的随机值这3列信息，对于MySQL我们把时间戳列做了索引：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@SpringBootApplication</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class CommonMistakesApplication {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">            SpringApplication.run(CommonMistakesApplication.class, args);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //测试数据量</span></div><div class="token-line"><span class="token plain">        public static final int ROWS = 10000000;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private JdbcTemplate jdbcTemplate;</span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private StandardEnvironment standardEnvironment;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @PostConstruct</span></div><div class="token-line"><span class="token plain">        public void init() {</span></div><div class="token-line"><span class="token plain">            //使用-Dspring.profiles.active=init启动程序进行初始化</span></div><div class="token-line"><span class="token plain">            if (Arrays.stream(standardEnvironment.getActiveProfiles()).anyMatch(s -&gt; s.equalsIgnoreCase(&quot;init&quot;))) {</span></div><div class="token-line"><span class="token plain">                initInfluxDB();</span></div><div class="token-line"><span class="token plain">                initMySQL();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //初始化MySQL</span></div><div class="token-line"><span class="token plain">        private void initMySQL() {</span></div><div class="token-line"><span class="token plain">            long begin = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">            jdbcTemplate.execute(&quot;DROP TABLE IF EXISTS `m`;&quot;);</span></div><div class="token-line"><span class="token plain">            //只有ID、值和时间戳三列</span></div><div class="token-line"><span class="token plain">            jdbcTemplate.execute(&quot;CREATE TABLE `m` (\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;  `value` bigint NOT NULL,\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;  `time` timestamp NOT NULL,\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;  PRIMARY KEY (`id`),\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;  KEY `time` (`time`) USING BTREE\n&quot; +</span></div><div class="token-line"><span class="token plain">                    &quot;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            String sql = &quot;INSERT INTO `m` (`value`,`time`) VALUES (?,?)&quot;;</span></div><div class="token-line"><span class="token plain">            //批量插入数据</span></div><div class="token-line"><span class="token plain">            jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {</span></div><div class="token-line"><span class="token plain">                @Override</span></div><div class="token-line"><span class="token plain">                public void setValues(PreparedStatement preparedStatement, int i) throws SQLException {</span></div><div class="token-line"><span class="token plain">                    preparedStatement.setLong(1, ThreadLocalRandom.current().nextInt(10000));</span></div><div class="token-line"><span class="token plain">                    preparedStatement.setTimestamp(2, Timestamp.valueOf(LocalDateTime.now().minusSeconds(5 * i)));</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                @Override</span></div><div class="token-line"><span class="token plain">                public int getBatchSize() {</span></div><div class="token-line"><span class="token plain">                    return ROWS;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            });</span></div><div class="token-line"><span class="token plain">            log.info(&quot;init mysql finished with count {} took {}ms&quot;, jdbcTemplate.queryForObject(&quot;SELECT COUNT(*) FROM `m`&quot;, Long.class), System.currentTimeMillis()-begin);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //初始化InfluxDB</span></div><div class="token-line"><span class="token plain">        private void initInfluxDB() {</span></div><div class="token-line"><span class="token plain">            long begin = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">            OkHttpClient.Builder okHttpClientBuilder = new OkHttpClient().newBuilder()</span></div><div class="token-line"><span class="token plain">                    .connectTimeout(1, TimeUnit.SECONDS)</span></div><div class="token-line"><span class="token plain">                    .readTimeout(10, TimeUnit.SECONDS)</span></div><div class="token-line"><span class="token plain">                    .writeTimeout(10, TimeUnit.SECONDS);</span></div><div class="token-line"><span class="token plain">            try (InfluxDB influxDB = InfluxDBFactory.connect(&quot;http://127.0.0.1:8086&quot;, &quot;root&quot;, &quot;root&quot;, okHttpClientBuilder)) {</span></div><div class="token-line"><span class="token plain">                String db = &quot;performance&quot;;</span></div><div class="token-line"><span class="token plain">                influxDB.query(new Query(&quot;DROP DATABASE &quot; + db));</span></div><div class="token-line"><span class="token plain">                influxDB.query(new Query(&quot;CREATE DATABASE &quot; + db));</span></div><div class="token-line"><span class="token plain">                //设置数据库</span></div><div class="token-line"><span class="token plain">                influxDB.setDatabase(db);</span></div><div class="token-line"><span class="token plain">                //批量插入，10000条数据刷一次，或1秒刷一次</span></div><div class="token-line"><span class="token plain">                influxDB.enableBatch(BatchOptions.DEFAULTS.actions(10000).flushDuration(1000));</span></div><div class="token-line"><span class="token plain">                IntStream.rangeClosed(1, ROWS).mapToObj(i -&gt; Point</span></div><div class="token-line"><span class="token plain">                        .measurement(&quot;m&quot;)</span></div><div class="token-line"><span class="token plain">                        .addField(&quot;value&quot;, ThreadLocalRandom.current().nextInt(10000))</span></div><div class="token-line"><span class="token plain">                        .time(LocalDateTime.now().minusSeconds(5 * i).toInstant(ZoneOffset.UTC).toEpochMilli(), TimeUnit.MILLISECONDS).build())</span></div><div class="token-line"><span class="token plain">                        .forEach(influxDB::write);</span></div><div class="token-line"><span class="token plain">                influxDB.flush();</span></div><div class="token-line"><span class="token plain">                log.info(&quot;init influxdb finished with count {} took {}ms&quot;, influxDB.query(new Query(&quot;SELECT COUNT(*) FROM m&quot;)).getResults().get(0).getSeries().get(0).getValues().get(0).get(1), System.currentTimeMillis()-begin);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>启动后，程序输出了如下日志：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[16:08:25.062] [main] [INFO ] [o.g.t.c.n.i.CommonMistakesApplication:104 ] - init influxdb finished with count 1.0E7 took 54280ms</span></div><div class="token-line"><span class="token plain">    [16:11:50.462] [main] [INFO ] [o.g.t.c.n.i.CommonMistakesApplication:80  ] - init mysql finished with count 10000000 took 205394ms</span></div></pre></div><p>InfluxDB批量插入1000万条数据仅用了54秒，相当于每秒插入18万条数据，速度相当快；MySQL的批量插入，速度也挺快达到了每秒4.8万。</p><p>接下来，我们测试一下。</p><p>对这1000万数据进行一个统计，查询最近60天的数据，按照1小时的时间粒度聚合，统计value列的最大值、最小值和平均值，并将统计结果绘制成曲线图：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Autowired</span></div><div class="token-line"><span class="token plain">    private JdbcTemplate jdbcTemplate;</span></div><div class="token-line"><span class="token plain">    @GetMapping(&quot;mysql&quot;)</span></div><div class="token-line"><span class="token plain">    public void mysql() {</span></div><div class="token-line"><span class="token plain">        long begin = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">        //使用SQL从MySQL查询，按照小时分组</span></div><div class="token-line"><span class="token plain">        Object result = jdbcTemplate.queryForList(&quot;SELECT date_format(time,&#x27;%Y%m%d%H&#x27;),max(value),min(value),avg(value) FROM m WHERE time&gt;now()- INTERVAL 60 DAY GROUP BY date_format(time,&#x27;%Y%m%d%H&#x27;)&quot;);</span></div><div class="token-line"><span class="token plain">        log.info(&quot;took {} ms result {}&quot;, System.currentTimeMillis() - begin, result);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @GetMapping(&quot;influxdb&quot;)</span></div><div class="token-line"><span class="token plain">    public void influxdb() {</span></div><div class="token-line"><span class="token plain">        long begin = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">        try (InfluxDB influxDB = InfluxDBFactory.connect(&quot;http://127.0.0.1:8086&quot;, &quot;root&quot;, &quot;root&quot;)) {</span></div><div class="token-line"><span class="token plain">            //切换数据库</span></div><div class="token-line"><span class="token plain">            influxDB.setDatabase(&quot;performance&quot;);</span></div><div class="token-line"><span class="token plain">            //InfluxDB的查询语法InfluxQL类似SQL</span></div><div class="token-line"><span class="token plain">            Object result = influxDB.query(new Query(&quot;SELECT MEAN(value),MIN(value),MAX(value) FROM m WHERE time &gt; now() - 60d GROUP BY TIME(1h)&quot;));</span></div><div class="token-line"><span class="token plain">            log.info(&quot;took {} ms result {}&quot;, System.currentTimeMillis() - begin, result);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>因为数据量非常大，单次查询就已经很慢了，所以这次我们不进行压测。分别调用两个接口，可以看到<strong>MySQL查询一次耗时29秒左右，而InfluxDB耗时980ms</strong>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[16:19:26.562] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.n.i.PerformanceController:31  ] - took 28919 ms result [{date_format(time,&#x27;%Y%m%d%H&#x27;)=2019121308, max(value)=9993, min(value)=4, avg(value)=5129.5639}, {date_format(time,&#x27;%Y%m%d%H&#x27;)=2019121309, max(value)=9990, min(value)=12, avg(value)=4856.0556}, {date_format(time,&#x27;%Y%m%d%H&#x27;)=2019121310, max(value)=9998, min(value)=8, avg(value)=4948.9347}, {date_format(time,&#x27;%Y%m%d%H&#x27;)...</span></div><div class="token-line"><span class="token plain">    [16:20:08.170] [http-nio-45678-exec-6] [INFO ] [o.g.t.c.n.i.PerformanceController:40  ] - took 981 ms result QueryResult [results=[Result [series=[Series [name=m, tags=null, columns=[time, mean, min, max], values=[[2019-12-13T08:00:00Z, 5249.2468619246865, 21.0, 9992.0],...</span></div></pre></div><p>在按照时间区间聚合的案例上，我们看到了InfluxDB的性能优势。但，我们<strong>肯定不能把InfluxDB当作普通数据库</strong>，原因是：</p><ul><li>InfluxDB不支持数据更新操作，毕竟时间数据只能随着时间产生新数据，肯定无法对过去的数据做修改；</li><li>从数据结构上说，时间序列数据数据没有单一的主键标识，必须包含时间戳，数据只能和时间戳进行关联，不适合普通业务数据。</li></ul><p><strong>此外需要注意，即便只是使用InfluxDB保存和时间相关的指标数据，我们也要注意不能滥用tag</strong>。</p><p>InfluxDB提供的tag功能，可以为每一个指标设置多个标签，并且tag有索引，可以对tag进行条件搜索或分组。但是，tag只能保存有限的、可枚举的标签，不能保存URL等信息，否则可能会出现<a target="_blank" rel="noopener noreferrer" href="https://docs.influxdata.com/influxdb/v1.7/concepts/schema_and_data_layout/#don-t-have-too-many-serieshigh%20series%20cardinality">high series cardinality问题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，导致占用大量内存，甚至是OOM。你可以点击<a target="_blank" rel="noopener noreferrer" href="https://docs.influxdata.com/influxdb/v1.7/guides/hardware_sizing/">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，查看series和内存占用的关系。对于InfluxDB，我们无法把URL这种原始数据保存到数据库中，只能把数据进行归类，形成有限的tag进行保存。</p><p>总结一下，对于MySQL而言，针对大量的数据使用全表扫描的方式来聚合统计指标数据，性能非常差，一般只能作为临时方案来使用。此时，引入InfluxDB之类的时间序列数据库，就很有必要了。时间序列数据库可以作为特定场景（比如监控、统计）的主存储，也可以和关系型数据库搭配使用，作为一个辅助数据源，保存业务系统的指标数据。</p><h2 id="取长补短之-elasticsearch-vs-mysql"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/03.设计篇/06#取长补短之-elasticsearch-vs-mysql"><span class="icon icon-link"></span></a>取长补短之 Elasticsearch vs MySQL</h2><p>Elasticsearch（以下简称ES），是目前非常流行的分布式搜索和分析数据库，独特的倒排索引结构尤其适合进行全文搜索。</p><p>简单来讲，倒排索引可以认为是一个Map，其Key是分词之后的关键字，Value是文档ID/片段ID的列表。我们只要输入需要搜索的单词，就可以直接在这个Map中得到所有包含这个单词的文档ID/片段ID列表，然后再根据其中的文档ID/片段ID查询出实际的文档内容。</p><p>我们来测试一下，对比下使用ES进行关键字全文搜索、在MySQL中使用LIKE进行搜索的效率差距。</p><p>首先，定义一个实体News，包含新闻分类、标题、内容等字段。这个实体同时会用作Spring Data JPA和Spring Data Elasticsearch的实体：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Entity</span></div><div class="token-line"><span class="token plain">    @Document(indexName = &quot;news&quot;, replicas = 0) //@Document注解定义了这是一个ES的索引，索引名称news，数据不需要冗余</span></div><div class="token-line"><span class="token plain">    @Table(name = &quot;news&quot;, indexes = {@Index(columnList = &quot;cateid&quot;)}) //@Table注解定义了这是一个MySQL表，表名news，对cateid列做索引</span></div><div class="token-line"><span class="token plain">    @Data</span></div><div class="token-line"><span class="token plain">    @AllArgsConstructor</span></div><div class="token-line"><span class="token plain">    @NoArgsConstructor</span></div><div class="token-line"><span class="token plain">    @DynamicUpdate</span></div><div class="token-line"><span class="token plain">    public class News {</span></div><div class="token-line"><span class="token plain">        @Id</span></div><div class="token-line"><span class="token plain">        private long id;</span></div><div class="token-line"><span class="token plain">        @Field(type = FieldType.Keyword)</span></div><div class="token-line"><span class="token plain">        private String category;//新闻分类名称</span></div><div class="token-line"><span class="token plain">        private int cateid;//新闻分类ID</span></div><div class="token-line"><span class="token plain">        @Column(columnDefinition = &quot;varchar(500)&quot;)//@Column注解定义了在MySQL中字段，比如这里定义title列的类型是varchar(500)</span></div><div class="token-line"><span class="token plain">        @Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_smart&quot;)//@Field注解定义了ES字段的格式，使用ik分词器进行分词</span></div><div class="token-line"><span class="token plain">        private String title;//新闻标题</span></div><div class="token-line"><span class="token plain">        @Column(columnDefinition = &quot;text&quot;)</span></div><div class="token-line"><span class="token plain">        @Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_smart&quot;)</span></div><div class="token-line"><span class="token plain">        private String content;//新闻内容</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接下来，我们实现主程序。在启动时，我们会从一个csv文件中加载4000条新闻数据，然后复制100份，拼成40万条数据，分别写入MySQL和ES：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@SpringBootApplication</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    @EnableElasticsearchRepositories(includeFilters = @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, value = NewsESRepository.class)) //明确设置哪个是ES的Repository</span></div><div class="token-line"><span class="token plain">    @EnableJpaRepositories(excludeFilters = @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, value = NewsESRepository.class)) //其他的是MySQL的Repository</span></div><div class="token-line"><span class="token plain">    public class CommonMistakesApplication {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">            Utils.loadPropertySource(CommonMistakesApplication.class, &quot;es.properties&quot;);</span></div><div class="token-line"><span class="token plain">            SpringApplication.run(CommonMistakesApplication.class, args);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private StandardEnvironment standardEnvironment;</span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private NewsESRepository newsESRepository;</span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private NewsMySQLRepository newsMySQLRepository;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @PostConstruct</span></div><div class="token-line"><span class="token plain">        public void init() {</span></div><div class="token-line"><span class="token plain">            //使用-Dspring.profiles.active=init启动程序进行初始化</span></div><div class="token-line"><span class="token plain">            if (Arrays.stream(standardEnvironment.getActiveProfiles()).anyMatch(s -&gt; s.equalsIgnoreCase(&quot;init&quot;))) {</span></div><div class="token-line"><span class="token plain">                //csv中的原始数据只有4000条</span></div><div class="token-line"><span class="token plain">                List&lt;News&gt; news = loadData();</span></div><div class="token-line"><span class="token plain">                AtomicLong atomicLong = new AtomicLong();</span></div><div class="token-line"><span class="token plain">                news.forEach(item -&gt; item.setTitle(&quot;%%&quot; + item.getTitle()));</span></div><div class="token-line"><span class="token plain">                //我们模拟100倍的数据量，也就是40万条</span></div><div class="token-line"><span class="token plain">                IntStream.rangeClosed(1, 100).forEach(repeat -&gt; {</span></div><div class="token-line"><span class="token plain">                    news.forEach(item -&gt; {</span></div><div class="token-line"><span class="token plain">                        //重新设置主键ID</span></div><div class="token-line"><span class="token plain">                        item.setId(atomicLong.incrementAndGet());</span></div><div class="token-line"><span class="token plain">                        //每次复制数据稍微改一下title字段，在前面加上一个数字，代表这是第几次复制</span></div><div class="token-line"><span class="token plain">                        item.setTitle(item.getTitle().replaceFirst(&quot;%%&quot;, String.valueOf(repeat)));</span></div><div class="token-line"><span class="token plain">                    });</span></div><div class="token-line"><span class="token plain">                    initMySQL(news, repeat == 1);</span></div><div class="token-line"><span class="token plain">                    log.info(&quot;init MySQL finished for {}&quot;, repeat);</span></div><div class="token-line"><span class="token plain">                    initES(news, repeat == 1);</span></div><div class="token-line"><span class="token plain">                    log.info(&quot;init ES finished for {}&quot;, repeat);</span></div><div class="token-line"><span class="token plain">                });</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //从news.csv中解析得到原始数据</span></div><div class="token-line"><span class="token plain">        private List&lt;News&gt; loadData() {</span></div><div class="token-line"><span class="token plain">            //使用jackson-dataformat-csv实现csv到POJO的转换</span></div><div class="token-line"><span class="token plain">            CsvMapper csvMapper = new CsvMapper();</span></div><div class="token-line"><span class="token plain">            CsvSchema schema = CsvSchema.emptySchema().withHeader();</span></div><div class="token-line"><span class="token plain">            ObjectReader objectReader = csvMapper.readerFor(News.class).with(schema);</span></div><div class="token-line"><span class="token plain">            ClassLoader classLoader = getClass().getClassLoader();</span></div><div class="token-line"><span class="token plain">            File file = new File(classLoader.getResource(&quot;news.csv&quot;).getFile());</span></div><div class="token-line"><span class="token plain">            try (Reader reader = new FileReader(file)) {</span></div><div class="token-line"><span class="token plain">                return objectReader.&lt;News&gt;readValues(reader).readAll();</span></div><div class="token-line"><span class="token plain">            } catch (Exception e) {</span></div><div class="token-line"><span class="token plain">                e.printStackTrace();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            return null;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //把数据保存到ES中</span></div><div class="token-line"><span class="token plain">        private void initES(List&lt;News&gt; news, boolean clear) {</span></div><div class="token-line"><span class="token plain">            if (clear) {</span></div><div class="token-line"><span class="token plain">                //首次调用的时候先删除历史数据</span></div><div class="token-line"><span class="token plain">                newsESRepository.deleteAll();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            newsESRepository.saveAll(news);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //把数据保存到MySQL中</span></div><div class="token-line"><span class="token plain">        private void initMySQL(List&lt;News&gt; news, boolean clear) {</span></div><div class="token-line"><span class="token plain">            if (clear) {</span></div><div class="token-line"><span class="token plain">                //首次调用的时候先删除历史数据</span></div><div class="token-line"><span class="token plain">                newsMySQLRepository.deleteAll();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            newsMySQLRepository.saveAll(news);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>由于我们使用了Spring Data，直接定义两个Repository，然后直接定义查询方法，无需实现任何逻辑即可实现查询，Spring Data会根据方法名生成相应的SQL语句和ES查询DSL，其中ES的翻译逻辑<a target="_blank" rel="noopener noreferrer" href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#elasticsearch.query-methods.criterions">详见这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>在这里，我们定义一个countByCateidAndContentContainingAndContentContaining方法，代表查询条件是：搜索分类等于cateid参数，且内容同时包含关键字keyword1和keyword2，计算符合条件的新闻总数量：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Repository</span></div><div class="token-line"><span class="token plain">    public interface NewsMySQLRepository extends JpaRepository&lt;News, Long&gt; {</span></div><div class="token-line"><span class="token plain">        //JPA：搜索分类等于cateid参数，且内容同时包含关键字keyword1和keyword2，计算符合条件的新闻总数量</span></div><div class="token-line"><span class="token plain">        long countByCateidAndContentContainingAndContentContaining(int cateid, String keyword1, String keyword2);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Repository</span></div><div class="token-line"><span class="token plain">    public interface NewsESRepository extends ElasticsearchRepository&lt;News, Long&gt; {</span></div><div class="token-line"><span class="token plain">        //ES：搜索分类等于cateid参数，且内容同时包含关键字keyword1和keyword2，计算符合条件的新闻总数量</span></div><div class="token-line"><span class="token plain">        long countByCateidAndContentContainingAndContentContaining(int cateid, String keyword1, String keyword2);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>对于ES和MySQL，我们使用相同的条件进行搜索，搜素分类是1，关键字是社会和苹果，然后输出搜索结果和耗时：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//测试MySQL搜索，最后输出耗时和结果</span></div><div class="token-line"><span class="token plain">    @GetMapping(&quot;mysql&quot;)</span></div><div class="token-line"><span class="token plain">    public void mysql(@RequestParam(value = &quot;cateid&quot;, defaultValue = &quot;1&quot;) int cateid,</span></div><div class="token-line"><span class="token plain">                      @RequestParam(value = &quot;keyword1&quot;, defaultValue = &quot;社会&quot;) String keyword1,</span></div><div class="token-line"><span class="token plain">                      @RequestParam(value = &quot;keyword2&quot;, defaultValue = &quot;苹果&quot;) String keyword2) {</span></div><div class="token-line"><span class="token plain">        long begin = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">        Object result = newsMySQLRepository.countByCateidAndContentContainingAndContentContaining(cateid, keyword1, keyword2);</span></div><div class="token-line"><span class="token plain">        log.info(&quot;took {} ms result {}&quot;, System.currentTimeMillis() - begin, result);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //测试ES搜索，最后输出耗时和结果</span></div><div class="token-line"><span class="token plain">    @GetMapping(&quot;es&quot;)</span></div><div class="token-line"><span class="token plain">    public void es(@RequestParam(value = &quot;cateid&quot;, defaultValue = &quot;1&quot;) int cateid,</span></div><div class="token-line"><span class="token plain">                   @RequestParam(value = &quot;keyword1&quot;, defaultValue = &quot;社会&quot;) String keyword1,</span></div><div class="token-line"><span class="token plain">                   @RequestParam(value = &quot;keyword2&quot;, defaultValue = &quot;苹果&quot;) String keyword2) {</span></div><div class="token-line"><span class="token plain">        long begin = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">        Object result = newsESRepository.countByCateidAndContentContainingAndContentContaining(cateid, keyword1, keyword2);</span></div><div class="token-line"><span class="token plain">        log.info(&quot;took {} ms result {}&quot;, System.currentTimeMillis() - begin, result);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>分别调用接口可以看到，<strong>ES耗时仅仅48ms，MySQL耗时6秒多是ES的100倍</strong>。很遗憾，虽然新闻分类ID已经建了索引，但是这个索引只能起到加速过滤分类ID这一单一条件的作用，对于文本内容的全文搜索，B+树索引无能为力。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[22:04:00.951] [http-nio-45678-exec-6] [INFO ] [o.g.t.c.n.esvsmyql.PerformanceController:48  ] - took 48 ms result 2100</span></div><div class="token-line"><span class="token plain">    Hibernate: select count(news0_.id) as col_0_0_ from news news0_ where news0_.cateid=? and (news0_.content like ? escape ?) and (news0_.content like ? escape ?)</span></div><div class="token-line"><span class="token plain">    [22:04:11.946] [http-nio-45678-exec-7] [INFO ] [o.g.t.c.n.esvsmyql.PerformanceController:39  ] - took 6637 ms result 2100</span></div></pre></div><p>但ES这种以索引为核心的数据库，也不是万能的，频繁更新就是一个大问题。</p><p>MySQL可以做到仅更新某行数据的某个字段，但ES里每次数据字段更新都相当于整个文档索引重建。即便ES提供了文档部分更新的功能，但本质上只是节省了提交文档的网络流量，以及减少了更新冲突，其内部实现还是文档删除后重新构建索引。因此，如果要在ES中保存一个类似计数器的值，要实现不断更新，其执行效率会非常低。</p><p>我们来验证下，分别使用JdbcTemplate+SQL语句、ElasticsearchTemplate+自定义UpdateQuery，实现部分更新MySQL表和ES索引的一个字段，每个方法都是循环更新1000次：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@GetMapping(&quot;mysql2&quot;)</span></div><div class="token-line"><span class="token plain">    public void mysql2(@RequestParam(value = &quot;id&quot;, defaultValue = &quot;400000&quot;) long id) {</span></div><div class="token-line"><span class="token plain">        long begin = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">        //对于MySQL，使用JdbcTemplate+SQL语句，实现直接更新某个category字段，更新1000次</span></div><div class="token-line"><span class="token plain">        IntStream.rangeClosed(1, 1000).forEach(i -&gt; {</span></div><div class="token-line"><span class="token plain">            jdbcTemplate.update(&quot;UPDATE `news` SET category=? WHERE id=?&quot;, new Object[]{&quot;test&quot; + i, id});</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">        log.info(&quot;mysql took {} ms result {}&quot;, System.currentTimeMillis() - begin, newsMySQLRepository.findById(id));</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @GetMapping(&quot;es2&quot;)</span></div><div class="token-line"><span class="token plain">    public void es(@RequestParam(value = &quot;id&quot;, defaultValue = &quot;400000&quot;) long id) {</span></div><div class="token-line"><span class="token plain">        long begin = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">        IntStream.rangeClosed(1, 1000).forEach(i -&gt; {</span></div><div class="token-line"><span class="token plain">            //对于ES，通过ElasticsearchTemplate+自定义UpdateQuery，实现文档的部分更新</span></div><div class="token-line"><span class="token plain">            UpdateQuery updateQuery = null;</span></div><div class="token-line"><span class="token plain">            try {</span></div><div class="token-line"><span class="token plain">                updateQuery = new UpdateQueryBuilder()</span></div><div class="token-line"><span class="token plain">                        .withIndexName(&quot;news&quot;)</span></div><div class="token-line"><span class="token plain">                        .withId(String.valueOf(id))</span></div><div class="token-line"><span class="token plain">                        .withType(&quot;_doc&quot;)</span></div><div class="token-line"><span class="token plain">                        .withUpdateRequest(new UpdateRequest().doc(</span></div><div class="token-line"><span class="token plain">                                jsonBuilder()</span></div><div class="token-line"><span class="token plain">                                        .startObject()</span></div><div class="token-line"><span class="token plain">                                        .field(&quot;category&quot;, &quot;test&quot; + i)</span></div><div class="token-line"><span class="token plain">                                        .endObject()))</span></div><div class="token-line"><span class="token plain">                        .build();</span></div><div class="token-line"><span class="token plain">            } catch (IOException e) {</span></div><div class="token-line"><span class="token plain">                e.printStackTrace();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            elasticsearchTemplate.update(updateQuery);</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">        log.info(&quot;es took {} ms result {}&quot;, System.currentTimeMillis() - begin, newsESRepository.findById(id).get());</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，<strong>MySQL耗时仅仅1.5秒，而ES耗时6.8秒</strong>：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage630263a583a0bced67a3f7cf0eb32e644802.9533dc0d.png" alt=""/></p><p>ES是一个分布式的全文搜索数据库，所以与MySQL相比的优势在于文本搜索，而且因为其分布式的特性，可以使用一个大ES集群处理大规模数据的内容搜索。但，由于ES的索引是文档维度的，所以不适用于频繁更新的OLTP业务。</p><p>一般而言，我们会把ES和MySQL结合使用，MySQL直接承担业务系统的增删改操作，而ES作为辅助数据库，直接扁平化保存一份业务数据，用于复杂查询、全文搜索和统计。接下来，我也会继续和你分析这一点。</p><h2 id="结合nosql和mysql应对高并发的复合数据库架构"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/03.设计篇/06#结合nosql和mysql应对高并发的复合数据库架构"><span class="icon icon-link"></span></a>结合NoSQL和MySQL应对高并发的复合数据库架构</h2><p>现在，我们通过一些案例看到了Redis、InfluxDB、ES这些NoSQL数据库，都有擅长和不擅长的场景。那么，有没有全能的数据库呢？</p><p>我认为没有。每一个存储系统都有其独特的数据结构，数据结构的设计就决定了其擅长和不擅长的场景。</p><p>比如，MySQL InnoDB引擎的B+树对排序和范围查询友好，频繁数据更新的代价不是太大，因此适合OLTP（On-Line Transaction Processing）。</p><p>又比如，ES的Lucene采用了FST（Finite State Transducer）索引+倒排索引，空间效率高，适合对变动不频繁的数据做索引，实现全文搜索。存储系统本身不可能对一份数据使用多种数据结构保存，因此不可能适用于所有场景。</p><p>虽然在大多数业务场景下，MySQL的性能都不算太差，但对于数据量大、访问量大、业务复杂的互联网应用来说，MySQL因为实现了ACID（原子性、一致性、隔离性、持久性）会比较重，而且横向扩展能力较差、功能单一，无法扛下所有数据量和流量，无法应对所有功能需求。因此，我们需要通过架构手段，来组合使用多种存储系统，取长补短，实现1+1&gt;2的效果。</p><p>我来举个例子。我们设计了一个<strong>包含多个数据库系统的、能应对各种高并发场景的一套数据服务的系统架构</strong>，其中包含了同步写服务、异步写服务和查询服务三部分，分别实现主数据库写入、辅助数据库写入和查询路由。</p><p>我们按照服务来依次分析下这个架构。</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimagebb38bbbcdbd74308de6b8fda04b34ed07e38.344d14d4.png" alt=""/></p><p>首先要明确的是，重要的业务主数据只能保存在MySQL这样的关系型数据库中，原因有三点：</p><ul><li>RDBMS经过了几十年的验证，已经非常成熟；</li><li>RDBMS的用户数量众多，Bug修复快、版本稳定、可靠性很高；</li><li>RDBMS强调ACID，能确保数据完整。</li></ul><p>有两种类型的查询任务可以交给MySQL来做，性能会比较好，这也是MySQL擅长的地方：</p><ul><li>按照主键ID的查询。直接查询聚簇索引，其性能会很高。但是单表数据量超过亿级后，性能也会衰退，而且单个数据库无法承受超大的查询并发，因此我们可以把数据表进行Sharding操作，均匀拆分到多个数据库实例中保存。我们把这套数据库集群称作Sharding集群。</li><li>按照各种条件进行范围查询，查出主键ID。对二级索引进行查询得到主键，只需要查询一棵B+树，效率同样很高。但索引的值不宜过大，比如对varchar(1000)进行索引不太合适，而索引外键（一般是int或bigint类型）性能就会比较好。因此，我们可以在MySQL中建立一张“索引表”，除了保存主键外，主要是保存各种关联表的外键，以及尽可能少的varchar类型的字段。这张索引表的大部分列都可以建上二级索引，用于进行简单搜索，搜索的结果是主键的列表，而不是完整的数据。由于索引表字段轻量并且数量不多（一般控制在10个以内），所以即便索引表没有进行Sharding拆分，问题也不会很大。</li></ul><p>如图上蓝色线所示，写入两种MySQL数据表和发送MQ消息的这三步，我们用一个<strong>同步写服务</strong>完成了。我在“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/234928">异步处理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”中提到，所有异步流程都需要补偿，这里的异步流程同样需要。只不过为了简洁，我在这里省略了补偿流程。</p><p>然后，如图中绿色线所示，有一个<strong>异步写服务</strong>，监听MQ的消息，继续完成辅助数据的更新操作。这里我们选用了ES和InfluxDB这两种辅助数据库，因此整个异步写数据操作有三步：</p><ol><li>MQ消息不一定包含完整的数据，甚至可能只包含一个最新数据的主键ID，我们需要根据ID从查询服务查询到完整的数据。</li><li>写入InfluxDB的数据一般可以按时间间隔进行简单聚合，定时写入InfluxDB。因此，这里会进行简单的客户端聚合，然后写入InfluxDB。</li><li>ES不适合在各索引之间做连接（Join）操作，适合保存扁平化的数据。比如，我们可以把订单下的用户、商户、商品列表等信息，作为内嵌对象嵌入整个订单JSON，然后把整个扁平化的JSON直接存入ES。</li></ol><p>对于数据写入操作，我们认为操作返回的时候同步数据一定是写入成功的，但是由于各种原因，异步数据写入无法确保立即成功，会有一定延迟，比如：</p><ul><li>异步消息丢失的情况，需要补偿处理；</li><li>写入ES的索引操作本身就会比较慢；</li><li>写入InfluxDB的数据需要客户端定时聚合。</li></ul><p>因此，对于<strong>查询服务</strong>，如图中红色线所示，我们需要根据一定的上下文条件（比如查询一致性要求、时效性要求、搜索的条件、需要返回的数据字段、搜索时间区间等）来把请求路由到合适的数据库，并且做一些聚合处理：</p><ul><li>需要根据主键查询单条数据，可以从MySQL Sharding集群或Redis查询，如果对实时性要求不高也可以从ES查询。</li><li>按照多个条件搜索订单的场景，可以从MySQL索引表查询出主键列表，然后再根据主键从MySQL Sharding集群或Redis获取数据详情。</li><li>各种后台系统需要使用比较复杂的搜索条件，甚至全文搜索来查询订单数据，或是定时分析任务需要一次查询大量数据，这些场景对数据实时性要求都不高，可以到ES进行搜索。此外，MySQL中的数据可以归档，我们可以在ES中保留更久的数据，而且查询历史数据一般并发不会很大，可以统一路由到ES查询。</li><li>监控系统或后台报表系统需要呈现业务监控图表或表格，可以把请求路由到InfluxDB查询。</li></ul><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/03.设计篇/06#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>今天，我通过三个案例分别对比了缓存数据库Redis、时间序列数据库InfluxDB、搜索数据库ES和MySQL的性能。我们看到：</p><ul><li>Redis对单条数据的读取性能远远高于MySQL，但不适合进行范围搜索。</li><li>InfluxDB对于时间序列数据的聚合效率远远高于MySQL，但因为没有主键，所以不是一个通用数据库。</li><li>ES对关键字的全文搜索能力远远高于MySQL，但是字段的更新效率较低，不适合保存频繁更新的数据。</li></ul><p>最后，我们给出了一个混合使用MySQL + Redis + InfluxDB + ES的架构方案，充分发挥了各种数据库的特长，相互配合构成了一个可以应对各种复杂查询，以及高并发读写的存储架构。</p><ul><li>主数据由两种MySQL数据表构成，其中索引表承担简单条件的搜索来得到主键，Sharding表承担大并发的主键查询。主数据由同步写服务写入，写入后发出MQ消息。</li><li>辅助数据可以根据需求选用合适的NoSQL，由单独一个或多个异步写服务监听MQ后异步写入。</li><li>由统一的查询服务，对接所有查询需求，根据不同的查询需求路由查询到合适的存储，确保每一个存储系统可以根据场景发挥所长，并分散各数据库系统的查询压力。</li></ul><p>今天用到的代码，我都放在了GitHub上，你可以点击<a target="_blank" rel="noopener noreferrer" href="https://github.com/JosephZhu1983/java-common-mistakes">这个链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>查看。</p><h2 id="思考与讨论"><a aria-hidden="true" tabindex="-1" href="/blog-java/java业务开发常见错误100例/03.设计篇/06#思考与讨论"><span class="icon icon-link"></span></a>思考与讨论</h2><ol><li>我们提到，InfluxDB不能包含太多tag。你能写一段测试代码，来模拟这个问题，并观察下InfluxDB的内存使用情况吗？</li><li>文档数据库MongoDB，也是一种常用的NoSQL。你觉得MongoDB的优势和劣势是什么呢？它适合用在什么场景下呢？</li></ol><p>关于数据存储，你还有其他心得吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把今天的内容分享给你的朋友或同事，一起交流。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/java业务开发常见错误100例/03.设计篇/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:06:36</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-java/umi.fde43fdb.js"></script>
  </body>
</html>
