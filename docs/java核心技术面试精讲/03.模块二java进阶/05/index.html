<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-test/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-test";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>第19讲 | Java并发包提供了哪些并发工具类？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/java核心技术面试精讲/03.模块二java进阶/05" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a aria-current="page" class="active" href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-test/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-test/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a aria-current="page" class="active" href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-test/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-test/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-test/java核心技术面试精讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog-test/java核心技术面试精讲/01.开篇词/01"><span>开篇词 | 以面试题为切入点，有效提升你的Java内功</span></a></li></ul></li><li><a href="/blog-test/java核心技术面试精讲/02.模块一java基础">02.模块一Java基础</a><ul><li><a href="/blog-test/java核心技术面试精讲/02.模块一java基础/01"><span>第1讲 | 谈谈你对Java平台的理解？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/02.模块一java基础/02"><span>第2讲 | Exception和Error有什么区别？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/02.模块一java基础/03"><span>第3讲 | 谈谈final、finally、 finalize有什么不同？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/02.模块一java基础/04"><span>第4讲 | 强引用、软引用、弱引用、幻象引用有什么区别？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/02.模块一java基础/05"><span>第5讲 | String、StringBuffer、StringBuilder有什么区别？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/02.模块一java基础/06"><span>第6讲 | 动态代理是基于什么原理？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/02.模块一java基础/07"><span>第7讲 | int和Integer有什么区别？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/02.模块一java基础/08"><span>第8讲 | 对比Vector、ArrayList、LinkedList有何区别？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/02.模块一java基础/09"><span>第9讲 | 对比Hashtable、HashMap、TreeMap有什么不同？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/02.模块一java基础/10"><span>第10讲 | 如何保证集合是线程安全的? ConcurrentHashMap如何实现高效地线程安全？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/02.模块一java基础/11"><span>第11讲 | Java提供了哪些IO方式？ NIO如何实现多路复用？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/02.模块一java基础/12"><span>第12讲 | Java有几种文件拷贝方式？哪一种最高效？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/02.模块一java基础/13"><span>第13讲 | 谈谈接口和抽象类有什么区别？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/02.模块一java基础/14"><span>第14讲 | 谈谈你知道的设计模式？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-test/java核心技术面试精讲/03.模块二java进阶">03.模块二Java进阶</a><ul><li><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/01"><span>第15讲 | synchronized和ReentrantLock有什么区别呢？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/02"><span>第16讲 | synchronized底层如何实现？什么是锁的升级、降级？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/03"><span>第17讲 | 一个线程两次调用start()方法会出现什么情况？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/04"><span>第18讲 | 什么情况下Java程序会产生死锁？如何定位、修复？</span></a></li><li><a aria-current="page" class="active" href="/blog-test/java核心技术面试精讲/03.模块二java进阶/05"><span>第19讲 | Java并发包提供了哪些并发工具类？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/06"><span>第20讲 | 并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/07"><span>第21讲 | Java并发类库提供的线程池有哪几种？ 分别有什么特点？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/08"><span>第22讲 | AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/09"><span>第23讲 | 请介绍类加载过程，什么是双亲委派模型？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/10"><span>第24讲 | 有哪些方法可以在运行时动态生成一个Java类？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/11"><span>第25讲 | 谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError?</span></a></li><li><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/12"><span>第26讲 | 如何监控和诊断JVM堆内和堆外内存使用？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/13"><span>第27讲 | Java常见的垃圾收集器有哪些？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/14"><span>第28讲 | 谈谈你的GC调优思路?</span></a></li><li><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/15"><span>第29讲 | Java内存模型中的happen-before是什么？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/16"><span>第30讲 | Java程序运行在Docker等容器环境有哪些新问题？</span></a></li></ul></li><li><a href="/blog-test/java核心技术面试精讲/04.模块三java安全基础">04.模块三Java安全基础</a><ul><li><a href="/blog-test/java核心技术面试精讲/04.模块三java安全基础/01"><span>第31讲 | 你了解Java应用开发中的注入攻击吗？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/04.模块三java安全基础/02"><span>第32讲 | 如何写出安全的Java代码？</span></a></li></ul></li><li><a href="/blog-test/java核心技术面试精讲/05.模块四java性能基础">05.模块四Java性能基础</a><ul><li><a href="/blog-test/java核心技术面试精讲/05.模块四java性能基础/01"><span>第33讲 | 后台服务出现明显“变慢”，谈谈你的诊断思路？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/05.模块四java性能基础/02"><span>第34讲 | 有人说“Lambda能让Java程序慢30倍”，你怎么看？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/05.模块四java性能基础/03"><span>第35讲 | JVM优化Java代码时都做了什么？</span></a></li></ul></li><li><a href="/blog-test/java核心技术面试精讲/06.模块5java应用开发扩展">06.模块5Java应用开发扩展</a><ul><li><a href="/blog-test/java核心技术面试精讲/06.模块5java应用开发扩展/01"><span>第36讲 | 谈谈MySQL支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/06.模块5java应用开发扩展/02"><span>第37讲 | 谈谈Spring Bean的生命周期和作用域？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/06.模块5java应用开发扩展/03"><span>第38讲 | 对比Java标准NIO类库，你知道Netty是如何实现更高性能的吗？</span></a></li><li><a href="/blog-test/java核心技术面试精讲/06.模块5java应用开发扩展/04"><span>第39讲 | 谈谈常用的分布式ID的设计方案？Snowflake是否受冬令时切换影响？</span></a></li></ul></li><li><a href="/blog-test/java核心技术面试精讲/07.周末福利">07.周末福利</a><ul><li><a href="/blog-test/java核心技术面试精讲/07.周末福利/01"><span>周末福利 | 谈谈我对Java学习和面试的看法</span></a></li><li><a href="/blog-test/java核心技术面试精讲/07.周末福利/02"><span>周末福利 | 一份Java工程师必读书单</span></a></li></ul></li><li><a href="/blog-test/java核心技术面试精讲/08.结束语">08.结束语</a><ul><li><a href="/blog-test/java核心技术面试精讲/08.结束语/01"><span>结束语 | 技术没有终点</span></a></li><li><a href="/blog-test/java核心技术面试精讲/08.结束语/02"><span>结课测试 | Java核心技术的这些知识，你真的掌握了吗？</span></a></li></ul></li><li><a href="/blog-test/java核心技术面试精讲/summary">java核心技术面试精讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="典型回答" data-depth="2"><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/05#典型回答"><span>典型回答</span></a></li><li title="考点分析" data-depth="2"><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/05#考点分析"><span>考点分析</span></a></li><li title="知识扩展" data-depth="2"><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/05#知识扩展"><span>知识扩展</span></a></li><li title="一课一练" data-depth="2"><a href="/blog-test/java核心技术面试精讲/03.模块二java进阶/05#一课一练"><span>一课一练</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="第19讲--java并发包提供了哪些并发工具类"><a aria-hidden="true" tabindex="-1" href="/blog-test/java核心技术面试精讲/03.模块二java进阶/05#第19讲--java并发包提供了哪些并发工具类"><span class="icon icon-link"></span></a>第19讲 | Java并发包提供了哪些并发工具类？</h1><p>通过前面的学习，我们一起回顾了线程、锁等各种并发编程的基本元素，也逐步涉及了Java并发包中的部分内容，相信经过前面的热身，我们能够更快地理解Java并发包。</p><p>今天我要问你的问题是，Java并发包提供了哪些并发工具类？</p><h2 id="典型回答"><a aria-hidden="true" tabindex="-1" href="/blog-test/java核心技术面试精讲/03.模块二java进阶/05#典型回答"><span class="icon icon-link"></span></a>典型回答</h2><p>我们通常所说的并发包也就是java.util.concurrent及其子包，集中了Java并发的各种基础工具类，具体主要包括几个方面：</p><ul><li><p>提供了比synchronized更加高级的各种同步结构，包括CountDownLatch、CyclicBarrier、Semaphore等，可以实现更加丰富的多线程操作，比如利用Semaphore作为资源控制器，限制同时进行工作的线程数量。</p></li><li><p>各种线程安全的容器，比如最常见的ConcurrentHashMap、有序的ConcurrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组CopyOnWriteArrayList等。</p></li><li><p>各种并发队列实现，如各种BlockingQueue实现，比较典型的ArrayBlockingQueue、 SynchronousQueue或针对特定场景的PriorityBlockingQueue等。</p></li><li><p>强大的Executor框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。</p></li></ul><h2 id="考点分析"><a aria-hidden="true" tabindex="-1" href="/blog-test/java核心技术面试精讲/03.模块二java进阶/05#考点分析"><span class="icon icon-link"></span></a>考点分析</h2><p>这个题目主要考察你对并发包了解程度，以及是否有实际使用经验。我们进行多线程编程，无非是达到几个目的：</p><ul><li><p>利用多线程提高程序的扩展能力，以达到业务对吞吐量的要求。</p></li><li><p>协调线程间调度、交互，以完成业务逻辑。</p></li><li><p>线程间传递数据和状态，这同样是实现业务逻辑的需要。</p></li></ul><p>所以，这道题目只能算作简单的开始，往往面试官还会进一步考察如何利用并发包实现某个特定的用例，分析实现的优缺点等。</p><p>如果你在这方面的基础比较薄弱，我的建议是：</p><ul><li><p>从总体上，把握住几个主要组成部分（前面回答中已经简要介绍）。</p></li><li><p>理解具体设计、实现和能力。</p></li><li><p>再深入掌握一些比较典型工具类的适用场景、用法甚至是原理，并熟练写出典型的代码用例。</p></li></ul><p>掌握这些通常就够用了，毕竟并发包提供了方方面面的工具，其实很少有机会能在应用中全面使用过，扎实地掌握核心功能就非常不错了。真正特别深入的经验，还是得靠在实际场景中踩坑来获得。</p><h2 id="知识扩展"><a aria-hidden="true" tabindex="-1" href="/blog-test/java核心技术面试精讲/03.模块二java进阶/05#知识扩展"><span class="icon icon-link"></span></a>知识扩展</h2><p>首先，我们来看看并发包提供的丰富同步结构。前面几讲已经分析过各种不同的显式锁，今天我将专注于</p><ul><li><p><a target="_blank" rel="noopener noreferrer" href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CountDownLatch.html">CountDownLatch<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，允许一个或多个线程等待某些操作完成。</p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CyclicBarrier.html">CyclicBarrier<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，一种辅助性的同步结构，允许多个线程等待到达某个屏障。</p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Semaphore.html">Semaphore<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，Java版本的信号量实现。</p></li></ul><p>Java提供了经典信号量（<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Semaphore_(programming)">Semaphore<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）的实现，它通过控制一定数量的允许（permit）的方式，来达到限制通用资源访问的目的。你可以想象一下这个场景，在车站、机场等出租车时，当很多空出租车就位时，为防止过度拥挤，调度员指挥排队等待坐车的队伍一次进来5个人上车，等这5个人坐车出发，再放进去下一批，这和Semaphore的工作原理有些类似。</p><p>你可以试试使用Semaphore来模拟实现这个调度过程：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import java.util.concurrent.Semaphore;</span></div><div class="token-line"><span class="token plain">    public class UsualSemaphoreSample {</span></div><div class="token-line"><span class="token plain">    	public static void main(String[] args) throws InterruptedException {</span></div><div class="token-line"><span class="token plain">        	System.out.println(&quot;Action...GO!&quot;);</span></div><div class="token-line"><span class="token plain">        	Semaphore semaphore = new Semaphore(5);</span></div><div class="token-line"><span class="token plain">        	for (int i = 0; i &lt; 10; i++) {</span></div><div class="token-line"><span class="token plain">            	Thread t = new Thread(new SemaphoreWorker(semaphore));</span></div><div class="token-line"><span class="token plain">            	t.start();</span></div><div class="token-line"><span class="token plain">        	}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    class SemaphoreWorker implements Runnable {</span></div><div class="token-line"><span class="token plain">    	private String name;</span></div><div class="token-line"><span class="token plain">    	private Semaphore semaphore;</span></div><div class="token-line"><span class="token plain">    	public SemaphoreWorker(Semaphore semaphore) {</span></div><div class="token-line"><span class="token plain">        	this.semaphore = semaphore;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	@Override</span></div><div class="token-line"><span class="token plain">    	public void run() {</span></div><div class="token-line"><span class="token plain">        	try {</span></div><div class="token-line"><span class="token plain">            	log(&quot;is waiting for a permit!&quot;);</span></div><div class="token-line"><span class="token plain">           	semaphore.acquire();</span></div><div class="token-line"><span class="token plain">            	log(&quot;acquired a permit!&quot;);</span></div><div class="token-line"><span class="token plain">            	log(&quot;executed!&quot;);</span></div><div class="token-line"><span class="token plain">        	} catch (InterruptedException e) {</span></div><div class="token-line"><span class="token plain">            	e.printStackTrace();</span></div><div class="token-line"><span class="token plain">        	} finally {</span></div><div class="token-line"><span class="token plain">            	log(&quot;released a permit!&quot;);</span></div><div class="token-line"><span class="token plain">            	semaphore.release();</span></div><div class="token-line"><span class="token plain">        	}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	private void log(String msg){</span></div><div class="token-line"><span class="token plain">        	if (name == null) {</span></div><div class="token-line"><span class="token plain">            	name = Thread.currentThread().getName();</span></div><div class="token-line"><span class="token plain">        	}</span></div><div class="token-line"><span class="token plain">        	System.out.println(name + &quot; &quot; + msg);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码是比较典型的Semaphore示例，其逻辑是，线程试图获得工作允许，得到许可则进行任务，然后释放许可，这时等待许可的其他线程，就可获得许可进入工作状态，直到全部处理结束。编译运行，我们就能看到Semaphore的允许机制对工作线程的限制。</p><p>但是，从具体节奏来看，其实并不符合我们前面场景的需求，因为本例中Semaphore的用法实际是保证，一直有5个人可以试图乘车，如果有1个人出发了，立即就有排队的人获得许可，而这并不完全符合我们前面的要求。</p><p>那么，我再修改一下，演示个非典型的Semaphore用法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import java.util.concurrent.Semaphore;</span></div><div class="token-line"><span class="token plain">    public class AbnormalSemaphoreSample {</span></div><div class="token-line"><span class="token plain">    	public static void main(String[] args) throws InterruptedException {</span></div><div class="token-line"><span class="token plain">        	Semaphore semaphore = new Semaphore(0);</span></div><div class="token-line"><span class="token plain">        	for (int i = 0; i &lt; 10; i++) {</span></div><div class="token-line"><span class="token plain">            	Thread t = new Thread(new MyWorker(semaphore));</span></div><div class="token-line"><span class="token plain">            	t.start();</span></div><div class="token-line"><span class="token plain">        	}</span></div><div class="token-line"><span class="token plain">        	System.out.println(&quot;Action...GO!&quot;);</span></div><div class="token-line"><span class="token plain">        	semaphore.release(5);</span></div><div class="token-line"><span class="token plain">        	System.out.println(&quot;Wait for permits off&quot;);</span></div><div class="token-line"><span class="token plain">        	while (semaphore.availablePermits()!=0) {</span></div><div class="token-line"><span class="token plain">            	Thread.sleep(100L);</span></div><div class="token-line"><span class="token plain">        	}</span></div><div class="token-line"><span class="token plain">        	System.out.println(&quot;Action...GO again!&quot;);</span></div><div class="token-line"><span class="token plain">        	semaphore.release(5);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    class MyWorker implements Runnable {</span></div><div class="token-line"><span class="token plain">    	private Semaphore semaphore;</span></div><div class="token-line"><span class="token plain">    	public MyWorker(Semaphore semaphore) {</span></div><div class="token-line"><span class="token plain">        	this.semaphore = semaphore;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	@Override</span></div><div class="token-line"><span class="token plain">    	public void run() {</span></div><div class="token-line"><span class="token plain">        	try {</span></div><div class="token-line"><span class="token plain">            	semaphore.acquire();</span></div><div class="token-line"><span class="token plain">            	System.out.println(&quot;Executed!&quot;);</span></div><div class="token-line"><span class="token plain">        	} catch (InterruptedException e) {</span></div><div class="token-line"><span class="token plain">            	e.printStackTrace();</span></div><div class="token-line"><span class="token plain">        	}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>注意，上面的代码，更侧重的是演示Semaphore的功能以及局限性，其实有很多线程编程中的反实践，比如使用了sleep来协调任务执行，而且使用轮询调用availalePermits来检测信号量获取情况，这都是很低效并且脆弱的，通常只是用在测试或者诊断场景。</p><p>总的来说，我们可以看出Semaphore就是个<strong>计数器</strong>，<strong>其基本逻辑基于acquire/release</strong>，并没有太复杂的同步逻辑。</p><p>如果Semaphore的数值被初始化为1，那么一个线程就可以通过acquire进入互斥状态，本质上和互斥锁是非常相似的。但是区别也非常明显，比如互斥锁是有持有者的，而对于Semaphore这种计数器结构，虽然有类似功能，但其实不存在真正意义的持有者，除非我们进行扩展包装。</p><p>下面，来看看CountDownLatch和CyclicBarrier，它们的行为有一定的相似度，经常会被考察二者有什么区别，我来简单总结一下。</p><ul><li><p>CountDownLatch是不可以重置的，所以无法重用；而CyclicBarrier则没有这种限制，可以重用。</p></li><li><p>CountDownLatch的基本操作组合是countDown/await。调用await的线程阻塞等待countDown足够的次数，不管你是在一个线程还是多个线程里countDown，只要次数足够即可。所以就像Brain Goetz说过的，CountDownLatch操作的是事件。</p></li><li><p>CyclicBarrier的基本操作组合，则就是await，当所有的伙伴（parties）都调用了await，才会继续进行任务，并自动进行重置。<strong>注意</strong>，正常情况下，CyclicBarrier的重置都是自动发生的，如果我们调用reset方法，但还有线程在等待，就会导致等待线程被打扰，抛出BrokenBarrierException异常。CyclicBarrier侧重点是线程，而不是调用事件，它的典型应用场景是用来等待并发线程结束。</p></li></ul><p>如果用CountDownLatch去实现上面的排队场景，该怎么做呢？假设有10个人排队，我们将其分成5个人一批，通过CountDownLatch来协调批次，你可以试试下面的示例代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import java.util.concurrent.CountDownLatch;</span></div><div class="token-line"><span class="token plain">    public class LatchSample {</span></div><div class="token-line"><span class="token plain">    	public static void main(String[] args) throws InterruptedException {</span></div><div class="token-line"><span class="token plain">        	CountDownLatch latch = new CountDownLatch(6);</span></div><div class="token-line"><span class="token plain">               for (int i = 0; i &lt; 5; i++) {</span></div><div class="token-line"><span class="token plain">                    Thread t = new Thread(new FirstBatchWorker(latch));</span></div><div class="token-line"><span class="token plain">                    t.start();</span></div><div class="token-line"><span class="token plain">        	}</span></div><div class="token-line"><span class="token plain">        	for (int i = 0; i &lt; 5; i++) {</span></div><div class="token-line"><span class="token plain">            	    Thread t = new Thread(new SecondBatchWorker(latch));</span></div><div class="token-line"><span class="token plain">            	    t.start();</span></div><div class="token-line"><span class="token plain">        	}</span></div><div class="token-line"><span class="token plain">               // 注意这里也是演示目的的逻辑，并不是推荐的协调方式</span></div><div class="token-line"><span class="token plain">        	while ( latch.getCount() != 1 ){</span></div><div class="token-line"><span class="token plain">            	    Thread.sleep(100L);</span></div><div class="token-line"><span class="token plain">        	}</span></div><div class="token-line"><span class="token plain">        	System.out.println(&quot;Wait for first batch finish&quot;);</span></div><div class="token-line"><span class="token plain">        	latch.countDown();</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    class FirstBatchWorker implements Runnable {</span></div><div class="token-line"><span class="token plain">    	private CountDownLatch latch;</span></div><div class="token-line"><span class="token plain">    	public FirstBatchWorker(CountDownLatch latch) {</span></div><div class="token-line"><span class="token plain">        	this.latch = latch;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	@Override</span></div><div class="token-line"><span class="token plain">    	public void run() {</span></div><div class="token-line"><span class="token plain">            	System.out.println(&quot;First batch executed!&quot;);</span></div><div class="token-line"><span class="token plain">            	latch.countDown();</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    class SecondBatchWorker implements Runnable {</span></div><div class="token-line"><span class="token plain">    	private CountDownLatch latch;</span></div><div class="token-line"><span class="token plain">    	public SecondBatchWorker(CountDownLatch latch) {</span></div><div class="token-line"><span class="token plain">        	this.latch = latch;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	@Override</span></div><div class="token-line"><span class="token plain">    	public void run() {</span></div><div class="token-line"><span class="token plain">        	try {</span></div><div class="token-line"><span class="token plain">            	latch.await();</span></div><div class="token-line"><span class="token plain">            	System.out.println(&quot;Second batch executed!&quot;);</span></div><div class="token-line"><span class="token plain">        	} catch (InterruptedException e) {</span></div><div class="token-line"><span class="token plain">            	e.printStackTrace();</span></div><div class="token-line"><span class="token plain">        	}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>CountDownLatch的调度方式相对简单，后一批次的线程进行await，等待前一批countDown足够多次。这个例子也从侧面体现出了它的局限性，虽然它也能够支持10个人排队的情况，但是因为不能重用，如果要支持更多人排队，就不能依赖一个CountDownLatch进行了。其编译运行输出如下：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUcAAADICAAAAABes3wOAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAACYktHRAD/h4/MvwAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAAd0SU1FB+cJGwEZGbM0WJoAAAABb3JOVAHPoneaAAAGEUlEQVR42u2dAY6bMBBFuW5v1aPM0brdBDwejwHDJyTRe9J2G2wG8wA7fFXq9PfPBALwqAGPGv57tB+SpnRj2uV3/6ZIKOs+dSvvOGRvtO1xdnTccbid/Hh8SHD1N87KdzX3O3RfylpTru6Z1Ful6WRpezytPZWO8/dPcfC8Pt37pmmvB9T1aOujHj2b9r5PP9/i0XuKIs3841uJWdpnX25k5WPZ3dczW6k3Vdch3L/J4X2/nz+roYR+v83+wJLn23tsRtqOKbTPbfOJP+fJecBxvJVYV7eq19SdwvHDtWruPysDCdfUQuHs8is9Nuez1Z7eN9HPyvjDPGtN3caju07ZxfAPgrsPc4+KGzKZH/0I/PiSFTe7HzOPm/dBUi/+TKFWnH+jx6RG9348j1+v/WWpD7Zc2KAoeuw+gPUEkXRP6/XLBo/ZOEY8Ku7HzkRbbq78trdK/zx51+os9K8m/GZZCvX8+hQ6LvNvdf0X74urcvl9yTIfLHVOazzxPqO5jtfVWz2QnBPvhZLreGG9lx6G92sNeNSARw141IBHDf/fZ6x809qxx9ZyJ1wOR4Z1M1X+2Blw2Nr02mrfS7tf5739DXl6TM6hPpkTn/fSC54+yaMbr3/dmn/FN7y03c0OTf/ipHpfK5vSOvZhHueBOg9tnuK81BlLL/+L3fPsoDlOm/N8gEZ/P/pYJwsHo5hyv9Td2gDCBQY+Hmg9T6H94zx6Y/3P1Ylv5X91Ee+x3t6r87Lc4mKP8Xlc87iWQ4481+n2j7D5+P74PGF7PNLu8/yXWmO7ILn+Fm+kjXWmV8dvv9vSHo93j+A7wKMGPGrAowY8asCjBjxqIH/UQP6ogfxRA/mj0GN5kV48kD8e8Ej+qPLojZE/Sj2SP455dLOjGfnjYY93j+A7wKMGPGrAowY8asCjBjxqIH/UQP6ogfxRA/mj0GN5kV48kD8e8Ej+qPLojZE/Sj2SP455dLOjGfnjYY93j+A7wKMGPGrAowY8asCjBjxqIH/UQP6ogfxRA/mj0GN5kV48kD8e8Ej+qPLojZE/Sj2SP455dLOjGfnjYY93j+A7wKMGPGrAowY8asCjBjxqIH/UQP6ogfxRA/mj0GN5kV48kD8e8Ej+qPLojZE/Sj2SP455dLOjGfnjYY93j+A7wKMGPGrAowY8asCjBjxq8P+f5kIvP9ubPF6UY3brx1jkIldrrHlsR7s6xNJ+TY7Zr7/rLriW1GP3PFYZbb8q17zbY5MLhuCvPFVZPNZv79eztL2MY6t+8x6Z7vc6j/GBSeMBH5OVXMGadr//7FKTY9b1s93zC/xij2Wg/bxsbbxtbiTNMWP96LE6zg0eY1414DFtT/aX5JibHv1x3sxjNj+NelTlmFseu/u92KN7Dt1K4U+jziXDqlG3X5BjtvXL/GJunbS7PIIAPGrAowY8asCjBjxqwKOG57/v2dfZ6q/Ftr/zOaz6Yv+WPPKeQ5HUaH64m3a/9Iv/WyH0eDQvXD2I2/QBHp+DTfM885/9ibjXx6WfVftP2YtlP+908Y+FcXyARz/77PlxXgbzwzyPaOqHOuUwb6zxsV6H1/36vDc9lvulOA2eJ1d/XjZ6xyt1SvsneIyORj3uzQ997GVT/3ixzi3xzUmPR57rvfnhyHOdH/edbbrvj911pjvfWb29WZ9iDru6zvTq+O1321r1CALwqAGPGvCoAY8a8KgBjxrIHzWQP2ogf9RA/qjy6Gcf8scTHskfJR7JH/UeyR+Pe+ytL3H+T+Y7q7c36xP5IwyCRw141IBHDXjUgEcNeNRA/qiB/FED+aMG8keVRz/7kD+e8Ej+KPFI/qj3SP543GNvfYnzfzLfWb29WZ/IH2EQPGrAowY8asCjBjxqwKMG8kcN5I8ayB81kD+qPPrZh/zxhEfyR4lH8ke9R/LH4x5760uc/5P5zurtzfpE/giD4FEDHjXgUQMeNeBRAx41kD9qIH/UQP6ogfxR5dHPPuSPJzySP0o8kj/qPZI/HvfYW1/i/J/Md1Zvb9Yn8kcYBI8a8KgBjxrwqAGPGvCoAY8a8KgBjxrwqAGPEv4BuEnwVyX/64AAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjMtMDktMjdUMDE6MjU6MjUrMDA6MDCxrL0HAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIzLTA5LTI3VDAxOjI1OjI1KzAwOjAwwPEFuwAAACh0RVh0ZGF0ZTp0aW1lc3RhbXAAMjAyMy0wOS0yN1QwMToyNToyNSswMDowMJfkJGQAAAAASUVORK5CYII=" alt=""/></p><p>在实际应用中的条件依赖，往往没有这么别扭，CountDownLatch用于线程间等待操作结束是非常简单普遍的用法。通过countDown/await组合进行通信是很高效的，通常不建议使用例子里那个循环等待方式。</p><p>如果用CyclicBarrier来表达这个场景呢？我们知道CyclicBarrier其实反映的是线程并行运行时的协调，在下面的示例里，从逻辑上，5个工作线程其实更像是代表了5个可以就绪的空车，而不再是5个乘客，对比前面CountDownLatch的例子更有助于我们区别它们的抽象模型，请看下面的示例代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import java.util.concurrent.BrokenBarrierException;</span></div><div class="token-line"><span class="token plain">    import java.util.concurrent.CyclicBarrier;</span></div><div class="token-line"><span class="token plain">    public class CyclicBarrierSample {</span></div><div class="token-line"><span class="token plain">    	public static void main(String[] args) throws InterruptedException {</span></div><div class="token-line"><span class="token plain">        	CyclicBarrier barrier = new CyclicBarrier(5, new Runnable() {</span></div><div class="token-line"><span class="token plain">            	@Override</span></div><div class="token-line"><span class="token plain">            	public void run() {</span></div><div class="token-line"><span class="token plain">                	System.out.println(&quot;Action...GO again!&quot;);</span></div><div class="token-line"><span class="token plain">            	}</span></div><div class="token-line"><span class="token plain">        	});</span></div><div class="token-line"><span class="token plain">        	for (int i = 0; i &lt; 5; i++) {</span></div><div class="token-line"><span class="token plain">            	Thread t = new Thread(new CyclicWorker(barrier));</span></div><div class="token-line"><span class="token plain">            	t.start();</span></div><div class="token-line"><span class="token plain">        	}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	static class CyclicWorker implements Runnable {</span></div><div class="token-line"><span class="token plain">        	private CyclicBarrier barrier;</span></div><div class="token-line"><span class="token plain">        	public CyclicWorker(CyclicBarrier barrier) {</span></div><div class="token-line"><span class="token plain">            	this.barrier = barrier;</span></div><div class="token-line"><span class="token plain">        	}</span></div><div class="token-line"><span class="token plain">        	@Override</span></div><div class="token-line"><span class="token plain">        	public void run() {</span></div><div class="token-line"><span class="token plain">            	try {</span></div><div class="token-line"><span class="token plain">                	for (int i=0; i&lt;3 ; i++){</span></div><div class="token-line"><span class="token plain">                    	System.out.println(&quot;Executed!&quot;);</span></div><div class="token-line"><span class="token plain">                    	barrier.await();</span></div><div class="token-line"><span class="token plain">                	}</span></div><div class="token-line"><span class="token plain">            	} catch (BrokenBarrierException e) {</span></div><div class="token-line"><span class="token plain">                	e.printStackTrace();</span></div><div class="token-line"><span class="token plain">            	} catch (InterruptedException e) {</span></div><div class="token-line"><span class="token plain">                	e.printStackTrace();</span></div><div class="token-line"><span class="token plain">            	}</span></div><div class="token-line"><span class="token plain">     	   }</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>为了让输出更能表达运行时序，我使用了CyclicBarrier特有的barrierAction，当屏障被触发时，Java会自动调度该动作。因为CyclicBarrier会<strong>自动</strong>进行重置，所以这个逻辑其实可以非常自然的支持更多排队人数。其编译输出如下：</p><p><img src="data:image/png;base64,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" alt=""/></p><p>Java并发类库还提供了<a target="_blank" rel="noopener noreferrer" href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Phaser.html">Phaser<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，功能与CountDownLatch很接近，但是它允许线程动态地注册到Phaser上面，而CountDownLatch显然是不能动态设置的。Phaser的设计初衷是，实现多个线程类似步骤、阶段场景的协调，线程注册等待屏障条件触发，进而协调彼此间行动，具体请参考这个<a target="_blank" rel="noopener noreferrer" href="http://www.baeldung.com/java-phaser">例子<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>接下来，我来梳理下并发包里提供的线程安全Map、List和Set。首先，请参考下面的类图。</p><p><img src="data:image/png;base64,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" alt=""/></p><p>你可以看到，总体上种类和结构还是比较简单的，如果我们的应用侧重于Map放入或者获取的速度，而不在乎顺序，大多推荐使用ConcurrentHashMap，反之则使用ConcurrentSkipListMap；如果我们需要对大量数据进行非常频繁地修改，ConcurrentSkipListMap也可能表现出优势。</p><p>我在前面的专栏，谈到了普通无顺序场景选择HashMap，有顺序场景则可以选择类似TreeMap等，但是为什么并发容器里面没有ConcurrentTreeMap呢？</p><p>这是因为TreeMap要实现高效的线程安全是非常困难的，它的实现基于复杂的红黑树。为保证访问效率，当我们插入或删除节点时，会移动节点进行平衡操作，这导致在并发场景中难以进行合理粒度的同步。而SkipList结构则要相对简单很多，通过层次结构提高访问速度，虽然不够紧凑，空间使用有一定提高（O(nlogn)），但是在增删元素时线程安全的开销要好很多。为了方便你理解SkipList的内部结构，我画了一个示意图。</p><p><img src="data:image/png;base64,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" alt=""/></p><p>关于两个CopyOnWrite容器，其实CopyOnWriteArraySet是通过包装了CopyOnWriteArrayList来实现的，所以在学习时，我们可以专注于理解一种。</p><p>首先，CopyOnWrite到底是什么意思呢？它的原理是，任何修改操作，如add、set、remove，都会拷贝原数组，修改后替换原来的数组，通过这种防御性的方式，实现另类的线程安全。请看下面的代码片段，我进行注释的地方，可以清晰地理解其逻辑。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public boolean add(E e) {</span></div><div class="token-line"><span class="token plain">    	synchronized (lock) {</span></div><div class="token-line"><span class="token plain">        	Object[] elements = getArray();</span></div><div class="token-line"><span class="token plain">        	int len = elements.length;</span></div><div class="token-line"><span class="token plain">               // 拷贝</span></div><div class="token-line"><span class="token plain">        	Object[] newElements = Arrays.copyOf(elements, len + 1);</span></div><div class="token-line"><span class="token plain">        	newElements[len] = e;</span></div><div class="token-line"><span class="token plain">               // 替换</span></div><div class="token-line"><span class="token plain">        	setArray(newElements);</span></div><div class="token-line"><span class="token plain">        	return true;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    final void setArray(Object[] a) {</span></div><div class="token-line"><span class="token plain">    	array = a;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>所以这种数据结构，相对比较适合读多写少的操作，不然修改的开销还是非常明显的。</p><p>今天我对Java并发包进行了总结，并且结合实例分析了各种同步结构和部分线程安全容器，希望对你有所帮助。</p><h2 id="一课一练"><a aria-hidden="true" tabindex="-1" href="/blog-test/java核心技术面试精讲/03.模块二java进阶/05#一课一练"><span class="icon icon-link"></span></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？留给你的思考题是，你使用过类似CountDownLatch的同步结构解决实际问题吗？谈谈你的使用场景和心得。</p><p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习奖励礼券，欢迎你与我一起讨论。</p><p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/java核心技术面试精讲/03.模块二Java进阶/05.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 09:43:57</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-test/umi.3ded5539.js"></script>
  </body>
</html>
