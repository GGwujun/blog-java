<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-test/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-test";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>24 | 字段访问相关优化 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/深入拆解java虚拟机/04.模块三代码优化/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a aria-current="page" class="active" href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-test/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-test/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a aria-current="page" class="active" href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-test/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-test/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li><li><a href="/blog-test/深入拆解java虚拟机/01.开篇词">01.开篇词</a><ul><li><a href="/blog-test/深入拆解java虚拟机/01.开篇词/01"><span>开篇词 | 为什么我们要学习Java虚拟机？</span></a></li></ul></li><li><a href="/blog-test/深入拆解java虚拟机/02.模块一java虚拟机基本原理">02.模块一Java虚拟机基本原理</a><ul><li><a href="/blog-test/深入拆解java虚拟机/02.模块一java虚拟机基本原理/01"><span>01 | Java代码是怎么运行的？</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/02.模块一java虚拟机基本原理/02"><span>02 | Java的基本类型</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/02.模块一java虚拟机基本原理/03"><span>03 | Java虚拟机是如何加载Java类的?</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/02.模块一java虚拟机基本原理/04"><span>04 | JVM是如何执行方法调用的？（上）</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/02.模块一java虚拟机基本原理/05"><span>05 | JVM是如何执行方法调用的？（下）</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/02.模块一java虚拟机基本原理/06"><span>06 | JVM是如何处理异常的？</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/02.模块一java虚拟机基本原理/07"><span>07 | JVM是如何实现反射的？</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/02.模块一java虚拟机基本原理/08"><span>08 | JVM是怎么实现invokedynamic的？（上）</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/02.模块一java虚拟机基本原理/09"><span>09 | JVM是怎么实现invokedynamic的？（下）</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/02.模块一java虚拟机基本原理/10"><span>10 | Java对象的内存布局</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/02.模块一java虚拟机基本原理/11"><span>11 | 垃圾回收（上）</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/02.模块一java虚拟机基本原理/12"><span>12 | 垃圾回收（下）</span></a></li></ul></li><li><a href="/blog-test/深入拆解java虚拟机/03.模块二高效编译">03.模块二高效编译</a><ul><li><a href="/blog-test/深入拆解java虚拟机/03.模块二高效编译/01"><span>【工具篇】 常用工具介绍</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/03.模块二高效编译/02"><span>13 | Java内存模型</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/03.模块二高效编译/03"><span>14 | Java虚拟机是怎么实现synchronized的？</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/03.模块二高效编译/04"><span>15 | Java语法糖与Java编译器</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/03.模块二高效编译/05"><span>16 | 即时编译（上）</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/03.模块二高效编译/06"><span>17 | 即时编译（下）</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/03.模块二高效编译/07"><span>18 | 即时编译器的中间表达形式</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/03.模块二高效编译/08"><span>19 |  Java字节码（基础篇）</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/03.模块二高效编译/09"><span>20 | 方法内联（上）</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/03.模块二高效编译/10"><span>21 | 方法内联（下）</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/03.模块二高效编译/11"><span>22 | HotSpot虚拟机的intrinsic</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/03.模块二高效编译/12"><span>23 | 逃逸分析</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-test/深入拆解java虚拟机/04.模块三代码优化">04.模块三代码优化</a><ul><li><a aria-current="page" class="active" href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/01"><span>24 | 字段访问相关优化</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/02"><span>25 | 循环优化</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/03"><span>26 | 向量化</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/04"><span>27 | 注解处理器</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/05"><span>28 | 基准测试框架JMH（上）</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/06"><span>29 | 基准测试框架JMH（下）</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/07"><span>30 | Java虚拟机的监控及诊断工具（命令行篇）</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/08"><span>31 | Java虚拟机的监控及诊断工具（GUI篇）</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/09"><span>32 | JNI的运行机制</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/10"><span>33 | Java Agent与字节码注入</span></a></li></ul></li><li><a href="/blog-test/深入拆解java虚拟机/05.模块四黑科技">05.模块四黑科技</a><ul><li><a href="/blog-test/深入拆解java虚拟机/05.模块四黑科技/01"><span>34 | Graal：用Java编译Java</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/05.模块四黑科技/02"><span>35 | Truffle：语言实现框架</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/05.模块四黑科技/03"><span>36 | SubstrateVM：AOT编译框架</span></a></li></ul></li><li><a href="/blog-test/深入拆解java虚拟机/06.尾声">06.尾声</a><ul><li><a href="/blog-test/深入拆解java虚拟机/06.尾声/01"><span>尾声 | 道阻且长，努力加餐</span></a></li><li><a href="/blog-test/深入拆解java虚拟机/06.尾声/02"><span>结课测试 | 这些Java虚拟机的知识你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-test/深入拆解java虚拟机/summary">深入拆解java虚拟机</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="字段读取优化" data-depth="2"><a href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/01#字段读取优化"><span>字段读取优化</span></a></li><li title="字段存储优化" data-depth="2"><a href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/01#字段存储优化"><span>字段存储优化</span></a></li><li title="死代码消除" data-depth="2"><a href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/01#死代码消除"><span>死代码消除</span></a></li><li title="总结与实践" data-depth="2"><a href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/01#总结与实践"><span>总结与实践</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="24--字段访问相关优化"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/01#24--字段访问相关优化"><span class="icon icon-link"></span></a>24 | 字段访问相关优化</h1><p>在上一篇文章中，我介绍了逃逸分析，也介绍了基于逃逸分析的优化方式锁消除、栈上分配以及标量替换等内容。</p><p>其中的标量替换，可以看成将对象本身拆散为一个个字段，并把原本对对象字段的访问，替换为对一个个局部变量的访问。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class Foo {</span></div><div class="token-line"><span class="token plain">      int a = 0;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static int bar(int x) {</span></div><div class="token-line"><span class="token plain">      Foo foo = new Foo();</span></div><div class="token-line"><span class="token plain">      foo.a = x;</span></div><div class="token-line"><span class="token plain">      return foo.a;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>举个例子，上面这段代码中的<code>bar</code>方法，经过逃逸分析以及标量替换后，其优化结果如下所示。（确切地说，是指所生成的IR图与下述代码所生成的IR图类似。之后不再重复解释。）</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int bar(int x) {</span></div><div class="token-line"><span class="token plain">      int a = x;</span></div><div class="token-line"><span class="token plain">      return a;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>由于Sea-of-Nodes IR的特性，局部变量不复存在，取而代之的是一个个值。在例子对应的IR图中，返回节点将直接返回所输入的参数。</p><p><img src="data:image/png;base64,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" alt=""/></p><p><strong>经过标量替换的<code>bar</code>方法</strong></p><p>下面我列举了<code>bar</code>方法经由C2即时编译生成的机器码（这里略去了指令地址的前48位）。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># {method} &#x27;bar&#x27; &#x27;(I)I&#x27; in &#x27;FieldAccessTest&#x27;</span></div><div class="token-line"><span class="token plain">      # parm0:    rsi       = int             // 参数x</span></div><div class="token-line"><span class="token plain">      #           [sp+0x20]  (sp of caller)</span></div><div class="token-line"><span class="token plain">    0x06a0: sub    rsp,0x18                   // 创建方法栈桢</span></div><div class="token-line"><span class="token plain">    0x06a7: mov    QWORD PTR [rsp+0x10],rbp   // 无关指令</span></div><div class="token-line"><span class="token plain">    0x06ac: mov    eax,esi                    // 将参数x存入返回值eax中</span></div><div class="token-line"><span class="token plain">    0x06ae: add    rsp,0x10                   // 弹出方法栈桢</span></div><div class="token-line"><span class="token plain">    0x06b2: pop    rbp                        // 无关指令</span></div><div class="token-line"><span class="token plain">    0x06b3: mov    r10,QWORD PTR [r15+0x70]   // 安全点测试</span></div><div class="token-line"><span class="token plain">    0x06b7: test   DWORD PTR [r10],eax        // 安全点测试</span></div><div class="token-line"><span class="token plain">    0x06ba: ret</span></div></pre></div><blockquote><p>在X86_64的机器码中，每当使用call指令进入目标方法的方法体中时，我们需要在栈上为当前方法分配一块内存作为其栈桢。而在退出该方法时，我们需要弹出当前方法所使用的栈桢。</p></blockquote><blockquote><p>由于寄存器rsp维护着当前线程的栈顶指针，因此这些操作都是通过增减寄存器rsp来实现的，即上面这段机器码中偏移量为0x06a0以及0x06ae的指令。</p></blockquote><blockquote><p>在介绍安全点（safepoint）时我曾介绍过，HotSpot虚拟机的即时编译器将在方法返回时插入安全点测试指令，即图中偏移量为0x06b3以及0x06ba的指令。其中真正的安全点测试是0x06b7指令。</p></blockquote><blockquote><p>如果虚拟机需要所有线程都到达安全点，那么该test指令所访问的内存地址所在的页将被标记为不可访问，而该指令也将触发segfault，并借由segfault处理器进入安全点之中。通常，该指令会附带<code>; <!-- -->{<!-- -->poll_return<!-- -->}</code>这样子的注释，这里被我略去了。</p></blockquote><blockquote><p>在X8_64中，前几个传入参数会被放置于寄存器中，而返回值则需要存放在rax寄存器中。有时候你会看到返回值被存入eax寄存器中，这其实是同一个寄存器，只不过rax表示64位寄存器，而eax表示32位寄存器。具体可以参考x86 calling conventions[1]。</p></blockquote><p>当忽略掉创建、弹出方法栈桢，安全点测试以及其他无关指令之后，所剩下的方法体就只剩下偏移量为0x06ac的mov指令，以及0x06ba的ret指令。前者将所传入的int型参数x移至代表返回值的eax寄存器中，后者是退出当前方法并返回至调用者中。</p><p>虽然在部分情况下，逃逸分析以及基于逃逸分析的优化已经十分高效了，能够将代码优化到极其简单的地步，但是逃逸分析毕竟不是Java虚拟机的银色子弹。</p><p>在现实中，Java程序中的对象或许本身便是逃逸的，或许因为方法内联不够彻底而被即时编译器当成是逃逸的。这两种情况都将导致即时编译器无法进行标量替换。这时候，针对对象字段访问的优化也变得格外重要起来。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int bar(Foo o, int x) {</span></div><div class="token-line"><span class="token plain">      o.a = x;</span></div><div class="token-line"><span class="token plain">      return o.a;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在上面这段代码中，对象<code>o</code>是传入参数，不属于逃逸分析的范围（Java虚拟机中的逃逸分析针对的是新建对象）。该方法会将所传入的int型参数<code>x</code>的值存储至实例字段<code>Foo.a</code>中，然后再读取并返回同一字段的值。</p><p>这段代码将涉及两次内存访问操作：存储以及读取实例字段<code>Foo.a</code>。我们可以轻易地将其手工优化为直接读取并返回传入参数x的值。由于这段代码较为简单，因此它极大可能被编译为寄存器之间的移动指令（即将输入参数<code>x</code>的值移至寄存器eax中）。这与原本的内存访问指令相比，显然要高效得多。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int bar(Foo o, int x) {</span></div><div class="token-line"><span class="token plain">      o.a = x;</span></div><div class="token-line"><span class="token plain">      return x;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>那么即时编译器是否能够作出类似的自动优化呢？</p><h2 id="字段读取优化"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/01#字段读取优化"><span class="icon icon-link"></span></a>字段读取优化</h2><p>答案是可以的。即时编译器会优化实例字段以及静态字段访问，以减少总的内存访问数目。具体来说，它将沿着控制流，缓存各个字段存储节点将要存储的值，或者字段读取节点所得到的值。</p><p>当即时编译器遇到对同一字段的读取节点时，如果缓存值还没有失效，那么它会将读取节点替换为该缓存值。</p><p>当即时编译器遇到对同一字段的存储节点时，它会更新所缓存的值。当即时编译器遇到可能更新字段的节点时，如方法调用节点（在即时编译器看来，方法调用会执行未知代码），或者内存屏障节点（其他线程可能异步更新了字段），那么它会采取保守的策略，舍弃所有缓存值。</p><p>在前面的例子中，我们见识了缓存字段存储节点的情况。下面我们来看一下缓存字段读取节点的情况。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int bar(Foo o, int x) {</span></div><div class="token-line"><span class="token plain">      int y = o.a + x;</span></div><div class="token-line"><span class="token plain">      return o.a + y;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在上面这段代码中，实例字段<code>Foo.a</code>将被读取两次。即时编译器会将第一次读取的值缓存起来，并且替换第二次字段读取操作，以节省一次内存访问。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int bar(Foo o, int x) {</span></div><div class="token-line"><span class="token plain">      int t = o.a;</span></div><div class="token-line"><span class="token plain">      int y = t + x;</span></div><div class="token-line"><span class="token plain">      return t + y;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果字段读取节点被替换成一个常量，那么它将进一步触发更多优化。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int bar(Foo o, int x) {</span></div><div class="token-line"><span class="token plain">      o.a = 1;</span></div><div class="token-line"><span class="token plain">      if (o.a &gt;= 0)</span></div><div class="token-line"><span class="token plain">        return x;</span></div><div class="token-line"><span class="token plain">      else</span></div><div class="token-line"><span class="token plain">        return -x;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>例如在上面这段代码中，实例字段<code>Foo.a</code>会被赋值为1。接下来的if语句将判断同一实例字段是否不小于0。经过字段读取优化之后，<code>&gt;=</code>节点的两个输入参数分别为常数1和0，因此可以直接替换为具体结果<code>true</code>。如此一来，else分支将变成不可达代码，可以直接删除，其优化结果如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int bar(Foo o, int x) {</span></div><div class="token-line"><span class="token plain">      o.a = 1;</span></div><div class="token-line"><span class="token plain">      return x;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们再来看另一个例子。下面这段代码的<code>bar</code>方法中，实例字段<code>a</code>会被赋值为<code>true</code>，后面紧跟着一个以<code>a</code>为条件的while循环。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class Foo {</span></div><div class="token-line"><span class="token plain">      boolean a;</span></div><div class="token-line"><span class="token plain">      void bar() {</span></div><div class="token-line"><span class="token plain">        a = true;</span></div><div class="token-line"><span class="token plain">        while (a) {}</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      void whatever() { a = false; }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>同样，即时编译器会将while循环中读取实例字段<code>a</code>的操作直接替换为常量<code>true</code>，即下面代码所示的死循环。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void bar() {</span></div><div class="token-line"><span class="token plain">        a = true;</span></div><div class="token-line"><span class="token plain">        while (true) {}</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    // 生成的机器码将陷入这一死循环中</span></div><div class="token-line"><span class="token plain">    0x066b: mov    r11,QWORD PTR [r15+0x70] // 安全点测试</span></div><div class="token-line"><span class="token plain">    0x066f: test   DWORD PTR [r11],eax      // 安全点测试</span></div><div class="token-line"><span class="token plain">    0x0672: jmp    0x066b                   // while (true)</span></div></pre></div><p>在介绍Java内存模型时，我们便知道可以通过volatile关键字标记实例字段<code>a</code>，以此强制对它的读取。</p><p>实际上，即时编译器将在volatile字段访问前后插入内存屏障节点。这些内存屏障节点会阻止即时编译器将屏障之前所缓存的值用于屏障之后的读取节点之上。</p><p>就我们的例子而言，尽管在X86_64平台上，volatile字段读取操作前后的内存屏障是no-op，在即时编译过程中的屏障节点，还是会阻止即时编译器的字段读取优化，强制在循环中使用内存读取指令访问实例字段<code>Foo.a</code>的最新值。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">0x00e0: movzx  r11d,BYTE PTR [rbx+0xc]   // 读取a</span></div><div class="token-line"><span class="token plain">    0x00e5: mov    r10,QWORD PTR [r15+0x70]  // 安全点测试</span></div><div class="token-line"><span class="token plain">    0x00e9: test   DWORD PTR [r10],eax       // 安全点测试</span></div><div class="token-line"><span class="token plain">    0x00ec: test   r11d,r11d                 // while (a)</span></div><div class="token-line"><span class="token plain">    0x00ef: jne    0x00e0                    // while (a)</span></div></pre></div><p>同理，加锁、解锁操作也同样会阻止即时编译器的字段读取优化。</p><h2 id="字段存储优化"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/01#字段存储优化"><span class="icon icon-link"></span></a>字段存储优化</h2><p>除了字段读取优化之外，即时编译器还将消除冗余的存储节点。如果一个字段先后被存储了两次，而且这两次存储之间没有对第一次存储内容的读取，那么即时编译器可以将第一个字段存储给消除掉。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class Foo {</span></div><div class="token-line"><span class="token plain">      int a = 0;</span></div><div class="token-line"><span class="token plain">      void bar() {</span></div><div class="token-line"><span class="token plain">        a = 1;</span></div><div class="token-line"><span class="token plain">        a = 2;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>举例来说，上面这段代码中的<code>bar</code>方法先后存储了两次<code>Foo.a</code>实例字段。由于第一次存储之后没有读取<code>Foo.a</code>的值，因此，即时编译器会将其看成冗余存储，并将之消除掉，生成如下代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void bar() {</span></div><div class="token-line"><span class="token plain">        a = 2;</span></div><div class="token-line"><span class="token plain">      }</span></div></pre></div><p>实际上，即便是在这两个字段存储操作之间读取该字段，即时编译器还是有可能在字段读取优化的帮助下，将第一个存储操作当成冗余存储给消除掉。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class Foo {</span></div><div class="token-line"><span class="token plain">      int a = 0;</span></div><div class="token-line"><span class="token plain">      void bar() {</span></div><div class="token-line"><span class="token plain">        a = 1;</span></div><div class="token-line"><span class="token plain">        int t = a;</span></div><div class="token-line"><span class="token plain">        a = t + 2;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 优化为</span></div><div class="token-line"><span class="token plain">    class Foo {</span></div><div class="token-line"><span class="token plain">      int a = 0;</span></div><div class="token-line"><span class="token plain">      void bar() {</span></div><div class="token-line"><span class="token plain">        a = 1;</span></div><div class="token-line"><span class="token plain">        int t = 1;</span></div><div class="token-line"><span class="token plain">        a = t + 2;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 进一步优化为</span></div><div class="token-line"><span class="token plain">    class Foo {</span></div><div class="token-line"><span class="token plain">      int a = 0;</span></div><div class="token-line"><span class="token plain">      void bar() {</span></div><div class="token-line"><span class="token plain">        a = 3;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>当然，如果所存储的字段被标记为volatile，那么即时编译器也不能将冗余的存储操作消除掉。</p><p>这种情况看似很蠢，但实际上并不少见，比如说两个存储之间隔着许多其他代码，或者因为方法内联的缘故，将两个存储操作（如构造器中字段的初始化以及随后的更新）纳入同一个编译单元里。</p><h2 id="死代码消除"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/01#死代码消除"><span class="icon icon-link"></span></a>死代码消除</h2><p>除了字段存储优化之外，局部变量的死存储（dead store）同样也涉及了冗余存储。这是死代码消除（dead code eliminiation）的一种。不过，由于Sea-of-Nodes IR的特性，死存储的优化无须额外代价。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int bar(int x, int y) {</span></div><div class="token-line"><span class="token plain">      int t = x*y;</span></div><div class="token-line"><span class="token plain">      t = x+y;</span></div><div class="token-line"><span class="token plain">      return t;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面这段代码涉及两个存储局部变量操作。当即时编译器将其转换为Sea-of-Nodes IR之后，没有节点依赖于t的第一个值<code>x*y</code>。因此，该乘法运算将被消除，其结果如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int bar(int x, int y) {</span></div><div class="token-line"><span class="token plain">      return x+y;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>死存储还有一种变体，即在部分程序路径上有冗余存储。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int bar(boolean f, int x, int y) {</span></div><div class="token-line"><span class="token plain">      int t = x*y;</span></div><div class="token-line"><span class="token plain">      if (f)</span></div><div class="token-line"><span class="token plain">        t = x+y;</span></div><div class="token-line"><span class="token plain">      return t;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>举个例子，上面这段代码中，如果所传入的boolean类型的参数<code>f</code>是<code>true</code>，那么在程序执行路径上将先后进行两次对局部变量<code>t</code>的存储。</p><p>同样，经过Sea-of-Nodes IR转换之后，返回节点所依赖的值是一个phi节点，将根据程序路径选择<code>x+y</code>或者<code>x*y</code>。也就是说，当<code>f</code>为<code>true</code>的程序路径上的乘法运算会被消除，其结果如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int bar(boolean f, int x, int y) {</span></div><div class="token-line"><span class="token plain">      int t;</span></div><div class="token-line"><span class="token plain">      if (f)</span></div><div class="token-line"><span class="token plain">        t = x+y;</span></div><div class="token-line"><span class="token plain">      else</span></div><div class="token-line"><span class="token plain">        t = x*y;</span></div><div class="token-line"><span class="token plain">      return t;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>另一种死代码消除则是不可达分支消除。不可达分支就是任何程序路径都不可到达的分支，我们之前已经多次接触过了。</p><p>在即时编译过程中，我们经常因为方法内联、常量传播以及基于profile的优化等，生成许多不可达分支。通过消除不可达分支，即时编译器可以精简数据流，并且减少编译时间以及最终生成机器码的大小。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int bar(int x) {</span></div><div class="token-line"><span class="token plain">      if (false)</span></div><div class="token-line"><span class="token plain">        return x;</span></div><div class="token-line"><span class="token plain">      else</span></div><div class="token-line"><span class="token plain">        return -x;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>举个例子，在上面的代码中，if语句将一直跳转至else分支之中。因此，另一不可达分支可以直接消除掉，形成下面的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int bar(int x) {</span></div><div class="token-line"><span class="token plain">      return -x;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="总结与实践"><a aria-hidden="true" tabindex="-1" href="/blog-test/深入拆解java虚拟机/04.模块三代码优化/01#总结与实践"><span class="icon icon-link"></span></a>总结与实践</h2><p>今天我介绍了即时编译器关于字段访问的优化方式，以及死代码消除。</p><p>即时编译器将沿着控制流缓存字段存储、读取的值，并在接下来的字段读取操作时直接使用该缓存值。</p><p>这要求生成缓存值的访问以及使用缓存值的读取之间没有方法调用、内存屏障，或者其他可能存储该字段的节点。</p><p>即时编译器还会优化冗余的字段存储操作。如果一个字段的两次存储之间没有对该字段的读取操作、方法调用以及内存屏障，那么即时编译器可以将第一个冗余的存储操作给消除掉。</p><p>此外，我还介绍了死代码消除的两种形式。第一种是局部变量的死存储消除以及部分死存储消除。它们可以通过转换为Sea-of-Nodes IR来完成。第二种则是不可达分支。通过消除不可达分支，即时编译器可以精简数据流，并且减少编译时间以及最终生成机器码的大小。</p><p>今天的实践环节，请思考即时编译器会怎么优化下面代码中的除法操作？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int bar(int x, int y) {</span></div><div class="token-line"><span class="token plain">      int t = x/y;</span></div><div class="token-line"><span class="token plain">      t = x+y;</span></div><div class="token-line"><span class="token plain">      return t;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>[1] <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/深入拆解java虚拟机/04.模块三代码优化/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 09:43:57</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-test/umi.3ded5539.js"></script>
  </body>
</html>
