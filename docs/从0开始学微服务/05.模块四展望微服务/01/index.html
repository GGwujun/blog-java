<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-java/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-java";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>33 | 下一代微服务架构Service Mesh - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/从0开始学微服务/05.模块四展望微服务/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a aria-current="page" class="active" href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a aria-current="page" class="active" href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li><li><a href="/blog-java/从0开始学微服务/01.开篇词">01.开篇词</a><ul><li><a href="/blog-java/从0开始学微服务/01.开篇词/01"><span>开篇词 | 微服务，从放弃到入门</span></a></li></ul></li><li><a href="/blog-java/从0开始学微服务/02.模块一入门微服务">02.模块一入门微服务</a><ul><li><a href="/blog-java/从0开始学微服务/02.模块一入门微服务/01"><span>01 | 到底什么是微服务？</span></a></li><li><a href="/blog-java/从0开始学微服务/02.模块一入门微服务/02"><span>02 | 从单体应用走向服务化</span></a></li><li><a href="/blog-java/从0开始学微服务/02.模块一入门微服务/03"><span>03 | 初探微服务架构</span></a></li><li><a href="/blog-java/从0开始学微服务/02.模块一入门微服务/04"><span>04 | 如何发布和引用服务？</span></a></li><li><a href="/blog-java/从0开始学微服务/02.模块一入门微服务/05"><span>05 | 如何注册和发现服务？</span></a></li><li><a href="/blog-java/从0开始学微服务/02.模块一入门微服务/06"><span>06 | 如何实现RPC远程服务调用？</span></a></li><li><a href="/blog-java/从0开始学微服务/02.模块一入门微服务/07"><span>07 | 如何监控微服务调用？</span></a></li><li><a href="/blog-java/从0开始学微服务/02.模块一入门微服务/08"><span>08 | 如何追踪微服务调用？</span></a></li><li><a href="/blog-java/从0开始学微服务/02.模块一入门微服务/09"><span>09 | 微服务治理的手段有哪些？</span></a></li><li><a href="/blog-java/从0开始学微服务/02.模块一入门微服务/10"><span>10 | Dubbo框架里的微服务组件</span></a></li></ul></li><li><a href="/blog-java/从0开始学微服务/03.模块二落地微服务">03.模块二落地微服务</a><ul><li><a href="/blog-java/从0开始学微服务/03.模块二落地微服务/01"><span>11 | 服务发布和引用的实践</span></a></li><li><a href="/blog-java/从0开始学微服务/03.模块二落地微服务/02"><span>12 | 如何将注册中心落地？</span></a></li><li><a href="/blog-java/从0开始学微服务/03.模块二落地微服务/03"><span>13 | 开源服务注册中心如何选型？</span></a></li><li><a href="/blog-java/从0开始学微服务/03.模块二落地微服务/04"><span>14 | 开源RPC框架如何选型？</span></a></li><li><a href="/blog-java/从0开始学微服务/03.模块二落地微服务/05"><span>15 | 如何搭建一个可靠的监控系统？</span></a></li><li><a href="/blog-java/从0开始学微服务/03.模块二落地微服务/06"><span>16 | 如何搭建一套适合你的服务追踪系统？</span></a></li><li><a href="/blog-java/从0开始学微服务/03.模块二落地微服务/07"><span>17 | 如何识别服务节点是否存活？</span></a></li><li><a href="/blog-java/从0开始学微服务/03.模块二落地微服务/08"><span>18 | 如何使用负载均衡算法？</span></a></li><li><a href="/blog-java/从0开始学微服务/03.模块二落地微服务/09"><span>19 | 如何使用服务路由？</span></a></li><li><a href="/blog-java/从0开始学微服务/03.模块二落地微服务/10"><span>20 | 服务端出现故障时该如何应对？</span></a></li><li><a href="/blog-java/从0开始学微服务/03.模块二落地微服务/11"><span>21 | 服务调用失败时有哪些处理手段？</span></a></li><li><a href="/blog-java/从0开始学微服务/03.模块二落地微服务/12"><span>22 | 如何管理服务配置？</span></a></li><li><a href="/blog-java/从0开始学微服务/03.模块二落地微服务/13"><span>23 | 如何搭建微服务治理平台？</span></a></li><li><a href="/blog-java/从0开始学微服务/03.模块二落地微服务/14"><span>24 | 微服务架构该如何落地？</span></a></li></ul></li><li><a href="/blog-java/从0开始学微服务/04.模块三进阶微服务">04.模块三进阶微服务</a><ul><li><a href="/blog-java/从0开始学微服务/04.模块三进阶微服务/01"><span>25 | 微服务为什么要容器化？</span></a></li><li><a href="/blog-java/从0开始学微服务/04.模块三进阶微服务/02"><span>26 | 微服务容器化运维：镜像仓库和资源调度</span></a></li><li><a href="/blog-java/从0开始学微服务/04.模块三进阶微服务/03"><span>27 | 微服务容器化运维：容器调度和服务编排</span></a></li><li><a href="/blog-java/从0开始学微服务/04.模块三进阶微服务/04"><span>28 | 微服务容器化运维：微博容器运维平台DCP</span></a></li><li><a href="/blog-java/从0开始学微服务/04.模块三进阶微服务/05"><span>29 | 微服务如何实现DevOps？</span></a></li><li><a href="/blog-java/从0开始学微服务/04.模块三进阶微服务/06"><span>30 | 如何做好微服务容量规划？</span></a></li><li><a href="/blog-java/从0开始学微服务/04.模块三进阶微服务/07"><span>31 | 微服务多机房部署实践</span></a></li><li><a href="/blog-java/从0开始学微服务/04.模块三进阶微服务/08"><span>32 | 微服务混合云部署实践</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-java/从0开始学微服务/05.模块四展望微服务">05.模块四展望微服务</a><ul><li><a aria-current="page" class="active" href="/blog-java/从0开始学微服务/05.模块四展望微服务/01"><span>33 | 下一代微服务架构Service Mesh</span></a></li><li><a href="/blog-java/从0开始学微服务/05.模块四展望微服务/02"><span>34 | Istio：Service Mesh的代表产品</span></a></li><li><a href="/blog-java/从0开始学微服务/05.模块四展望微服务/03"><span>35 | 微博Service Mesh实践之路（上）</span></a></li><li><a href="/blog-java/从0开始学微服务/05.模块四展望微服务/04"><span>36 | 微博Service Mesh实践之路（下）</span></a></li></ul></li><li><a href="/blog-java/从0开始学微服务/06.阿忠伯的特别放送">06.阿忠伯的特别放送</a><ul><li><a href="/blog-java/从0开始学微服务/06.阿忠伯的特别放送/01"><span>阿忠伯的特别放送 | 答疑解惑01</span></a></li><li><a href="/blog-java/从0开始学微服务/06.阿忠伯的特别放送/02"><span>阿忠伯的特别放送 | 答疑解惑02</span></a></li><li><a href="/blog-java/从0开始学微服务/06.阿忠伯的特别放送/03"><span>微博技术解密（上） | 微博信息流是如何实现的？</span></a></li><li><a href="/blog-java/从0开始学微服务/06.阿忠伯的特别放送/04"><span>微博技术解密（下）| 微博存储的那些事儿</span></a></li></ul></li><li><a href="/blog-java/从0开始学微服务/07.结束语">07.结束语</a><ul><li><a href="/blog-java/从0开始学微服务/07.结束语/01"><span>结束语 | 微服务，从入门到精通</span></a></li></ul></li><li><a href="/blog-java/从0开始学微服务/08.结课测试">08.结课测试</a><ul><li><a href="/blog-java/从0开始学微服务/08.结课测试/01"><span>结课测试｜这些微服务知识你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-java/从0开始学微服务/summary">从0开始学微服务</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="什么是Service Mesh？" data-depth="2"><a href="/blog-java/从0开始学微服务/05.模块四展望微服务/01#什么是service-mesh"><span>什么是Service Mesh？</span></a></li><li title="Service Mesh的实现原理" data-depth="2"><a href="/blog-java/从0开始学微服务/05.模块四展望微服务/01#service-mesh的实现原理"><span>Service Mesh的实现原理</span></a></li><li title="总结" data-depth="2"><a href="/blog-java/从0开始学微服务/05.模块四展望微服务/01#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-java/从0开始学微服务/05.模块四展望微服务/01#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="33--下一代微服务架构service-mesh"><a aria-hidden="true" tabindex="-1" href="/blog-java/从0开始学微服务/05.模块四展望微服务/01#33--下一代微服务架构service-mesh"><span class="icon icon-link"></span></a>33 | 下一代微服务架构Service Mesh</h1><p>今天我们将进入专栏最后一个模块，我会和你聊聊下一代微服务架构Service Mesh。说到Service Mesh，在如今的微服务领域可谓是无人不知、无人不晓，被很多人定义为下一代的微服务架构。那么究竟什么是Service Mesh？Service Mesh是如何实现的？今天我就来给你解答这些疑问。</p><h2 id="什么是service-mesh"><a aria-hidden="true" tabindex="-1" href="/blog-java/从0开始学微服务/05.模块四展望微服务/01#什么是service-mesh"><span class="icon icon-link"></span></a>什么是Service Mesh？</h2><p>Service Mesh的概念最早是由Buoyant公司的CEO William Morgan在一篇<a target="_blank" rel="noopener noreferrer" href="https://blog.buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/">文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里提出，他给出的服务网格的定义是：</p><blockquote><p>A service mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery of requests through the complex topology of services that comprise a modern, cloud native application. In practice, the service mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code, without the application needing to be aware.</p></blockquote><p>专栏里我就不解释教条的定义了，感兴趣的话你可以点击链接阅读原文，这里我来谈谈我对Service Mesh的理解。我认为是Service Mesh是一种新型的用于处理服务与服务之间通信的技术，尤其适用以云原生应用形式部署的服务，能够保证服务与服务之间调用的可靠性。在实际部署时，Service Mesh通常以轻量级的网络代理的方式跟应用的代码部署在一起，从而以应用无感知的方式实现服务治理。</p><p>从我的理解来看，Service Mesh以轻量级的网络代理的方式与应用的代码部署在一起，用于保证服务与服务之间调用的可靠性，这与传统的微服务架构有着本质的区别，在我看来这么做主要是出于两个原因。</p><p>1.跨语言服务调用的需要。在大多数公司内通常都存在多个业务团队，每个团队业务所采用的开发语言一般都不相同，以微博的业务为例，移动服务端的业务主要采用的是PHP语言开发，API平台的业务主要采用的是Java语言开发，移动服务端调用API平台使用的是HTTP请求，如果要进行服务化，改成RPC调用，就需要一种既支持PHP语言又支持支持Java语言的的服务化框架。在专栏第14期我给你讲解了几种开源的服务化框架，它们要么与特定的语言绑定，比如Dubbo和Spring Cloud只支持Java语言，要么是跟语言无关，比如gRPC和Thrift，得定义个IDL文件，然后根据这个IDL文件生成客户端和服务端各自语言的SDK，并且服务框架的功能比如超时重试、负载均衡、服务发现等，都需要在各个语言的SDK中实现一遍，开发成本很高。</p><p>2.云原生应用服务治理的需要。在专栏前面，我给你讲解了微服务越来越多开始容器化，并使用Kubernetes类似的容器平台对服务进行管理，逐步朝云原生应用的方向进化。而传统的服务治理要求在业务代码里集成服务框架的SDK，这显然与云原生应用的理念相悖，因此迫切需要一种对业务代码无侵入的适合云原生应用的服务治理方式。</p><p>在这种背景下，Buoyant公司开发的第一代Service Mesh产品<a target="_blank" rel="noopener noreferrer" href="https://linkerd.io/">L<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><a target="_blank" rel="noopener noreferrer" href="https://linkerd.io/">inkerd<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>应运而生。从下图中你可以看到，服务A要调用服务B，经过Linkerd来代理转发，服务A和服务B的业务代码不需要关心服务框架功能的实现。为此Linkerd需要具备负载均衡、熔断、超时重试、监控统计以及服务路由等功能。这样的话，对于跨语言服务调用来说，即使服务消费者和服务提供者采用的语言不同，也不需要集成各自语言的SDK。</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage2670269ca9676c98e6b9ed831d38fdd67d70.789aac3e.png" alt=""/><br/>（图片来源：<a target="_blank" rel="noopener noreferrer" href="https://linkerd.io/images/what_it_does@2x.png">https://linkerd.io/images/what_it_does@2x.png<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p><p>而对于云原生应用来说，可以在每个服务部署的实例上，都同等的部署一个Linkerd实例。比如下面这张图，服务A要想调用服务B，首先调用本地的Linkerd实例，经过本地的Linked实例转发给服务B所在节点上的Linkerd实例，最后再由服务B本地的Linkerd实例把请求转发给服务B。这样的话，所有的服务调用都得经过Linkerd进行代理转发，所有的Linkerd组合起来就像一个网格一样，这也是为什么我们把这项技术称为Service Mesh，也就是“服务网格”的原因。</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimagef42bf4b75f2f1c4c72e51f626e331f06cf2b.e7bd2d07.png" alt=""/><br/>（图片来源：<a target="_blank" rel="noopener noreferrer" href="https://buoyant.io/wp-content/uploads/2017/04/linkerd-service-mesh-diagram-1024x587.png">https://buoyant.io/wp-content/uploads/2017/04/linkerd-service-mesh-diagram-1024x587.png<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p><h2 id="service-mesh的实现原理"><a aria-hidden="true" tabindex="-1" href="/blog-java/从0开始学微服务/05.模块四展望微服务/01#service-mesh的实现原理"><span class="icon icon-link"></span></a>Service Mesh的实现原理</h2><p>根据我的理解，Service Mesh实现的关键就在于两点：一个是上面提到的轻量级的网络代理也叫SideCar，它的作用就是转发服务之间的调用；一个是基于SideCar的服务治理也被叫作Control Plane，它的作用是向SideCar发送各种指令，以完成各种服务治理功能。下面我就来详细讲解这两点是如何实现的。</p><p>1.SideCar</p><p>我们首先来看一下，在传统的微服务架构下服务调用的原理。你可以看下面这张图，服务消费者这边除了自身的业务逻辑实现外，还需要集成部分服务框架的逻辑，比如服务发现、负载均衡、熔断降级、封装调用等，而服务提供者这边除了实现服务的业务逻辑外，也要集成部分服务框架的逻辑，比如线程池、限流降级、服务注册等。</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage10921070a53f237a8ef75845f49b71961292.8a5100bc.png" alt=""/></p><p>而在Service Mesh架构中，服务框架的功能都集中实现在SideCar里，并在每一个服务消费者和服务提供者的本地都部署一个SideCar，服务消费者和服务提供者只管自己的业务实现，服务消费者向本地的SideCar发起请求，本地的SideCar根据请求的路径向注册中心查询，得到服务提供者的可用节点列表后，再根据负载均衡策略选择一个服务提供者节点，并向这个节点上的SideCar转发请求，服务提供者节点上的SideCar完成流量统计、限流等功能后，再把请求转发给本地部署的服务提供者进程，从而完成一次服务请求。整个流程你可以参考下面这张图。</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimageda6ddaa8dee489e51238f450b51a53c1016d.1dd30721.png" alt=""/></p><p>我们可以把服务消费者节点上的SideCar叫作正向代理，服务提供者节点上的SideCar叫作反向代理，那么Service Mesh架构的关键点就在于服务消费者发出的请求如何通过正向代理转发以及服务提供者收到的请求如何通过反向代理转发。从我的经验来看，主要有两种实现方案。</p><ul><li>基于iptables的网络拦截。这种方案请见下图，节点A上服务消费者发出的TCP请求都会被拦截，然后发送给正向代理监听的端口15001，正向代理处理完成后再把请求转发到节点B的端口9080。节点B端口9080上的所有请求都会被拦截发送给反向代理监听的端口15001，反向代理处理完后再转发给本机上服务提供者监听的端口9080。</li></ul><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage433e438e7dbbd0fe9ba9434834837c712b3e.91a722ac.png" alt=""/></p><ul><li>采用协议转换的方式。这种方案请见下图，节点A上的服务消费者请求直接发给正向代理监听的端口15001，正向代理处理完成后，再把请求转发到节点B上反向代理监听的端口15001，反向代理处理完成后再发送给本机上的服务提供者监听的端口9080。</li></ul><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimagec7afc7c5785653da63d2174714f66a7f88af.24b1a183.png" alt=""/></p><p>可见，这两种方案最大的不同之处在于，一个是通过iptables网络拦截实现代理转发的，一个是靠直接把请求发送给代理来转发的。基于iptables网络拦截的方式，理论上会有一定的性能损耗，但它的优点是从网络层实现调用拦截，能做到完全的业务无感知，所以适合云原生应用。而直接把请求发送给代理的方式，要求代理层加入业务逻辑，才能把请求转发给对应的服务提供者监听的端口。</p><p>2.Control Plane</p><p>既然SideCar能实现服务之间的调用拦截功能，那么服务之间的所有流量都可以通过SideCar来转发，这样的话所有的SideCar就组成了一个服务网格，再通过一个统一的地方与各个SideCar交互，就能控制网格中流量的运转了，这个统一的地方就在Sevice Mesh中就被称为Control Plane。如下图所示，Control Plane的主要作用包括以下几个方面：</p><ul><li><p>服务发现。服务提供者会通过SideCar注册到Control Plane的注册中心，这样的话服务消费者把请求发送给SideCar后，SideCar就会查询Control Plane的注册中心来获取服务提供者节点列表。</p></li><li><p>负载均衡。SideCar从Control Plane获取到服务提供者节点列表信息后，就需要按照一定的负载均衡算法从可用的节点列表中选取一个节点发起调用，可以通过Control Plane动态修改SideCar中的负载均衡配置。</p></li><li><p>请求路由。SideCar从Control Plane获取的服务提供者节点列表，也可以通过Control Plane来动态改变，比如需要进行A/B测试、灰度发布或者流量切换时，就可以动态地改变请求路由。</p></li><li><p>故障处理。服务之间的调用如果出现故障，就需要加以控制，通常的手段有超时重试、熔断等，这些都可以在SideCar转发请求时，通过Control Plane动态配置。</p></li><li><p>安全认证。可以通过Control Plane控制一个服务可以被谁访问，以及访问哪些信息。</p></li><li><p>监控上报。所有SideCar转发的请求信息，都会发送到Control Plane，再由Control Plane发送给监控系统，比如Prometheus等。</p></li><li><p>日志记录。所有SideCar转发的日志信息，也会发送到Control Plane，再由Control Plane发送给日志系统，比如Stackdriver等。</p></li><li><p>配额控制。可以在Control Plane里给服务的每个调用方配置最大调用次数，在SideCar转发请求给某个服务时，会审计调用是否超出服务对应的次数限制。</p></li></ul><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage7462746ba12fff2b184157b00ac44ec2e862.9c3edbdb.png" alt=""/></p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-java/从0开始学微服务/05.模块四展望微服务/01#总结"><span class="icon icon-link"></span></a>总结</h2><p>今天我给你讲解了什么是Service Mesh，以及Service Mesh的实现原理。简单来说，Service Mesh思想的孕育而生，一方面出于各大公司微服务技术的普及，增加了对跨语言服务调用的需求；另一方面得益于微服务容器化后，采用Kubernetes等云平台部署的云原生应用越来越多，服务治理的需求也越来越强烈。Service Mesh通过SideCar代理转发请求，把服务框架的相关实现全部集中到SideCar中，并通过Control Plane控制SideCar来实现服务治理的各种功能，这种业务与框架功能解耦的思想恰好能够解决上面两个问题。</p><p>Service Mesh在诞生不到两年的时间里取得令人瞩目的发展，在国内外都涌现出一批具有代表性的新产品，最著名的莫过于Google、IBM领导的Istio，也是Service Mesh技术的代表之作，我会在下一期给你详细讲解。而国内在这一方面也不遑多让，秉承了Service Mesh的思想也走出了各自的实践之路，并且已经开始在线上的核心业务中大规模使用，比如微博的Weibo Mesh、华为公有云Service Mesh以及蚂蚁金服的SOFA Mesh等。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-java/从0开始学微服务/05.模块四展望微服务/01#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>Service Mesh中SideCar的部署模式是在每个服务节点的本地，都同等部署一个SideCar实例，为什么不使用集中式的部署模式，让多个服务节点访问一个SideCar实例？</p><p>欢迎你在留言区写下自己的思考，与我一起讨论。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/从0开始学微服务/05.模块四展望微服务/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:06:36</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-java/umi.fde43fdb.js"></script>
  </body>
</html>
