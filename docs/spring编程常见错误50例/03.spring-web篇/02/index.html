<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-test/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-test";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>09｜Spring Web URL 解析常见错误 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/spring编程常见错误50例/03.spring-web篇/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a aria-current="page" class="active" href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-test/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-test/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a aria-current="page" class="active" href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-test/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-test/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-test/spring编程常见错误50例/01.课前必读">01.课前必读</a><ul><li><a href="/blog-test/spring编程常见错误50例/01.课前必读/01"><span>开篇词｜贴心“保姆”Spring罢工了怎么办？</span></a></li></ul></li><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇">02.SpringCore篇</a><ul><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/01"><span>导读｜5分钟轻松了解Spring基础知识</span></a></li><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/02"><span>01｜Spring Bean 定义常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/03"><span>02｜Spring Bean 依赖注入常见错误（上）</span></a></li><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/04"><span>03｜Spring Bean 依赖注入常见错误（下）</span></a></li><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/05"><span>04｜Spring Bean 生命周期常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/06"><span>05｜Spring AOP 常见错误（上）</span></a></li><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/07"><span>06｜Spring AOP 常见错误（下）</span></a></li><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/08"><span>07｜Spring事件常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/09"><span>08｜答疑现场：Spring Core 篇思考题合集</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-test/spring编程常见错误50例/03.spring-web篇">03.SpringWeb篇</a><ul><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/01"><span>导读｜5分钟轻松了解一个HTTP请求的处理过程</span></a></li><li><a aria-current="page" class="active" href="/blog-test/spring编程常见错误50例/03.spring-web篇/02"><span>09｜Spring Web URL 解析常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/03"><span>10 | Spring Web Header 解析常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/04"><span>11 | Spring Web Body 转化常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/05"><span>12｜Spring Web 参数验证常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/06"><span>13 | Spring Web 过滤器使用常见错误（上）</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/07"><span>14 | Spring Web 过滤器使用常见错误（下）</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/08"><span>15 | Spring Security 常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/09"><span>16｜Spring Exception 常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/10"><span>17｜答疑现场：Spring Web 篇思考题合集</span></a></li></ul></li><li><a href="/blog-test/spring编程常见错误50例/04.spring补充篇">04.Spring补充篇</a><ul><li><a href="/blog-test/spring编程常见错误50例/04.spring补充篇/01"><span>18 | Spring Data 常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/04.spring补充篇/02"><span>19 | Spring 事务常见错误（上）</span></a></li><li><a href="/blog-test/spring编程常见错误50例/04.spring补充篇/03"><span>20 | Spring 事务常见错误（下）</span></a></li><li><a href="/blog-test/spring编程常见错误50例/04.spring补充篇/04"><span>21 | Spring Rest Template 常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/04.spring补充篇/05"><span>22 | Spring Test 常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/04.spring补充篇/06"><span>23｜答疑现场：Spring 补充篇思考题合集</span></a></li><li><a href="/blog-test/spring编程常见错误50例/04.spring补充篇/07"><span>知识回顾 | 系统梳理Spring编程错误根源</span></a></li></ul></li><li><a href="/blog-test/spring编程常见错误50例/05.结束语">05.结束语</a><ul><li><a href="/blog-test/spring编程常见错误50例/05.结束语/01"><span>结束语｜问题总比解决办法多</span></a></li></ul></li><li><a href="/blog-test/spring编程常见错误50例/06.期末测试">06.期末测试</a><ul><li><a href="/blog-test/spring编程常见错误50例/06.期末测试/01"><span>期末测试｜来赴一场100分之约！</span></a></li></ul></li><li><a href="/blog-test/spring编程常见错误50例/summary">spring编程常见错误50例</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="案例 1：当@PathVariable 遇到 /" data-depth="2"><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#案例-1当pathvariable-遇到-"><span>案例 1：当@PathVariable 遇到 /</span></a></li><li title="案例解析" data-depth="3"><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#案例解析"><span>案例解析</span></a></li><li title="问题修正" data-depth="3"><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#问题修正"><span>问题修正</span></a></li><li title="案例 2：错误使用@RequestParam、@PathVarible 等注解" data-depth="2"><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#案例-2错误使用requestparampathvarible-等注解"><span>案例 2：错误使用@RequestParam、@PathVarible 等注解</span></a></li><li title="案例解析" data-depth="3"><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#案例解析-1"><span>案例解析</span></a></li><li title="问题修正" data-depth="3"><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#问题修正-1"><span>问题修正</span></a></li><li title="案例 3：未考虑参数是否可选" data-depth="2"><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#案例-3未考虑参数是否可选"><span>案例 3：未考虑参数是否可选</span></a></li><li title="案例解析" data-depth="3"><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#案例解析-2"><span>案例解析</span></a></li><li title="问题修正" data-depth="3"><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#问题修正-2"><span>问题修正</span></a></li><li title="案例 4：请求参数格式错误" data-depth="2"><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#案例-4请求参数格式错误"><span>案例 4：请求参数格式错误</span></a></li><li title="案例解析" data-depth="3"><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#案例解析-3"><span>案例解析</span></a></li><li title="问题修正" data-depth="3"><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#问题修正-3"><span>问题修正</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#重点回顾"><span>重点回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="09spring-web-url-解析常见错误"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#09spring-web-url-解析常见错误"><span class="icon icon-link"></span></a>09｜Spring Web URL 解析常见错误</h1><p>你好，我是傅健。</p><p>上一章节我们讲解了各式各样的错误案例，这些案例都是围绕 Spring 的核心功能展开的，例如依赖注入、AOP 等诸多方面。然而，从现实情况来看，在使用上，我们更多地是使用 Spring 来构建一个 Web 服务，所以从这节课开始，我们会重点解析在 Spring Web 开发中经常遇到的一些错误，帮助你规避这些问题。</p><p>不言而喻，这里说的 Web 服务就是指使用 HTTP 协议的服务。而对于 HTTP 请求，首先要处理的就是 URL，所以今天我们就先来介绍下，在 URL 的处理上，Spring 都有哪些经典的案例。闲话少叙，下面我们直接开始演示吧。</p><h2 id="案例-1当pathvariable-遇到-"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#案例-1当pathvariable-遇到-"><span class="icon icon-link"></span></a>案例 1：当@PathVariable 遇到 /</h2><p>在解析一个 URL 时，我们经常会使用 @PathVariable 这个注解。例如我们会经常见到如下风格的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RestController</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class HelloWorldController {</span></div><div class="token-line"><span class="token plain">        @RequestMapping(path = &quot;/hi1/{name}&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">        public String hello1(@PathVariable(&quot;name&quot;) String name){</span></div><div class="token-line"><span class="token plain">            return name;</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">        };  </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>当我们使用 <a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi1/xiaoming">http://localhost:8080/hi1/xiaoming<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 访问这个服务时，会返回&quot;xiaoming&quot;，即 Spring 会把 name 设置为 URL 中对应的值。</p><p>看起来顺风顺水，但是假设这个 name 中含有特殊字符/时（例如<a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi1/xiaoming">http://localhost:8080/hi1/xiao/ming<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ），会如何？如果我们不假思索，或许答案是&quot;xiao/ming&quot;？然而稍微敏锐点的程序员都会判定这个访问是会报错的，具体错误参考：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage926492a3c8894b88eec937139f3c858bf664.3bc9c371.png" alt=""/></p><p>如图所示，当 name 中含有/，这个接口不会为 name 获取任何值，而是直接报Not Found错误。当然这里的“找不到”并不是指name找不到，而是指服务于这个特殊请求的接口。</p><p>实际上，这里还存在另外一种错误，即当 name 的字符串以/结尾时，/会被自动去掉。例如我们访问 <a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi1/xiaoming/">http://localhost:8080/hi1/xiaoming/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，Spring 并不会报错，而是返回xiaoming。</p><p>针对这两种类型的错误，应该如何理解并修正呢？</p><h3 id="案例解析"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#案例解析"><span class="icon icon-link"></span></a>案例解析</h3><p>实际上，这两种错误都是 URL 匹配执行方法的相关问题，所以我们有必要先了解下 URL 匹配执行方法的大致过程。参考 AbstractHandlerMethodMapping#lookupHandlerMethod：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Nullable</span></div><div class="token-line"><span class="token plain">    protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {</span></div><div class="token-line"><span class="token plain">       List&lt;Match&gt; matches = new ArrayList&lt;&gt;();</span></div><div class="token-line"><span class="token plain">       //尝试按照 URL 进行精准匹配</span></div><div class="token-line"><span class="token plain">       List&lt;T&gt; directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath);</span></div><div class="token-line"><span class="token plain">       if (directPathMatches != null) {</span></div><div class="token-line"><span class="token plain">          //精确匹配上，存储匹配结果</span></div><div class="token-line"><span class="token plain">          addMatchingMappings(directPathMatches, matches, request);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       if (matches.isEmpty()) {</span></div><div class="token-line"><span class="token plain">          //没有精确匹配上，尝试根据请求来匹配</span></div><div class="token-line"><span class="token plain">          addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       if (!matches.isEmpty()) {</span></div><div class="token-line"><span class="token plain">          Comparator&lt;Match&gt; comparator = new MatchComparator(getMappingComparator(request));</span></div><div class="token-line"><span class="token plain">          matches.sort(comparator);</span></div><div class="token-line"><span class="token plain">          Match bestMatch = matches.get(0);</span></div><div class="token-line"><span class="token plain">          if (matches.size() &gt; 1) {</span></div><div class="token-line"><span class="token plain">             //处理多个匹配的情况</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          //省略其他非关键代码</span></div><div class="token-line"><span class="token plain">          return bestMatch.handlerMethod;</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       else {</span></div><div class="token-line"><span class="token plain">          //匹配不上，直接报错</span></div><div class="token-line"><span class="token plain">          return handleNoMatch(this.mappingRegistry.getMappings().keySet(), lookupPath, request);</span></div><div class="token-line"><span class="token plain">       }</span></div></pre></div><p>大体分为这样几个基本步骤。</p><p><strong>1. 根据 Path 进行精确匹配</strong></p><p>这个步骤执行的代码语句是&quot;this.mappingRegistry.getMappingsByUrl(lookupPath)&quot;，实际上，它是查询 MappingRegistry#urlLookup，它的值可以用调试视图查看，如下图所示：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimaged580d579a4557a06ef8a0ba960ed05184b80.776a94bf.png" alt=""/></p><p>查询 urlLookup 是一个精确匹配 Path 的过程。很明显，<a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi1/xiaoming">http://localhost:8080/hi1/xiao/ming<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的 lookupPath 是&quot;/hi1/xiao/ming&quot;，并不能得到任何精确匹配。这里需要补充的是，&quot;/hi1/<!-- -->{<!-- -->name<!-- -->}<!-- -->&quot;这种定义本身也没有出现在 urlLookup 中。</p><p><strong>2. 假设 Path 没有精确匹配上，则执行模糊匹配</strong></p><p>在步骤 1 匹配失败时，会根据请求来尝试模糊匹配，待匹配的匹配方法可参考下图：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage1d2b1da52225336ec68451471ac4de36db2b.f6c0f52e.png" alt=""/></p><p>显然，&quot;/hi1/<!-- -->{<!-- -->name<!-- -->}<!-- -->&quot;这个匹配方法已经出现在待匹配候选中了。具体匹配过程可以参考方法 RequestMappingInfo#getMatchingCondition：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public RequestMappingInfo getMatchingCondition(HttpServletRequest request) {</span></div><div class="token-line"><span class="token plain">       RequestMethodsRequestCondition methods = this.methodsCondition.getMatchingCondition(request);</span></div><div class="token-line"><span class="token plain">       if (methods == null) {</span></div><div class="token-line"><span class="token plain">          return null;</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       ParamsRequestCondition params = this.paramsCondition.getMatchingCondition(request);</span></div><div class="token-line"><span class="token plain">       if (params == null) {</span></div><div class="token-line"><span class="token plain">          return null;</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       //省略其他匹配条件</span></div><div class="token-line"><span class="token plain">       PatternsRequestCondition patterns = this.patternsCondition.getMatchingCondition(request);</span></div><div class="token-line"><span class="token plain">       if (patterns == null) {</span></div><div class="token-line"><span class="token plain">          return null;</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       //省略其他匹配条件</span></div><div class="token-line"><span class="token plain">       return new RequestMappingInfo(this.name, patterns,</span></div><div class="token-line"><span class="token plain">             methods, params, headers, consumes, produces, custom.getCondition());</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>现在我们知道<strong>匹配会查询所有的信息</strong>，例如 Header、Body 类型以及URL 等。如果有一项不符合条件，则不匹配。</p><p>在我们的案例中，当使用 <a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi1/xiaoming">http://localhost:8080/hi1/xiaoming<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 访问时，其中 patternsCondition 是可以匹配上的。实际的匹配方法执行是通过 AntPathMatcher#match 来执行，判断的相关参数可参考以下调试视图：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimagef2c6f224047fd2d4ee0751229415a9ac87c6.53a33bae.png" alt=""/></p><p>但是当我们使用 <a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi1/xiaoming">http://localhost:8080/hi1/xiao/ming<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来访问时，AntPathMatcher 执行的结果是&quot;/hi1/xiao/ming&quot;匹配不上&quot;/hi1/<!-- -->{<!-- -->name<!-- -->}<!-- -->&quot;。</p><p><strong>3. 根据匹配情况返回结果</strong></p><p>如果找到匹配的方法，则返回方法；如果没有，则返回 null。</p><p>在本案例中，<a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi1/xiaoming">http://localhost:8080/hi1/xiao/ming<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 因为找不到匹配方法最终报 404 错误。追根溯源就是 AntPathMatcher 匹配不了&quot;/hi1/xiao/ming&quot;和&quot;/hi1/<!-- -->{<!-- -->name<!-- -->}<!-- -->&quot;。</p><p>另外，我们再回头思考 <a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi1/xiaoming/">http://localhost:8080/hi1/xiaoming/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 为什么没有报错而是直接去掉了/。这里我直接贴出了负责执行 AntPathMatcher 匹配的 PatternsRequestCondition#getMatchingPattern 方法的部分关键代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private String getMatchingPattern(String pattern, String lookupPath) {</span></div><div class="token-line"><span class="token plain">       //省略其他非关键代码</span></div><div class="token-line"><span class="token plain">       if (this.pathMatcher.match(pattern, lookupPath)) {</span></div><div class="token-line"><span class="token plain">          return pattern;</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       //尝试加一个/来匹配</span></div><div class="token-line"><span class="token plain">       if (this.useTrailingSlashMatch) {</span></div><div class="token-line"><span class="token plain">          if (!pattern.endsWith(&quot;/&quot;) &amp;&amp; this.pathMatcher.match(pattern + &quot;/&quot;, lookupPath)) {</span></div><div class="token-line"><span class="token plain">             return pattern + &quot;/&quot;;</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return null;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这段代码中，AntPathMatcher 匹配不了&quot;/hi1/xiaoming/&quot;和&quot;/hi1/<!-- -->{<!-- -->name<!-- -->}<!-- -->&quot;，所以不会直接返回。进而，在 useTrailingSlashMatch 这个参数启用时（默认启用），会把 Pattern 结尾加上/再尝试匹配一次。如果能匹配上，在最终返回 Pattern 时就隐式自动加/。</p><p>很明显，我们的案例符合这种情况，等于说我们最终是用了&quot;/hi1/<!-- -->{<!-- -->name<!-- -->}<!-- -->/&quot;这个 Pattern，而不再是&quot;/hi1/<!-- -->{<!-- -->name<!-- -->}<!-- -->&quot;。所以自然 URL 解析 name 结果是去掉/的。</p><h3 id="问题修正"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#问题修正"><span class="icon icon-link"></span></a>问题修正</h3><p>针对这个案例，有了源码的剖析，我们可能会想到可以先用&quot;**&quot;匹配上路径，等进入方法后再尝试去解析，这样就可以万无一失吧。具体修改代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RequestMapping(path = &quot;/hi1/**&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">    public String hi1(HttpServletRequest request){</span></div><div class="token-line"><span class="token plain">        String requestURI = request.getRequestURI();</span></div><div class="token-line"><span class="token plain">        return requestURI.split(&quot;/hi1/&quot;)[1];</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>但是这种修改方法还是存在漏洞，假设我们路径的 name 中刚好又含有&quot;/hi1/&quot;，则 split 后返回的值就并不是我们想要的。实际上，更合适的修订代码示例如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private AntPathMatcher antPathMatcher = new AntPathMatcher();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @RequestMapping(path = &quot;/hi1/**&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">    public String hi1(HttpServletRequest request){</span></div><div class="token-line"><span class="token plain">        String path = (String) request.getAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE);</span></div><div class="token-line"><span class="token plain">        //matchPattern 即为&quot;/hi1/**&quot;</span></div><div class="token-line"><span class="token plain">        String matchPattern = (String) request.getAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE); </span></div><div class="token-line"><span class="token plain">        return antPathMatcher.extractPathWithinPattern(matchPattern, path); </span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>经过修改，两个错误都得以解决了。当然也存在一些其他的方案，例如对传递的参数进行 URL 编码以避免出现/，或者干脆直接把这个变量作为请求参数、Header 等，而不是作为 URL 的一部分。你完全可以根据具体情况来选择合适的方案。</p><h2 id="案例-2错误使用requestparampathvarible-等注解"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#案例-2错误使用requestparampathvarible-等注解"><span class="icon icon-link"></span></a>案例 2：错误使用@RequestParam、@PathVarible 等注解</h2><p>我们常常使用@RequestParam 和@PathVarible 来获取请求参数（request parameters）以及 path 中的部分。但是在频繁使用这些参数时，不知道你有没有觉得它们的使用方式并不友好，例如我们去获取一个请求参数 name，我们会定义如下：</p><blockquote><p>@RequestParam(&quot;name&quot;) String name</p></blockquote><p>此时，我们会发现变量名称大概率会被定义成 RequestParam值。所以我们是不是可以用下面这种方式来定义：</p><blockquote><p>@RequestParam String name</p></blockquote><p>这种方式确实是可以的，本地测试也能通过。这里我还给出了完整的代码，你可以感受下这两者的区别。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RequestMapping(path = &quot;/hi1&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">    public String hi1(@RequestParam(&quot;name&quot;) String name){</span></div><div class="token-line"><span class="token plain">        return name;</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @RequestMapping(path = &quot;/hi2&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">    public String hi2(@RequestParam String name){</span></div><div class="token-line"><span class="token plain">        return name;</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>很明显，对于喜欢追究极致简洁的同学来说，这个酷炫的功能是一个福音。但当我们换一个项目时，有可能上线后就失效了，然后报错 500，提示匹配不上。</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimagef37ff377e98e0293e480c4ea249596ec4d7f.16f661d0.png" alt=""/></p><h3 id="案例解析-1"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#案例解析-1"><span class="icon icon-link"></span></a>案例解析</h3><p>要理解这个问题出现的原因，首先我们需要把这个问题复现出来。例如我们可以修改下 pom.xml 来关掉两个选项：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&lt;plugin&gt;</span></div><div class="token-line"><span class="token plain">        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span></div><div class="token-line"><span class="token plain">        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span></div><div class="token-line"><span class="token plain">       &lt;configuration&gt;</span></div><div class="token-line"><span class="token plain">            &lt;debug&gt;false&lt;/debug&gt;</span></div><div class="token-line"><span class="token plain">            &lt;parameters&gt;false&lt;/parameters&gt;</span></div><div class="token-line"><span class="token plain">        &lt;/configuration&gt;</span></div><div class="token-line"><span class="token plain">    &lt;/plugin&gt;</span></div></pre></div><p>上述配置显示关闭了 parameters 和 debug，这 2 个参数的作用你可以参考下面的表格：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimagec6a0c60cabd6a71f02db8663eae8224ddaa0.03335ec0.jpg" alt=""/></p><p>通过上述描述，我们可以看出这 2 个参数控制了一些 debug 信息是否加进 class 文件中。我们可以开启这两个参数来编译，然后使用下面的命令来查看信息：</p><blockquote><p>javap -verbose HelloWorldController.class</p></blockquote><p>执行完命令后，我们会看到以下 class 信息：</p><p><img src="data:image/png;base64,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" alt=""/></p><p>debug 参数开启的部分信息就是 LocalVaribleTable，而 paramters 参数开启的信息就是 MethodParameters。观察它们的信息，你会发现它们都含有参数名name。</p><p>如果你关闭这两个参数，则 name 这个名称自然就没有了。而这个方法本身在 @RequestParam 中又没有指定名称，那么 Spring 此时还能找到解析的方法么？</p><p>答案是否定的，这里我们可以顺带说下 Spring 解析请求参数名称的过程，参考代码 AbstractNamedValueMethodArgumentResolver#updateNamedValueInfo：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private NamedValueInfo updateNamedValueInfo(MethodParameter parameter, NamedValueInfo info) {</span></div><div class="token-line"><span class="token plain">       String name = info.name;</span></div><div class="token-line"><span class="token plain">       if (info.name.isEmpty()) {</span></div><div class="token-line"><span class="token plain">          name = parameter.getParameterName();</span></div><div class="token-line"><span class="token plain">          if (name == null) {</span></div><div class="token-line"><span class="token plain">             throw new IllegalArgumentException(</span></div><div class="token-line"><span class="token plain">                   &quot;Name for argument type [&quot; + parameter.getNestedParameterType().getName() +</span></div><div class="token-line"><span class="token plain">                   &quot;] not available, and parameter name information not found in class file either.&quot;);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       String defaultValue = (ValueConstants.DEFAULT_NONE.equals(info.defaultValue) ? null : info.defaultValue);</span></div><div class="token-line"><span class="token plain">       return new NamedValueInfo(name, info.required, defaultValue);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其中 NamedValueInfo 的 name 为 @RequestParam 指定的值。很明显，在本案例中，为 null。</p><p>所以这里我们就会尝试调用 parameter.getParameterName() 来获取参数名作为解析请求参数的名称。但是，很明显，关掉上面两个开关后，就不可能在 class 文件中找到参数名了，这点可以从下面的调试试图中得到验证：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage8d378dc41bf12f0075573bf6b6d13b2a2537.d67b5414.png" alt=""/></p><p>当参数名不存在，@RequestParam 也没有指明，自然就无法决定到底要用什么名称去获取请求参数，所以就会报本案例的错误。</p><h3 id="问题修正-1"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#问题修正-1"><span class="icon icon-link"></span></a>问题修正</h3><p>模拟出了问题是如何发生的，我们自然可以通过开启这两个参数让其工作起来。但是思考这两个参数的作用，很明显，它可以让我们的程序体积更小，所以很多项目都会青睐去关闭这两个参数。</p><p>为了以不变应万变，正确的修正方式是<strong>必须显式在@RequestParam 中指定请求参数名</strong>。具体修改如下：</p><blockquote><p>@RequestParam(&quot;name&quot;) String name</p></blockquote><p>通过这个案例，我们可以看出：很多功能貌似可以永远工作，但是实际上，只是在特定的条件下而已。另外，这里再拓展下，IDE 都喜欢开启相关 debug 参数，所以 IDE 里运行的程序不见得对产线适应，例如针对 parameters 这个参数，IDEA 默认就开启了。</p><p>另外，本案例围绕的都是 @RequestParam，其实 @PathVarible 也有一样的问题。这里你要注意。</p><p>那么说到这里，我顺带提一个可能出现的小困惑：我们这里讨论的参数，和 @QueryParam、@PathParam 有什么区别？实际上，后者都是 JAX-RS 自身的注解，不需要额外导包。而 @RequestParam 和 @PathVariable 是 Spring 框架中的注解，需要额外导入依赖包。另外不同注解的参数也不完全一致。</p><h2 id="案例-3未考虑参数是否可选"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#案例-3未考虑参数是否可选"><span class="icon icon-link"></span></a>案例 3：未考虑参数是否可选</h2><p>在上面的案例中，我们提到了 @RequestParam 的使用。而对于它的使用，我们常常会遇到另外一个问题。当需要特别多的请求参数时，我们往往会忽略其中一些参数是否可选。例如存在类似这样的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RequestMapping(path = &quot;/hi4&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">    public String hi4(@RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;address&quot;) String address){</span></div><div class="token-line"><span class="token plain">        return name + &quot;:&quot; + address;</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>在访问 <a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi2?name=xiaoming&amp;address=beijing">http://localhost:8080/hi4?name=xiaoming&amp;address=beijing<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 时并不会出问题，但是一旦用户仅仅使用 name 做请求（即 <a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi4?name=xiaoming">http://localhost:8080/hi4?name=xiaoming<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ）时，则会直接报错如下：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage92099289ddbf7e1b39131662ab3fc1807709.1b59c263.png" alt=""/></p><p>此时，返回错误码 400，提示请求格式错误：此处缺少 address 参数。</p><p>实际上，部分初学者即使面对这个错误，也会觉得惊讶，既然不存在 address，address 应该设置为 null，而不应该是直接报错不是么？接下来我们就分析下。</p><h3 id="案例解析-2"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#案例解析-2"><span class="icon icon-link"></span></a>案例解析</h3><p>要了解这个错误出现的根本原因，你就需要了解请求参数的发生位置。</p><p>实际上，这里我们也能按注解名（@RequestParam）来确定解析发生的位置是在 RequestParamMethodArgumentResolver 中。为什么是它？</p><p>追根溯源，针对当前案例，当根据 URL 匹配上要执行的方法是 hi4 后，要反射调用它，必须解析出方法参数 name 和 address 才可以。而它们被 @RequestParam 注解修饰，所以解析器借助 RequestParamMethodArgumentResolver 就成了很自然的事情。</p><p>接下来我们看下 RequestParamMethodArgumentResolver 对参数解析的一些关键操作，参考其父类方法 AbstractNamedValueMethodArgumentResolver#resolveArgument：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></div><div class="token-line"><span class="token plain">          NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {</span></div><div class="token-line"><span class="token plain">       NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);</span></div><div class="token-line"><span class="token plain">       MethodParameter nestedParameter = parameter.nestedIfOptional();</span></div><div class="token-line"><span class="token plain">       //省略其他非关键代码</span></div><div class="token-line"><span class="token plain">       //获取请求参数</span></div><div class="token-line"><span class="token plain">       Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);</span></div><div class="token-line"><span class="token plain">       if (arg == null) {</span></div><div class="token-line"><span class="token plain">          if (namedValueInfo.defaultValue != null) {</span></div><div class="token-line"><span class="token plain">             arg = resolveStringValue(namedValueInfo.defaultValue);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          else if (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) {</span></div><div class="token-line"><span class="token plain">             handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       //省略后续代码：类型转化等工作</span></div><div class="token-line"><span class="token plain">       return arg;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如代码所示，当缺少请求参数的时候，通常我们会按照以下几个步骤进行处理。</p><p><strong>1. 查看 namedValueInfo 的默认值，如果存在则使用它</strong></p><p>这个变量实际是通过下面的方法来获取的，参考 RequestParamMethodArgumentResolver#createNamedValueInfo：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Override</span></div><div class="token-line"><span class="token plain">    protected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {</span></div><div class="token-line"><span class="token plain">       RequestParam ann = parameter.getParameterAnnotation(RequestParam.class);</span></div><div class="token-line"><span class="token plain">       return (ann != null ? new RequestParamNamedValueInfo(ann) : new RequestParamNamedValueInfo());</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>实际上就是 @RequestParam 的相关信息，我们调试下，就可以验证这个结论，具体如下图所示：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimagef55ef56f4498bcd078c20e4320yy2353af5e.236ce485.png" alt=""/></p><p><strong>2. 在 @RequestParam 没有指明默认值时，会查看这个参数是否必须，如果必须，则按错误处理</strong></p><p>判断参数是否必须的代码即为下述关键代码行：</p><blockquote><p>namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()</p></blockquote><p>很明显，若要判定一个参数是否是必须的，需要同时满足两个条件：条件 1 是@RequestParam 指明了必须（即属性 required 为 true，实际上它也是默认值），条件 2 是要求 @RequestParam 标记的参数本身不是可选的。</p><p>我们可以通过 MethodParameter#isOptional 方法看下可选的具体含义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public boolean isOptional() {</span></div><div class="token-line"><span class="token plain">       return (getParameterType() == Optional.class || hasNullableAnnotation() ||</span></div><div class="token-line"><span class="token plain">             (KotlinDetector.isKotlinReflectPresent() &amp;&amp;</span></div><div class="token-line"><span class="token plain">                   KotlinDetector.isKotlinType(getContainingClass()) &amp;&amp;</span></div><div class="token-line"><span class="token plain">                   KotlinDelegate.isOptional(this)));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在不使用 Kotlin 的情况下，所谓可选，就是参数的类型为 Optional，或者任何标记了注解名为 Nullable 且 RetentionPolicy 为 RUNTIM 的注解。</p><p><strong>3. 如果不是必须，则按 null 去做具体处理</strong></p><p>如果接受类型是 boolean，返回 false，如果是基本类型则直接报错，这里不做展开。</p><p>结合我们的案例，我们的参数符合步骤 2 中判定为必选的条件，所以最终会执行方法 AbstractNamedValueMethodArgumentResolver#handleMissingValue：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">protected void handleMissingValue(String name, MethodParameter parameter) throws ServletException {</span></div><div class="token-line"><span class="token plain">       throw new ServletRequestBindingException(&quot;Missing argument &#x27;&quot; + name +</span></div><div class="token-line"><span class="token plain">             &quot;&#x27; for method parameter of type &quot; + parameter.getNestedParameterType().getSimpleName());</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="问题修正-2"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#问题修正-2"><span class="icon icon-link"></span></a>问题修正</h3><p>通过案例解析，我们很容易就能修正这个问题，就是让参数有默认值或为非可选即可，具体方法包含以下几种。</p><p><strong>1. 设置 @RequestParam 的默认值</strong></p><p>修改代码如下：</p><blockquote><p>@RequestParam(value = &quot;address&quot;, defaultValue = &quot;no address&quot;) String address</p></blockquote><p><strong>2. 设置 @RequestParam 的 required 值</strong></p><p>修改代码如下：</p><blockquote><p>@RequestParam(value = &quot;address&quot;, required = false) String address)</p></blockquote><p><strong>3. 标记任何名为 Nullable 且 RetentionPolicy 为 RUNTIME 的注解</strong></p><p>修改代码如下：</p><blockquote><p>&lt;//org.springframework.lang.Nullable&gt; 可以<br/>&lt;//edu.umd.cs.findbugs.annotations.Nullable&gt; 可以<br/>@RequestParam(value = &quot;address&quot;) @Nullable String address</p></blockquote><p><strong>4. 修改参数类型为 Optional</strong></p><p>修改代码如下：</p><blockquote><p>@RequestParam(value = &quot;address&quot;) Optional address</p></blockquote><p>从这些修正方法不难看出：假设你不学习源码，解决方法就可能只局限于一两种，但是深入源码后，解决方法就变得格外多了。这里要特别强调的是：<strong>在Spring Web 中，默认情况下，请求参数是必选项。</strong></p><h2 id="案例-4请求参数格式错误"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#案例-4请求参数格式错误"><span class="icon icon-link"></span></a>案例 4：请求参数格式错误</h2><p>当我们使用 Spring URL 相关的注解，会发现 Spring 是能够完成自动转化的。例如在下面的代码中，age 可以被直接定义为 int 这种基本类型（Integer 也可以），而不是必须是 String 类型。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RequestMapping(path = &quot;/hi5&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">    public String hi5(@RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;age&quot;) int age){</span></div><div class="token-line"><span class="token plain">        return name + &quot; is &quot; + age + &quot; years old&quot;;</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>鉴于 Spring 的强大转化功能，我们断定 Spring 也支持日期类型的转化（也确实如此），于是我们可能会写出类似下面这样的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RequestMapping(path = &quot;/hi6&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">    public String hi6(@RequestParam(&quot;Date&quot;) Date date){</span></div><div class="token-line"><span class="token plain">        return &quot;date is &quot; + date ;</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>然后，我们使用一些看似明显符合日期格式的 URL 来访问，例如 &lt;<a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi6?date=2021-5-1">http://localhost:8080/hi6?date=2021-5-1<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 20:26:53&gt;，我们会发现 Spring 并不能完成转化，而是报错如下：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage0878085931e6c4c8a01ae5f4f443c0393778.21d73816.png" alt=""/></p><p>此时，返回错误码 400，错误信息为&quot;Failed to convert value of type &#x27;java.lang.String&#x27; to required type &#x27;java.util.Date&quot;。</p><p>如何理解这个案例？如果实现自动转化，我们又需要做什么？</p><h3 id="案例解析-3"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#案例解析-3"><span class="icon icon-link"></span></a>案例解析</h3><p>不管是使用 @PathVarible 还是 @RequetParam，我们一般解析出的结果都是一个 String 或 String 数组。例如，使用 @RequetParam 解析的关键代码参考 RequestParamMethodArgumentResolver#resolveName 方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Nullable</span></div><div class="token-line"><span class="token plain">    protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception {</span></div><div class="token-line"><span class="token plain">       //省略其他非关键代码</span></div><div class="token-line"><span class="token plain">       if (arg == null) {</span></div><div class="token-line"><span class="token plain">          String[] paramValues = request.getParameterValues(name);</span></div><div class="token-line"><span class="token plain">          if (paramValues != null) {</span></div><div class="token-line"><span class="token plain">             arg = (paramValues.length == 1 ? paramValues[0] : paramValues);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return arg;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里我们调用的&quot;request.getParameterValues(name)&quot;，返回的是一个 String 数组，最终给上层调用者返回的是单个 String（如果只有一个元素时）或者 String 数组。</p><p>所以很明显，在这个测试程序中，我们给上层返回的是一个 String，这个 String 的值最终是需要做转化才能赋值给其他类型。例如对于案例中的&quot;int age&quot;定义，是需要转化为 int 基本类型的。这个基本流程可以通过 AbstractNamedValueMethodArgumentResolver#resolveArgument 的关键代码来验证：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></div><div class="token-line"><span class="token plain">          NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {</span></div><div class="token-line"><span class="token plain">       //省略其他非关键代码</span></div><div class="token-line"><span class="token plain">       Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);</span></div><div class="token-line"><span class="token plain">       //以此为界，前面代码为解析请求参数,后续代码为转化解析出的参数</span></div><div class="token-line"><span class="token plain">       if (binderFactory != null) {</span></div><div class="token-line"><span class="token plain">          WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name);</span></div><div class="token-line"><span class="token plain">          try {</span></div><div class="token-line"><span class="token plain">             arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          //省略其他非关键代码</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       //省略其他非关键代码</span></div><div class="token-line"><span class="token plain">       return arg;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>实际上在前面我们曾经提到过这个转化的基本逻辑，所以这里不再详述它具体是如何发生的。</p><p>在这里你只需要回忆出它是需要<strong>根据源类型和目标类型寻找转化器来执行转化的</strong>。在这里，对于 age 而言，最终找出的转化器是 StringToNumberConverterFactory。而对于 Date 型的 Date 变量，在本案例中，最终找到的是 ObjectToObjectConverter。它的转化过程参考下面的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {</span></div><div class="token-line"><span class="token plain">       if (source == null) {</span></div><div class="token-line"><span class="token plain">          return null;</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       Class&lt;?&gt; sourceClass = sourceType.getType();</span></div><div class="token-line"><span class="token plain">       Class&lt;?&gt; targetClass = targetType.getType();</span></div><div class="token-line"><span class="token plain">       //根据源类型去获取构建出目标类型的方法：可以是工厂方法（例如 valueOf、from 方法）也可以是构造器</span></div><div class="token-line"><span class="token plain">       Member member = getValidatedMember(targetClass, sourceClass);</span></div><div class="token-line"><span class="token plain">       try {</span></div><div class="token-line"><span class="token plain">          if (member instanceof Method) {</span></div><div class="token-line"><span class="token plain">             //如果是工厂方法，通过反射创建目标实例</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          else if (member instanceof Constructor) {</span></div><div class="token-line"><span class="token plain">             //如果是构造器，通过反射创建实例</span></div><div class="token-line"><span class="token plain">             Constructor&lt;?&gt; ctor = (Constructor&lt;?&gt;) member;</span></div><div class="token-line"><span class="token plain">             ReflectionUtils.makeAccessible(ctor);</span></div><div class="token-line"><span class="token plain">             return ctor.newInstance(source);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       catch (InvocationTargetException ex) {</span></div><div class="token-line"><span class="token plain">          throw new ConversionFailedException(sourceType, targetType, source, ex.getTargetException());</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       catch (Throwable ex) {</span></div><div class="token-line"><span class="token plain">          throw new ConversionFailedException(sourceType, targetType, source, ex);</span></div><div class="token-line"><span class="token plain">       }</span></div></pre></div><p>当使用 ObjectToObjectConverter 进行转化时，是根据反射机制带着源目标类型来查找可能的构造目标实例方法，例如构造器或者工厂方法，然后再次通过反射机制来创建一个目标对象。所以对于 Date 而言，最终调用的是下面的 Date 构造器：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public Date(String s) {</span></div><div class="token-line"><span class="token plain">        this(parse(s));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然而，我们传入的 <a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi6?date=2021-5-1%2020:26:53">2021-5-1 20:26:53<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 虽然确实是一种日期格式，但用来作为 Date 构造器参数是不支持的，最终报错，并被上层捕获，转化为 ConversionFailedException 异常。这就是这个案例背后的故事了。</p><h3 id="问题修正-3"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#问题修正-3"><span class="icon icon-link"></span></a>问题修正</h3><p>那么怎么解决呢？提供两种方法。</p><p><strong>1. 使用 Date 支持的格式</strong></p><p>例如下面的测试 URL 就可以工作起来：</p><blockquote><p><a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi6?date=Sat">http://localhost:8080/hi6?date=Sat<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, 12 Aug 1995 13:30:00 GMT</p></blockquote><p><strong>2. 使用好内置格式转化器</strong></p><p>实际上，在Spring中，要完成 String 对于 Date 的转化，ObjectToObjectConverter 并不是最好的转化器。我们可以使用更强大的AnnotationParserConverter。**在Spring 初始化时，会构建一些针对日期型的转化器，即相应的一些 AnnotationParserConverter 的实例。**但是为什么有时候用不上呢？</p><p>这是因为 AnnotationParserConverter 有目标类型的要求，这点我们可以通过调试角度来看下，参考 FormattingConversionService#addFormatterForFieldAnnotation 方法的调试试图：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage0c340c8bd3fc14081710cc411091c8bd4f34.445deb76.png" alt=""/></p><p>这是适应于 String 到 Date 类型的转化器 AnnotationParserConverter 实例的构造过程，其需要的 annototationType 参数为 DateTimeFormat。</p><p>annototationType 的作用正是为了帮助判断是否能用这个转化器，这一点可以参考代码 AnnotationParserConverter#matches：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Override</span></div><div class="token-line"><span class="token plain">    public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {</span></div><div class="token-line"><span class="token plain">       return targetType.hasAnnotation(this.annotationType);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>最终构建出来的转化器相关信息可以参考下图：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimagef0b1f068b39c4a3f81b8ccebbfd962e966b1.0fe9d606.png" alt=""/></p><p>图中构造出的转化器是可以用来转化 String 到 Date，但是它要求我们标记 @DateTimeFormat。很明显，我们的参数 Date 并没有标记这个注解，所以这里为了使用这个转化器，我们可以使用上它并提供合适的格式。这样就可以让原来不工作的 URL 工作起来，具体修改代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@DateTimeFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;) Date date</span></div></pre></div><p>以上即为本案例的解决方案。除此之外，我们完全可以制定一个转化器来帮助我们完成转化，这里不再赘述。另外，通过这个案例，我们可以看出：尽管 Spring 给我们提供了很多内置的转化功能，但是我们一定要注意，格式是否符合对应的要求，否则代码就可能会失效。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>通过这一讲的学习，我们了解到了在Spring解析URL中的一些常见错误及其背后的深层原因。这里再次回顾下重点：</p><ol><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">当我们使用\@PathVariable时，一定要注意传递的值是不是含有 / ;</span></div></pre></div></li><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">当我们使用\@RequestParam、\@PathVarible等注解时，一定要意识到一个问题，虽然下面这两种方式（以\@RequestParam使用示例）都可以，但是后者在一些项目中并不能正常工作，因为很多产线的编译配置会去掉不是必须的调试信息。</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RequestMapping(path = &quot;/hi1&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">    public String hi1(@RequestParam(&quot;name&quot;) String name){</span></div><div class="token-line"><span class="token plain">        return name;</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    //方式2：没有显式指定RequestParam的“name”，这种方式有时候会不行</span></div><div class="token-line"><span class="token plain">    @RequestMapping(path = &quot;/hi2&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">    public String hi2(@RequestParam String name){</span></div><div class="token-line"><span class="token plain">        return name;</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><ol start="3"><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">任何一个参数，我们都需要考虑它是可选的还是必须的。同时，你一定要想到参数类型的定义到底能不能从请求中自动转化而来。Spring本身给我们内置了很多转化器，但是我们要以合适的方式使用上它。另外，Spring对很多类型的转化设计都很贴心，例如使用下面的注解就能解决自定义日期格式参数转化问题。</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@DateTimeFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;) Date date</span></div></pre></div><p>希望这些核心知识点，能帮助你高效解析URL。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/03.spring-web篇/02#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>关于 URL 解析，其实还有许多让我们惊讶的地方，例如案例 2 的部分代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RequestMapping(path = &quot;/hi2&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">    public String hi2(@RequestParam(&quot;name&quot;) String name){</span></div><div class="token-line"><span class="token plain">        return name;</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>在上述代码的应用中，我们可以使用 <a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi2?name=xiaoming&amp;name=hanmeimei">http://localhost:8080/hi2?name=xiaoming&amp;name=hanmeimei<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来测试下，结果会返回什么呢？你猜会是<a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi2?name=xiaoming&amp;name=hanmeimei">xiaoming&amp;name=hanmeimei<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 么？</p><p>我们留言区见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/spring编程常见错误50例/03.SpringWeb篇/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 09:43:57</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-test/umi.3ded5539.js"></script>
  </body>
</html>
