<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-java/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-java";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>01｜Spring Bean 定义常见错误 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/spring编程常见错误50例/02.spring-core篇/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a aria-current="page" class="active" href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a aria-current="page" class="active" href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/spring编程常见错误50例/01.课前必读">01.课前必读</a><ul><li><a href="/blog-java/spring编程常见错误50例/01.课前必读/01"><span>开篇词｜贴心“保姆”Spring罢工了怎么办？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-java/spring编程常见错误50例/02.spring-core篇">02.SpringCore篇</a><ul><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/01"><span>导读｜5分钟轻松了解Spring基础知识</span></a></li><li><a aria-current="page" class="active" href="/blog-java/spring编程常见错误50例/02.spring-core篇/02"><span>01｜Spring Bean 定义常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/03"><span>02｜Spring Bean 依赖注入常见错误（上）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/04"><span>03｜Spring Bean 依赖注入常见错误（下）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/05"><span>04｜Spring Bean 生命周期常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/06"><span>05｜Spring AOP 常见错误（上）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/07"><span>06｜Spring AOP 常见错误（下）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/08"><span>07｜Spring事件常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/09"><span>08｜答疑现场：Spring Core 篇思考题合集</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇">03.SpringWeb篇</a><ul><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/01"><span>导读｜5分钟轻松了解一个HTTP请求的处理过程</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/02"><span>09｜Spring Web URL 解析常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/03"><span>10 | Spring Web Header 解析常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/04"><span>11 | Spring Web Body 转化常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/05"><span>12｜Spring Web 参数验证常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/06"><span>13 | Spring Web 过滤器使用常见错误（上）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/07"><span>14 | Spring Web 过滤器使用常见错误（下）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/08"><span>15 | Spring Security 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/09"><span>16｜Spring Exception 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/10"><span>17｜答疑现场：Spring Web 篇思考题合集</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇">04.Spring补充篇</a><ul><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/01"><span>18 | Spring Data 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/02"><span>19 | Spring 事务常见错误（上）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/03"><span>20 | Spring 事务常见错误（下）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/04"><span>21 | Spring Rest Template 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/05"><span>22 | Spring Test 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/06"><span>23｜答疑现场：Spring 补充篇思考题合集</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/07"><span>知识回顾 | 系统梳理Spring编程错误根源</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/05.结束语">05.结束语</a><ul><li><a href="/blog-java/spring编程常见错误50例/05.结束语/01"><span>结束语｜问题总比解决办法多</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/06.期末测试">06.期末测试</a><ul><li><a href="/blog-java/spring编程常见错误50例/06.期末测试/01"><span>期末测试｜来赴一场100分之约！</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/summary">spring编程常见错误50例</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="案例 1：隐式扫描不到 Bean 的定义" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#案例-1隐式扫描不到-bean-的定义"><span>案例 1：隐式扫描不到 Bean 的定义</span></a></li><li title="案例解析" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#案例解析"><span>案例解析</span></a></li><li title="问题修正" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#问题修正"><span>问题修正</span></a></li><li title="案例 2：定义的 Bean 缺少隐式依赖" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#案例-2定义的-bean-缺少隐式依赖"><span>案例 2：定义的 Bean 缺少隐式依赖</span></a></li><li title="案例解析" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#案例解析-1"><span>案例解析</span></a></li><li title="问题修正" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#问题修正-1"><span>问题修正</span></a></li><li title="案例 3：原型 Bean 被固定" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#案例-3原型-bean-被固定"><span>案例 3：原型 Bean 被固定</span></a></li><li title="案例解析" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#案例解析-2"><span>案例解析</span></a></li><li title="问题修正" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#问题修正-2"><span>问题修正</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#重点回顾"><span>重点回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="01spring-bean-定义常见错误"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#01spring-bean-定义常见错误"><span class="icon icon-link"></span></a>01｜Spring Bean 定义常见错误</h1><p>你好，我是傅健。</p><p>从导读中我们已知，Spring 的核心是围绕 Bean 进行的。不管是 Spring Boot 还是 Spring Cloud，只要名称中带有Spring关键字的技术都脱离不了 Bean，而要使用一个 Bean 少不了要先定义出来，所以<strong>定义一个Bean 就变得格外重要了</strong>。</p><p>当然，对于这么重要的工作，Spring 自然给我们提供了很多简单易用的方式。然而，这种简单易用得益于 Spring 的“<strong>约定大于配置</strong>”，但我们往往不见得会对所有的约定都了然于胸，所以仍然会在 Bean 的定义上犯一些经典的错误。</p><p>接下来我们就来了解下那些经典错误以及它们背后的原理，你也可以对照着去看看自己是否也曾犯过，后来又是如何解决的。</p><h2 id="案例-1隐式扫描不到-bean-的定义"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#案例-1隐式扫描不到-bean-的定义"><span class="icon icon-link"></span></a>案例 1：隐式扫描不到 Bean 的定义</h2><p>在构建 Web 服务时，我们常使用 Spring Boot 来快速构建。例如，使用下面的包结构和相关代码来完成一个简易的 Web 版 HelloWorld：</p><p><img src="data:image/png;base64,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" alt=""/></p><p>其中，负责启动程序的 Application 类定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.spring.puzzle.class1.example1.application</span></div><div class="token-line"><span class="token plain">    //省略 import</span></div><div class="token-line"><span class="token plain">    @SpringBootApplication</span></div><div class="token-line"><span class="token plain">    public class Application {</span></div><div class="token-line"><span class="token plain">        public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">            SpringApplication.run(Application.class, args);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>提供接口的 HelloWorldController 代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package com.spring.puzzle.class1.example1.application</span></div><div class="token-line"><span class="token plain">    //省略 import</span></div><div class="token-line"><span class="token plain">    @RestController</span></div><div class="token-line"><span class="token plain">    public class HelloWorldController {</span></div><div class="token-line"><span class="token plain">        @RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">        public String hi(){</span></div><div class="token-line"><span class="token plain">             return &quot;helloworld&quot;;</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码即可实现一个简单的功能：访问<a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi">http://localhost:8080/hi<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 返回helloworld。两个关键类位于同一个包（即 application）中。其中 HelloWorldController 因为添加了@RestController，最终被识别成一个 Controller 的 Bean。</p><p>但是，假设有一天，当我们需要添加多个类似的 Controller，同时又希望用更清晰的包层次和结构来管理时，我们可能会去单独建立一个独立于 application 包之外的 Controller 包，并调整类的位置。调整后结构示意如下：</p><p><img src="data:image/png;base64,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" alt=""/></p><p>实际上，我们没有改变任何代码，只是改变了包的结构，但是我们会发现这个 Web 应用失效了，即不能识别出 HelloWorldController 了。也就是说，我们找不到 HelloWorldController 这个 Bean 了。这是为何？</p><h3 id="案例解析"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#案例解析"><span class="icon icon-link"></span></a>案例解析</h3><p>要了解 HelloWorldController 为什么会失效，就需要先了解之前是如何生效的。对于 Spring Boot 而言，关键点在于 Application.java 中使用了 SpringBootApplication 注解。而这个注解继承了另外一些注解，具体定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Target(ElementType.TYPE)</span></div><div class="token-line"><span class="token plain">    @Retention(RetentionPolicy.RUNTIME)</span></div><div class="token-line"><span class="token plain">    @Documented</span></div><div class="token-line"><span class="token plain">    @Inherited</span></div><div class="token-line"><span class="token plain">    @SpringBootConfiguration</span></div><div class="token-line"><span class="token plain">    @EnableAutoConfiguration</span></div><div class="token-line"><span class="token plain">    @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></div><div class="token-line"><span class="token plain">          @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })</span></div><div class="token-line"><span class="token plain">    public @interface SpringBootApplication {</span></div><div class="token-line"><span class="token plain">    //省略非关键代码</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从定义可以看出，SpringBootApplication开启了很多功能，其中一个关键功能就是 ComponentScan，参考其配置如下：</p><blockquote><p>@ComponentScan(excludeFilters = <!-- -->{<!-- --> @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class)</p></blockquote><p>当 Spring Boot 启动时，ComponentScan 的启用意味着会去扫描出所有定义的 Bean，那么扫描什么位置呢？这是由 ComponentScan 注解的 basePackages 属性指定的，具体可参考如下定义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public @interface ComponentScan {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * Base packages to scan for annotated components.</span></div><div class="token-line"><span class="token plain">     * &lt;p&gt;{@link #value} is an alias for (and mutually exclusive with) this</span></div><div class="token-line"><span class="token plain">     * attribute.</span></div><div class="token-line"><span class="token plain">     * &lt;p&gt;Use {@link #basePackageClasses} for a type-safe alternative to</span></div><div class="token-line"><span class="token plain">     * String-based package names.</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    @AliasFor(&quot;value&quot;)</span></div><div class="token-line"><span class="token plain">    String[] basePackages() default {};</span></div><div class="token-line"><span class="token plain">    //省略其他非关键代码</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>而在我们的案例中，我们直接使用的是 SpringBootApplication 注解定义的 ComponentScan，它的 basePackages 没有指定，所以默认为空（即<!-- -->{<!-- -->}<!-- -->）。此时扫描的是什么包？这里不妨带着这个问题去调试下（调试位置参考 ComponentScanAnnotationParser#parse 方法），调试视图如下：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage75c675a8abe6d5854f4f4a8d6c9a5655f3c6.149b3e73.png" alt=""/></p><p>从上图可以看出，当 basePackages 为空时，扫描的包会是 declaringClass 所在的包，在本案例中，declaringClass 就是 Application.class，所以扫描的包其实就是它所在的包，即com.spring.puzzle.class1.example1.application。</p><p>对比我们重组包结构前后，我们自然就找到了这个问题的根源：在调整前，HelloWorldController 在扫描范围内，而调整后，它已经远离了扫描范围（不和 Application.java 一个包了），虽然代码没有一丝丝改变，但是这个功能已经失效了。</p><p>所以，综合来看，这个问题是因为我们不够了解 Spring Boot 的默认扫描规则引起的。我们仅仅享受了它的便捷，但是并未了解它背后的故事，所以稍作变化，就可能玩不转了。</p><h3 id="问题修正"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#问题修正"><span class="icon icon-link"></span></a>问题修正</h3><p>针对这个案例，有了源码的剖析，我们可以快速找到解决方案了。当然了，我们所谓的解决方案肯定不是说把 HelloWorldController 移动回原来的位置，而是<strong>真正去满足需求</strong>。在这里，真正解决问题的方式是显式配置@ComponentScan。具体修改方式如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@SpringBootApplication</span></div><div class="token-line"><span class="token plain">    @ComponentScan(&quot;com.spring.puzzle.class1.example1.controller&quot;)</span></div><div class="token-line"><span class="token plain">    public class Application {</span></div><div class="token-line"><span class="token plain">        public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">            SpringApplication.run(Application.class, args);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>通过上述修改，我们显式指定了扫描的范围为com.spring.puzzle.class1.example1.controller。不过需要注意的是，显式指定后，默认的扫描范围（即com.spring.puzzle.class1.example1.application）就不会被添加进去了。另外，我们也可以使用@ComponentScans 来修复问题，使用方式如下：</p><blockquote><p>@ComponentScans(value = <!-- -->{<!-- --> @ComponentScan(value = &quot;com.spring.puzzle.class1.example1.controller&quot;) <!-- -->}<!-- -->)</p></blockquote><p>顾名思义，可以看出 ComponentScans 相比较 ComponentScan 多了一个s，支持多个包的扫描范围指定。</p><p>此时，细心的你可能会发现：如果对源码缺乏了解，很容易会顾此失彼。以 ComponentScan 为例，原有的代码扫描了默认包而忽略了其它包；而<strong>一旦显式指定其它包，原来的默认扫描包就被忽略了。</strong></p><h2 id="案例-2定义的-bean-缺少隐式依赖"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#案例-2定义的-bean-缺少隐式依赖"><span class="icon icon-link"></span></a>案例 2：定义的 Bean 缺少隐式依赖</h2><p>初学 Spring 时，我们往往不能快速转化思维。例如，在程序开发过程中，有时候，一方面我们把一个类定义成 Bean，同时又觉得这个 Bean 的定义除了加了一些 Spring 注解外，并没有什么不同。所以在后续使用时，有时候我们会不假思索地去随意定义它，例如我们会写出下面这样的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Service</span></div><div class="token-line"><span class="token plain">    public class ServiceImpl {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        private String serviceName;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public ServiceImpl(String serviceName){</span></div><div class="token-line"><span class="token plain">            this.serviceName = serviceName;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>ServiceImpl 因为标记为@Service而成为一个 Bean。另外我们ServiceImpl 显式定义了一个构造器。但是，上面的代码不是永远都能正确运行的，有时候会报下面这种错误：</p><blockquote><p>Parameter 0 of constructor in com.spring.puzzle.class1.example2.ServiceImpl required a bean of type &#x27;java.lang.String&#x27; that could not be found.</p></blockquote><p>那这种错误是怎么发生的呢？下面我们来分析一下。</p><h3 id="案例解析-1"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#案例解析-1"><span class="icon icon-link"></span></a>案例解析</h3><p>当创建一个 Bean 时，调用的方法是 AbstractAutowireCapableBeanFactory#createBeanInstance。它主要包含两大基本步骤：寻找构造器和通过反射调用构造器创建实例。对于这个案例，最核心的代码执行，你可以参考下面的代码片段：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Candidate constructors for autowiring?</span></div><div class="token-line"><span class="token plain">    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span></div><div class="token-line"><span class="token plain">    if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span></div><div class="token-line"><span class="token plain">          mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {</span></div><div class="token-line"><span class="token plain">       return autowireConstructor(beanName, mbd, ctors, args);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>Spring 会先执行 determineConstructorsFromBeanPostProcessors 方法来获取构造器，然后通过 autowireConstructor 方法带着构造器去创建实例。很明显，在本案例中只有一个构造器，所以非常容易跟踪这个问题。</p><p>autowireConstructor 方法要创建实例，不仅需要知道是哪个构造器，还需要知道构造器对应的参数，这点从最后创建实例的方法名也可以看出，参考如下（即 ConstructorResolver#instantiate）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private Object instantiate(</span></div><div class="token-line"><span class="token plain">          String beanName, RootBeanDefinition mbd, Constructor&lt;?&gt; constructorToUse, Object[] argsToUse)</span></div></pre></div><p>那么上述方法中存储构造参数的 argsToUse 如何获取呢？换言之，当我们已经知道构造器ServiceImpl(String serviceName)，要创建出 ServiceImpl 实例，如何确定 serviceName 的值是多少？</p><p>很明显，这里是在使用 Spring，我们<strong>不能直接显式使用 new 关键字来创建实例</strong>。Spring只能是去寻找依赖来作为构造器调用参数。</p><p>那么这个参数如何获取呢？可以参考下面的代码片段（即 ConstructorResolver#autowireConstructor）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,</span></div><div class="token-line"><span class="token plain">          getUserDeclaredConstructor(candidate), autowiring, candidates.length == 1);</span></div></pre></div><p>我们可以调用 createArgumentArray 方法来构建调用构造器的参数数组，而这个方法的最终实现是从 BeanFactory 中获取 Bean，可以参考下述调用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">return this.beanFactory.resolveDependency(</span></div><div class="token-line"><span class="token plain">          new DependencyDescriptor(param, true), beanName, autowiredBeanNames, typeConverter);</span></div></pre></div><p>如果用调试视图，我们则可以看到更多的信息：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage51a35113cfc71ec8dab37e254c5c5e9abba3.c15c4b90.png" alt=""/></p><p>如图所示，上述的调用即是根据参数来寻找对应的 Bean，在本案例中，如果找不到对应的 Bean 就会抛出异常，提示装配失败。</p><h3 id="问题修正-1"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#问题修正-1"><span class="icon icon-link"></span></a>问题修正</h3><p>从源码级别了解了错误的原因后，现在反思为什么会出现这个错误。追根溯源，正如开头所述，因为不了解很多隐式的规则：我们定义一个类为 Bean，如果再显式定义了构造器，那么这个 Bean 在构建时，会自动根据构造器参数定义寻找对应的 Bean，然后反射创建出这个 Bean。</p><p>了解了这个隐式规则后，解决这个问题就简单多了。我们可以直接定义一个能让 Spring 装配给 ServiceImpl 构造器参数的 Bean，例如定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//这个bean装配给ServiceImpl的构造器参数“serviceName”</span></div><div class="token-line"><span class="token plain">    @Bean</span></div><div class="token-line"><span class="token plain">    public String serviceName(){</span></div><div class="token-line"><span class="token plain">        return &quot;MyServiceName&quot;;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>再次运行程序，发现一切正常了。</p><p>所以，我们在使用 Spring 时，<strong>不要总想着定义的Bean 也可以在非 Spring 场合直接用 new 关键字显式使用，这种思路是不可取的</strong>。</p><p>另外，类似的，假设我们不了解 Spring 的隐式规则，在修正问题后，我们可能写出更多看似可以运行的程序，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Service</span></div><div class="token-line"><span class="token plain">    public class ServiceImpl {</span></div><div class="token-line"><span class="token plain">        private String serviceName;</span></div><div class="token-line"><span class="token plain">        public ServiceImpl(String serviceName){</span></div><div class="token-line"><span class="token plain">            this.serviceName = serviceName;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        public ServiceImpl(String serviceName, String otherStringParameter){</span></div><div class="token-line"><span class="token plain">            this.serviceName = serviceName;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果我们仍用非 Spring 的思维去审阅这段代码，可能不会觉得有什么问题，毕竟 String 类型可以自动装配了，无非就是增加了一个 String 类型的参数而已。</p><p>但是如果你了解 Spring 内部是用反射来构建 Bean 的话，就不难发现问题所在：存在两个构造器，都可以调用时，到底应该调用哪个呢？最终 Spring 无从选择，只能尝试去调用默认构造器，而这个默认构造器又不存在，所以测试这个程序它会出错。</p><h2 id="案例-3原型-bean-被固定"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#案例-3原型-bean-被固定"><span class="icon icon-link"></span></a>案例 3：原型 Bean 被固定</h2><p>接下来，我们再来看另外一个关于 Bean 定义不生效的案例。在定义 Bean 时，有时候我们会使用原型 Bean，例如定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Service</span></div><div class="token-line"><span class="token plain">    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></div><div class="token-line"><span class="token plain">    public class ServiceImpl {</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后我们按照下面的方式去使用它：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RestController</span></div><div class="token-line"><span class="token plain">    public class HelloWorldController {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private ServiceImpl serviceImpl;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">        public String hi(){</span></div><div class="token-line"><span class="token plain">             return &quot;helloworld, service is : &quot; + serviceImpl;</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>结果，我们会发现，不管我们访问多少次<a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/hi">http://localhost:8080/hi<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，访问的结果都是不变的，如下：</p><blockquote><p>helloworld, service is : com.spring.puzzle.class1.example3.error.ServiceImpl@4908af</p></blockquote><p>很明显，这很可能和我们定义 ServiceImpl 为原型 Bean 的初衷背道而驰，如何理解这个现象呢？</p><h3 id="案例解析-2"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#案例解析-2"><span class="icon icon-link"></span></a>案例解析</h3><p>当一个属性成员 serviceImpl 声明为@Autowired 后，那么在创建 HelloWorldController 这个 Bean 时，会先使用构造器反射出实例，然后来装配各个标记为@Autowired 的属性成员（装配方法参考 AbstractAutowireCapableBeanFactory#populateBean）。</p><p>具体到执行过程，它会使用很多 BeanPostProcessor 来做完成工作，其中一种是 AutowiredAnnotationBeanPostProcessor，它会通过 DefaultListableBeanFactory#findAutowireCandidates 寻找到 ServiceImpl 类型的 Bean，然后设置给对应的属性（即 serviceImpl成员）。</p><p>关键执行步骤可参考 AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {</span></div><div class="token-line"><span class="token plain">       Field field = (Field) this.member;</span></div><div class="token-line"><span class="token plain">       Object value;</span></div><div class="token-line"><span class="token plain">       //寻找“bean”</span></div><div class="token-line"><span class="token plain">       if (this.cached) {</span></div><div class="token-line"><span class="token plain">          value = resolvedCachedArgument(beanName, this.cachedFieldValue);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       else {</span></div><div class="token-line"><span class="token plain">         //省略其他非关键代码</span></div><div class="token-line"><span class="token plain">         value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       if (value != null) {</span></div><div class="token-line"><span class="token plain">          //将bean设置给成员字段</span></div><div class="token-line"><span class="token plain">          ReflectionUtils.makeAccessible(field);</span></div><div class="token-line"><span class="token plain">          field.set(bean, value);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>待我们寻找到要自动注入的 Bean 后，即可通过反射设置给对应的field。这个field的执行只发生了一次，所以后续就固定起来了，它并不会因为 ServiceImpl 标记了 SCOPE_PROTOTYPE 而改变。</p><p>所以，<strong>当一个单例的Bean，使用 autowired 注解标记其属性时，你一定要注意这个属性值会被固定下来。</strong></p><h3 id="问题修正-2"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#问题修正-2"><span class="icon icon-link"></span></a>问题修正</h3><p>通过上述源码分析，我们可以知道要修正这个问题，肯定是不能将 ServiceImpl 的 Bean 固定到属性上的，而应该是每次使用时都会重新获取一次。所以这里我提供了两种修正方式：</p><p><strong>1. 自动注入 Context</strong></p><p>即自动注入 ApplicationContext，然后定义 getServiceImpl() 方法，在方法中获取一个新的 ServiceImpl 类型实例。修正代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RestController</span></div><div class="token-line"><span class="token plain">    public class HelloWorldController {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private ApplicationContext applicationContext;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">        public String hi(){</span></div><div class="token-line"><span class="token plain">             return &quot;helloworld, service is : &quot; + getServiceImpl();</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">        public ServiceImpl getServiceImpl(){</span></div><div class="token-line"><span class="token plain">            return applicationContext.getBean(ServiceImpl.class);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><strong>2. 使用 Lookup 注解</strong></p><p>类似修正方法 1，也添加一个 getServiceImpl 方法，不过这个方法是被 Lookup 标记的。修正代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RestController</span></div><div class="token-line"><span class="token plain">    public class HelloWorldController {</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">        @RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">        public String hi(){</span></div><div class="token-line"><span class="token plain">             return &quot;helloworld, service is : &quot; + getServiceImpl();</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Lookup</span></div><div class="token-line"><span class="token plain">        public ServiceImpl getServiceImpl(){</span></div><div class="token-line"><span class="token plain">            return null;</span></div><div class="token-line"><span class="token plain">        }  </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>通过这两种修正方式，再次测试程序，我们会发现结果已经符合预期（每次访问这个接口，都会创建新的 Bean）。</p><p>这里我们不妨再拓展下，讨论下 Lookup 是如何生效的。毕竟在修正代码中，我们看到getServiceImpl方法的实现返回值是 null，这或许很难说服自己。</p><p>首先，我们可以通过调试方式看下方法的执行，参考下图：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage3d913d0e125b9d9e0711489d3a6aeff88c91.2638ee9c.png" alt=""/></p><p>从上图我们可以看出，我们最终的执行因为标记了 Lookup 而走入了 CglibSubclassingInstantiationStrategy.LookupOverrideMethodInterceptor，这个方法的关键实现参考 LookupOverrideMethodInterceptor#intercept：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private final BeanFactory owner;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {</span></div><div class="token-line"><span class="token plain">       LookupOverride lo = (LookupOverride) getBeanDefinition().getMethodOverrides().getOverride(method);</span></div><div class="token-line"><span class="token plain">       Assert.state(lo != null, &quot;LookupOverride not found&quot;);</span></div><div class="token-line"><span class="token plain">       Object[] argsToUse = (args.length &gt; 0 ? args : null);  // if no-arg, don&#x27;t insist on args at all</span></div><div class="token-line"><span class="token plain">       if (StringUtils.hasText(lo.getBeanName())) {</span></div><div class="token-line"><span class="token plain">          return (argsToUse != null ? this.owner.getBean(lo.getBeanName(), argsToUse) :</span></div><div class="token-line"><span class="token plain">                this.owner.getBean(lo.getBeanName()));</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       else {</span></div><div class="token-line"><span class="token plain">          return (argsToUse != null ? this.owner.getBean(method.getReturnType(), argsToUse) :</span></div><div class="token-line"><span class="token plain">                this.owner.getBean(method.getReturnType()));</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们的方法调用最终并没有走入案例代码实现的return null语句，而是通过 BeanFactory 来获取 Bean。所以从这点也可以看出，其实<strong>在我们的 getServiceImpl 方法实现中，随便怎么写都行，这不太重要。</strong></p><p>例如，我们可以使用下面的实现来测试下这个结论：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Lookup</span></div><div class="token-line"><span class="token plain">    public ServiceImpl getServiceImpl(){</span></div><div class="token-line"><span class="token plain">        //下面的日志会输出么？</span></div><div class="token-line"><span class="token plain">        log.info(&quot;executing this method&quot;);</span></div><div class="token-line"><span class="token plain">        return null;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>以上代码，添加了一行代码输出日志。测试后，我们会发现并没有日志输出。这也验证了，当使用 Lookup 注解一个方法时，这个方法的具体实现已并不重要。</p><p>再回溯下前面的分析，为什么我们走入了CGLIB 搞出的类，这是因为我们有方法标记了 Lookup。我们可以从下面的这段代码得到验证，参考 SimpleInstantiationStrategy#instantiate：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Override</span></div><div class="token-line"><span class="token plain">    public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {</span></div><div class="token-line"><span class="token plain">       // Don&#x27;t override the class with CGLIB if no overrides.</span></div><div class="token-line"><span class="token plain">       if (!bd.hasMethodOverrides()) {</span></div><div class="token-line"><span class="token plain">          //</span></div><div class="token-line"><span class="token plain">          return BeanUtils.instantiateClass(constructorToUse);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       else {</span></div><div class="token-line"><span class="token plain">          // Must generate CGLIB subclass.</span></div><div class="token-line"><span class="token plain">          return instantiateWithMethodInjection(bd, beanName, owner);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在上述代码中，当 hasMethodOverrides 为 true 时，则使用 CGLIB。而在本案例中，这个条件的成立在于解析HelloWorldController 这个 Bean 时，我们会发现有方法标记了 Lookup，此时就会添加相应方法到属性methodOverrides 里面去（此过程由 AutowiredAnnotationBeanPostProcessor#determineCandidateConstructors 完成）。</p><p>添加后效果图如下：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimagebcf0bc917a82f62e8686a3c4eca64f89yyf0.7cc53241.png" alt=""/></p><p>以上即为 Lookup 的一些关键实现思路。还有很多细节，例如CGLIB子类如何产生，无法一一解释，有兴趣的话，可以进一步深入研究，留言区等你。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>这节课我们介绍了3个关于Bean定义的经典错误，并分析了其背后原理。</p><p>不难发现，要使用好Spring，就<strong>一定要了解它的一些潜规则</strong>，例如默认扫描Bean的范围、自动装配构造器等等。如果我们不了解这些规则，大多情况下虽然也能工作，但是稍微变化，则可能完全失效，例如在案例1中，我们也只是把Controller从一个包移动到另外一个包，接口就失效了。</p><p>另外，通过这三个案例的分析，我们也能感受到<strong>Spring的很多实现是通过反射来完成的</strong>，了解了这点，对于理解它的源码实现会大有帮助。例如在案例2中，为什么定义了多个构造器就可能报错，因为使用反射方式来创建实例必须要明确使用的是哪一个构造器。</p><p>最后，我想说，在Spring框架中，解决问题的方式往往有多种，不要拘泥于套路。就像案例3，使用ApplicationContext和Lookup注解，都能解决原型 Bean 被固定的问题一样。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/02#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>在案例 2 中，显示定义构造器，这会发生根据构造器参数寻找对应 Bean 的行为。这里请你思考一个问题，假设寻找不到对应的 Bean，一定会如案例 2 那样直接报错么？</p><p>尝试解决一下，我们留言区见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/spring编程常见错误50例/02.SpringCore篇/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:06:36</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-java/umi.fde43fdb.js"></script>
  </body>
</html>
