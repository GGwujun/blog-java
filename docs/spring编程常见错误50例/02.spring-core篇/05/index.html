<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-test/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-test";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>04｜Spring Bean 生命周期常见错误 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/spring编程常见错误50例/02.spring-core篇/05" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a aria-current="page" class="active" href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-test/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-test/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a aria-current="page" class="active" href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-test/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-test/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-test/spring编程常见错误50例/01.课前必读">01.课前必读</a><ul><li><a href="/blog-test/spring编程常见错误50例/01.课前必读/01"><span>开篇词｜贴心“保姆”Spring罢工了怎么办？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-test/spring编程常见错误50例/02.spring-core篇">02.SpringCore篇</a><ul><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/01"><span>导读｜5分钟轻松了解Spring基础知识</span></a></li><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/02"><span>01｜Spring Bean 定义常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/03"><span>02｜Spring Bean 依赖注入常见错误（上）</span></a></li><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/04"><span>03｜Spring Bean 依赖注入常见错误（下）</span></a></li><li><a aria-current="page" class="active" href="/blog-test/spring编程常见错误50例/02.spring-core篇/05"><span>04｜Spring Bean 生命周期常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/06"><span>05｜Spring AOP 常见错误（上）</span></a></li><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/07"><span>06｜Spring AOP 常见错误（下）</span></a></li><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/08"><span>07｜Spring事件常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/09"><span>08｜答疑现场：Spring Core 篇思考题合集</span></a></li></ul></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇">03.SpringWeb篇</a><ul><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/01"><span>导读｜5分钟轻松了解一个HTTP请求的处理过程</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/02"><span>09｜Spring Web URL 解析常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/03"><span>10 | Spring Web Header 解析常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/04"><span>11 | Spring Web Body 转化常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/05"><span>12｜Spring Web 参数验证常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/06"><span>13 | Spring Web 过滤器使用常见错误（上）</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/07"><span>14 | Spring Web 过滤器使用常见错误（下）</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/08"><span>15 | Spring Security 常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/09"><span>16｜Spring Exception 常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/03.spring-web篇/10"><span>17｜答疑现场：Spring Web 篇思考题合集</span></a></li></ul></li><li><a href="/blog-test/spring编程常见错误50例/04.spring补充篇">04.Spring补充篇</a><ul><li><a href="/blog-test/spring编程常见错误50例/04.spring补充篇/01"><span>18 | Spring Data 常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/04.spring补充篇/02"><span>19 | Spring 事务常见错误（上）</span></a></li><li><a href="/blog-test/spring编程常见错误50例/04.spring补充篇/03"><span>20 | Spring 事务常见错误（下）</span></a></li><li><a href="/blog-test/spring编程常见错误50例/04.spring补充篇/04"><span>21 | Spring Rest Template 常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/04.spring补充篇/05"><span>22 | Spring Test 常见错误</span></a></li><li><a href="/blog-test/spring编程常见错误50例/04.spring补充篇/06"><span>23｜答疑现场：Spring 补充篇思考题合集</span></a></li><li><a href="/blog-test/spring编程常见错误50例/04.spring补充篇/07"><span>知识回顾 | 系统梳理Spring编程错误根源</span></a></li></ul></li><li><a href="/blog-test/spring编程常见错误50例/05.结束语">05.结束语</a><ul><li><a href="/blog-test/spring编程常见错误50例/05.结束语/01"><span>结束语｜问题总比解决办法多</span></a></li></ul></li><li><a href="/blog-test/spring编程常见错误50例/06.期末测试">06.期末测试</a><ul><li><a href="/blog-test/spring编程常见错误50例/06.期末测试/01"><span>期末测试｜来赴一场100分之约！</span></a></li></ul></li><li><a href="/blog-test/spring编程常见错误50例/summary">spring编程常见错误50例</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="案例 1：构造器内抛空指针异常" data-depth="2"><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#案例-1构造器内抛空指针异常"><span>案例 1：构造器内抛空指针异常</span></a></li><li title="案例解析" data-depth="3"><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#案例解析"><span>案例解析</span></a></li><li title="问题修正" data-depth="3"><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#问题修正"><span>问题修正</span></a></li><li title="案例 2：意外触发 shutdown 方法" data-depth="2"><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#案例-2意外触发-shutdown-方法"><span>案例 2：意外触发 shutdown 方法</span></a></li><li title="案例解析" data-depth="3"><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#案例解析-1"><span>案例解析</span></a></li><li title="问题修正" data-depth="3"><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#问题修正-1"><span>问题修正</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#重点回顾"><span>重点回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="04spring-bean-生命周期常见错误"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#04spring-bean-生命周期常见错误"><span class="icon icon-link"></span></a>04｜Spring Bean 生命周期常见错误</h1><p>你好，我是傅健，这节课我们来聊一聊 Spring Bean 的初始化过程及销毁过程中的一些问题。</p><p>虽然说 Spring 容器上手简单，可以仅仅通过学习一些有限的注解，即可达到快速使用的目的。但在工程实践中，我们依然会从中发现一些常见的错误。尤其当你对 Spring 的生命周期还没有深入了解时，类初始化及销毁过程中潜在的约定就不会很清楚。</p><p>这会导致这样一些状况发生：有些错误，我们可以在 Spring 的异常提示下快速解决，但却不理解背后的原理；而另一些错误，并不容易在开发环境下被发现，从而在产线上造成较为严重的后果。</p><p>接下来我们就具体解析下这些常见案例及其背后的原理。</p><h2 id="案例-1构造器内抛空指针异常"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#案例-1构造器内抛空指针异常"><span class="icon icon-link"></span></a>案例 1：构造器内抛空指针异常</h2><p>先看个例子。在构建宿舍管理系统时，有 LightMgrService 来管理 LightService，从而控制宿舍灯的开启和关闭。我们希望在 LightMgrService 初始化时能够自动调用 LightService 的 check 方法来检查所有宿舍灯的电路是否正常，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import org.springframework.beans.factory.annotation.Autowired;</span></div><div class="token-line"><span class="token plain">    import org.springframework.stereotype.Component;</span></div><div class="token-line"><span class="token plain">    @Component</span></div><div class="token-line"><span class="token plain">    public class LightMgrService {</span></div><div class="token-line"><span class="token plain">      @Autowired</span></div><div class="token-line"><span class="token plain">      private LightService lightService;</span></div><div class="token-line"><span class="token plain">      public LightMgrService() {</span></div><div class="token-line"><span class="token plain">        lightService.check();</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们在 LightMgrService 的默认构造器中调用了通过 @Autoware 注入的成员变量 LightService 的 check 方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Service</span></div><div class="token-line"><span class="token plain">    public class LightService {</span></div><div class="token-line"><span class="token plain">        public void start() {</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;turn on all lights&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        public void shutdown() {</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;turn off all lights&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        public void check() {</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;check all lights&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>以上代码定义了 LightService 对象的原始类。</p><p>从整个案例代码实现来看，我们的期待是在 LightMgrService 初始化过程中，LightService 因为标记为 @Autowired，所以能被自动装配好；然后在 LightMgrService 的构造器执行中，LightService 的 shutdown() 方法能被自动调用；最终打印出 check all lights。</p><p>然而事与愿违，我们得到的只会是 NullPointerException，错误示例如下：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage4d4e4d4cecc9c82abaaa4f04cdb274c05e4e.94d52b93.png" alt=""/></p><p>这是为什么呢？</p><h3 id="案例解析"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#案例解析"><span class="icon icon-link"></span></a>案例解析</h3><p>显然这是新手最常犯的错误，但是问题的根源，是我们<strong>对Spring类初始化过程没有足够的了解</strong>。下面这张时序图描述了 Spring 启动时的一些关键结点：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage6f8a6ff70ab627711065bc17c54c001ef08a.c8f76a4f.png" alt=""/></p><p>这个图初看起来复杂，我们不妨将其分为三部分：</p><ul><li>第一部分，将一些必要的系统类，比如 Bean 的后置处理器类，注册到 Spring 容器，其中就包括我们这节课关注的 CommonAnnotationBeanPostProcessor 类；</li><li>第二部分，将这些后置处理器实例化，并注册到 Spring 的容器中；</li><li>第三部分，实例化所有用户定制类，调用后置处理器进行辅助装配、类初始化等等。</li></ul><p>第一部分和第二部分并非是我们今天要讨论的重点，这里仅仅是为了让你知道 CommonAnnotationBeanPostProcessor 这个后置处理类是何时被 Spring 加载和实例化的。</p><p><strong>这里我顺便给你拓展两个知识点：</strong></p><ol><li>很多必要的系统类，尤其是 Bean 后置处理器（比如CommonAnnotationBeanPostProcessor、AutowiredAnnotationBeanPostProcessor 等），都是被 Spring 统一加载和管理的，并在 Spring 中扮演了非常重要的角色；</li><li>通过 Bean 后置处理器，Spring 能够非常灵活地在不同的场景调用不同的后置处理器，比如接下来我会讲到示例问题如何修正，修正方案中提到的 PostConstruct 注解，它的处理逻辑就需要用到 CommonAnnotationBeanPostProcessor（继承自 InitDestroyAnnotationBeanPostProcessor）这个后置处理器。</li></ol><p>现在我们重点看下第三部分，即 Spring 初始化单例类的一般过程，基本都是 getBean()-&gt;doGetBean()-&gt;getSingleton()，如果发现 Bean 不存在，则调用 createBean()-&gt;doCreateBean() 进行实例化。</p><p>查看 doCreateBean() 的源代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)</span></div><div class="token-line"><span class="token plain">    		throws BeanCreationException {</span></div><div class="token-line"><span class="token plain">        //省略非关键代码</span></div><div class="token-line"><span class="token plain">    	if (instanceWrapper == null) {</span></div><div class="token-line"><span class="token plain">    		instanceWrapper = createBeanInstance(beanName, mbd, args);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	final Object bean = instanceWrapper.getWrappedInstance();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //省略非关键代码</span></div><div class="token-line"><span class="token plain">        Object exposedObject = bean;</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">           populateBean(beanName, mbd, instanceWrapper);</span></div><div class="token-line"><span class="token plain">           exposedObject = initializeBean(beanName, exposedObject, mbd);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        catch (Throwable ex) {</span></div><div class="token-line"><span class="token plain">        //省略非关键代码</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码完整地展示了 Bean 初始化的三个关键步骤，按执行顺序分别是第 5 行的 createBeanInstance，第 12 行的 populateBean，以及第 13 行的 initializeBean，分别对应实例化 Bean，注入 Bean 依赖，以及初始化 Bean （例如执行 @PostConstruct 标记的方法 ）这三个功能，这也和上述时序图的流程相符。</p><p>而用来实例化 Bean 的 createBeanInstance 方法通过依次调用DefaultListableBeanFactory.instantiateBean() &gt;SimpleInstantiationStrategy.instantiate()，最终执行到 BeanUtils.instantiateClass()，其代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public static &lt;T&gt; T instantiateClass(Constructor&lt;T&gt; ctor, Object... args) throws BeanInstantiationException {</span></div><div class="token-line"><span class="token plain">       Assert.notNull(ctor, &quot;Constructor must not be null&quot;);</span></div><div class="token-line"><span class="token plain">       try {</span></div><div class="token-line"><span class="token plain">          ReflectionUtils.makeAccessible(ctor);</span></div><div class="token-line"><span class="token plain">          return (KotlinDetector.isKotlinReflectPresent() &amp;&amp; KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?</span></div><div class="token-line"><span class="token plain">                KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args));</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       catch (InstantiationException ex) {</span></div><div class="token-line"><span class="token plain">          throw new BeanInstantiationException(ctor, &quot;Is it an abstract class?&quot;, ex);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       //省略非关键代码</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里因为当前的语言并非 Kotlin，所以最终将调用 ctor.newInstance() 方法实例化用户定制类 LightMgrService，而默认构造器显然是在类实例化的时候被自动调用的，Spring 也无法控制。而此时负责自动装配的 populateBean 方法还没有被执行，LightMgrService 的属性 LightService 还是 null，因而得到空指针异常也在情理之中。</p><h3 id="问题修正"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#问题修正"><span class="icon icon-link"></span></a>问题修正</h3><p>通过源码分析，现在我们知道了问题的根源，就是在于<strong>使用 @Autowired 直接标记在成员属性上而引发的装配行为是发生在构造器执行之后的</strong>。所以这里我们可以通过下面这种修订方法来纠正这个问题：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Component</span></div><div class="token-line"><span class="token plain">    public class LightMgrService {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        private LightService lightService;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public LightMgrService(LightService lightService) {</span></div><div class="token-line"><span class="token plain">            this.lightService = lightService;</span></div><div class="token-line"><span class="token plain">            lightService.check();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/366170">第02课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的案例 2 中，我们就提到了构造器参数的隐式注入。当使用上面的代码时，构造器参数 LightService 会被自动注入LightService 的 Bean，从而在构造器执行时，不会出现空指针。可以说，<strong>使用构造器参数来隐式注入是一种 Spring 最佳实践</strong>，因为它成功地规避了案例1中的问题。</p><p>另外，除了这种纠正方式，有没有别的方式？</p><p>实际上，Spring 在类属性完成注入之后，会回调用户定制的初始化方法。即在 populateBean 方法之后，会调用 initializeBean 方法，我们来看一下它的关键代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {</span></div><div class="token-line"><span class="token plain">       //省略非关键代码 </span></div><div class="token-line"><span class="token plain">       if (mbd == null || !mbd.isSynthetic()) {</span></div><div class="token-line"><span class="token plain">          wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       try {</span></div><div class="token-line"><span class="token plain">          invokeInitMethods(beanName, wrappedBean, mbd);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       //省略非关键代码 </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里你可以看到 applyBeanPostProcessorsBeforeInitialization 和 invokeInitMethods 这两个关键方法的执行，它们分别处理了 @PostConstruct 注解和 InitializingBean 接口这两种不同的初始化方案的逻辑。这里我再详细地给你讲讲。</p><p><strong>1. applyBeanPostProcessorsBeforeInitialization 与@PostConstruct</strong></p><p>applyBeanPostProcessorsBeforeInitialization 方法最终执行到后置处理器 InitDestroyAnnotationBeanPostProcessor 的 buildLifecycleMetadata 方法（CommonAnnotationBeanPostProcessor 的父类）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private LifecycleMetadata buildLifecycleMetadata(final Class&lt;?&gt; clazz) {</span></div><div class="token-line"><span class="token plain">       //省略非关键代码 </span></div><div class="token-line"><span class="token plain">       do {</span></div><div class="token-line"><span class="token plain">          //省略非关键代码</span></div><div class="token-line"><span class="token plain">          final List&lt;LifecycleElement&gt; currDestroyMethods = new ArrayList&lt;&gt;();</span></div><div class="token-line"><span class="token plain">          ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; {</span></div><div class="token-line"><span class="token plain">          //此处的 this.initAnnotationType 值，即为 PostConstruct.class</span></div><div class="token-line"><span class="token plain">             if (this.initAnnotationType != null &amp;&amp; method.isAnnotationPresent(this.initAnnotationType)) {</span></div><div class="token-line"><span class="token plain">                LifecycleElement element = new LifecycleElement(method);</span></div><div class="token-line"><span class="token plain">                currInitMethods.add(element);</span></div><div class="token-line"><span class="token plain">      //非关键代码          </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这个方法里，Spring 将遍历查找被 PostConstruct.class 注解过的方法，返回到上层，并最终调用此方法。</p><p><strong>2. invokeInitMethods 与 InitializingBean 接口</strong></p><p>invokeInitMethods 方法会判断当前 Bean 是否实现了 InitializingBean 接口，只有在实现了该接口的情况下，Spring 才会调用该 Bean 的接口实现方法 afterPropertiesSet()。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">protected void invokeInitMethods(String beanName, final Object bean, @Nullable RootBeanDefinition mbd)</span></div><div class="token-line"><span class="token plain">          throws Throwable {</span></div><div class="token-line"><span class="token plain">       boolean isInitializingBean = (bean instanceof InitializingBean);</span></div><div class="token-line"><span class="token plain">       if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) {</span></div><div class="token-line"><span class="token plain">          // 省略非关键代码 </span></div><div class="token-line"><span class="token plain">          else {</span></div><div class="token-line"><span class="token plain">             ((InitializingBean) bean).afterPropertiesSet();</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       // 省略非关键代码 </span></div><div class="token-line"><span class="token plain">     }</span></div></pre></div><p>学到此处，答案也就呼之欲出了。我们还有两种方式可以解决此问题。</p><ol><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">添加 init 方法，并且使用 PostConstruct 注解进行修饰：</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import org.springframework.beans.factory.annotation.Autowired;</span></div><div class="token-line"><span class="token plain">    import org.springframework.stereotype.Component;</span></div><div class="token-line"><span class="token plain">    @Component</span></div><div class="token-line"><span class="token plain">    public class LightMgrService {</span></div><div class="token-line"><span class="token plain">      @Autowired</span></div><div class="token-line"><span class="token plain">      private LightService lightService;</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      @PostConstruct</span></div><div class="token-line"><span class="token plain">      public void init() {</span></div><div class="token-line"><span class="token plain">           lightService.check();</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ol start="2"><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">实现 InitializingBean 接口，在其 afterPropertiesSet\(\) 方法中执行初始化代码：</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import org.springframework.beans.factory.InitializingBean;</span></div><div class="token-line"><span class="token plain">    import org.springframework.beans.factory.annotation.Autowired;</span></div><div class="token-line"><span class="token plain">    import org.springframework.stereotype.Component;</span></div><div class="token-line"><span class="token plain">    @Component</span></div><div class="token-line"><span class="token plain">    public class LightMgrService implements InitializingBean {</span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private LightService lightService;</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void afterPropertiesSet() throws Exception {</span></div><div class="token-line"><span class="token plain">            lightService.check();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>对比最开始提出的解决方案，很明显，针对本案例而言，后续的两种方案并不是最优的。但是在一些场景下，这两种方案各有所长，不然 Spring 为什么要提供这个功能呢？对吧！</p><h2 id="案例-2意外触发-shutdown-方法"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#案例-2意外触发-shutdown-方法"><span class="icon icon-link"></span></a>案例 2：意外触发 shutdown 方法</h2><p>上述实例我给你讲解了类初始化时最容易遇到的问题，同样，在类销毁时，也会有一些相对隐蔽的约定，导致一些难以察觉的错误。</p><p>接下来，我们再来看一个案例，还是沿用之前的场景。这里我们可以简单复习一下LightService 的实现，它包含了 shutdown 方法，负责关闭所有的灯，关键代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import org.springframework.stereotype.Service;</span></div><div class="token-line"><span class="token plain">    @Service</span></div><div class="token-line"><span class="token plain">    public class LightService {</span></div><div class="token-line"><span class="token plain">      //省略其他非关键代码</span></div><div class="token-line"><span class="token plain">      public void shutdown(){</span></div><div class="token-line"><span class="token plain">        System.out.println(&quot;shutting down all lights&quot;);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      //省略其他非关键代码</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在之前的案例中，如果我们的宿舍管理系统在重启时，灯是不会被关闭的。但是随着业务的需求变化，我们可能会去掉 @Service 注解，而是使用另外一种产生 Bean 的方式：创建一个配置类 BeanConfiguration（标记 @Configuration）来创建一堆 Bean，其中就包含了创建 LightService 类型的 Bean，并将其注册到 Spring 容器：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import org.springframework.context.annotation.Bean;</span></div><div class="token-line"><span class="token plain">    import org.springframework.context.annotation.Configuration;</span></div><div class="token-line"><span class="token plain">    @Configuration</span></div><div class="token-line"><span class="token plain">    public class BeanConfiguration {</span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public LightService getTransmission(){</span></div><div class="token-line"><span class="token plain">            return new LightService();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>复用案例 1 的启动程序，稍作修改，让 Spring 启动完成后立马关闭当前 Spring 上下文。这样等同于模拟宿舍管理系统的启停：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@SpringBootApplication</span></div><div class="token-line"><span class="token plain">    public class Application {</span></div><div class="token-line"><span class="token plain">        public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">            ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);</span></div><div class="token-line"><span class="token plain">            context.close();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>以上代码没有其他任何方法的调用，仅仅是将所有符合约定的类初始化并加载到 Spring 容器，完成后再关闭当前的 Spring 容器。按照预期，这段代码运行后不会有任何的 log 输出，毕竟我们只是改变了 Bean 的产生方式。</p><p>但实际运行这段代码后，我们可以看到控制台上打印了 shutting down all lights。显然 shutdown 方法未按照预期被执行了，这导致一个很有意思的 bug：在使用新的 Bean 生成方式之前，每一次宿舍管理服务被重启时，宿舍里所有的灯都不会被关闭。但是修改后，只有服务重启，灯都被意外关闭了。如何理解这个 bug?</p><h3 id="案例解析-1"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#案例解析-1"><span class="icon icon-link"></span></a>案例解析</h3><p>通过调试，我们发现只有通过使用 Bean 注解注册到 Spring 容器的对象，才会在 Spring 容器被关闭的时候自动调用 shutdown 方法，而使用 @Component（Service 也是一种 Component）将当前类自动注入到 Spring 容器时，shutdown 方法则不会被自动执行。</p><p>我们可以尝试到 Bean 注解类的代码中去寻找一些线索，可以看到属性 destroyMethod 有非常大段的注释，基本上解答了我们对于这个问题的大部分疑惑。</p><p>使用 Bean 注解的方法所注册的 Bean 对象，如果用户不设置 destroyMethod 属性，则其属性值为 AbstractBeanDefinition.INFER_METHOD。此时 Spring 会检查当前 Bean 对象的原始类中是否有名为 shutdown 或者 close 的方法，如果有，此方法会被 Spring 记录下来，并在容器被销毁时自动执行；当然如若没有，那么自然什么都不会发生。</p><p>下面我们继续查看 Spring 的源代码来进一步分析此问题。</p><p>首先我们可以查找 INFER_METHOD 枚举值的引用，很容易就找到了使用该枚举值的方法 DisposableBeanAdapter#inferDestroyMethodIfNecessary：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private String inferDestroyMethodIfNecessary(Object bean, RootBeanDefinition beanDefinition) {</span></div><div class="token-line"><span class="token plain">       String destroyMethodName = beanDefinition.getDestroyMethodName();</span></div><div class="token-line"><span class="token plain">       if (AbstractBeanDefinition.INFER_METHOD.equals(destroyMethodName) ||(destroyMethodName == null &amp;&amp; bean instanceof AutoCloseable)) {</span></div><div class="token-line"><span class="token plain">          if (!(bean instanceof DisposableBean)) {</span></div><div class="token-line"><span class="token plain">             try {</span></div><div class="token-line"><span class="token plain">                //尝试查找 close 方法</span></div><div class="token-line"><span class="token plain">                return bean.getClass().getMethod(CLOSE_METHOD_NAME).getName();</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             catch (NoSuchMethodException ex) {</span></div><div class="token-line"><span class="token plain">                try {</span></div><div class="token-line"><span class="token plain">                   //尝试查找 shutdown 方法</span></div><div class="token-line"><span class="token plain">                   return bean.getClass().getMethod(SHUTDOWN_METHOD_NAME).getName();</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">                catch (NoSuchMethodException ex2) {</span></div><div class="token-line"><span class="token plain">                   // no candidate destroy method found</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          return null;</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return (StringUtils.hasLength(destroyMethodName) ? destroyMethodName : null);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们可以看到，代码逻辑和 Bean 注解类中对于 destroyMethod 属性的注释完全一致destroyMethodName 如果等于 INFER_METHOD，且当前类没有实现 DisposableBean 接口，那么首先查找类的 close 方法，如果找不到，就在抛出异常后继续查找 shutdown 方法；如果找到了，则返回其方法名（close 或者 shutdown）。</p><p>接着，继续逐级查找引用，最终得到的调用链从上到下为 doCreateBean-&gt;registerDisposableBeanIfNecessary-&gt;registerDisposableBean(new DisposableBeanAdapter)-&gt;inferDestroyMethodIfNecessary。</p><p>然后，我们追溯到了顶层的 doCreateBean 方法，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)</span></div><div class="token-line"><span class="token plain">          throws BeanCreationException {</span></div><div class="token-line"><span class="token plain">       //省略非关键代码 </span></div><div class="token-line"><span class="token plain">       if (instanceWrapper == null) {</span></div><div class="token-line"><span class="token plain">          instanceWrapper = createBeanInstance(beanName, mbd, args);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       //省略非关键代码</span></div><div class="token-line"><span class="token plain">       // Initialize the bean instance.</span></div><div class="token-line"><span class="token plain">       Object exposedObject = bean;</span></div><div class="token-line"><span class="token plain">       try {</span></div><div class="token-line"><span class="token plain">          populateBean(beanName, mbd, instanceWrapper);</span></div><div class="token-line"><span class="token plain">          exposedObject = initializeBean(beanName, exposedObject, mbd);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       //省略非关键代码 </span></div><div class="token-line"><span class="token plain">       // Register bean as disposable.</span></div><div class="token-line"><span class="token plain">       try {</span></div><div class="token-line"><span class="token plain">          registerDisposableBeanIfNecessary(beanName, bean, mbd);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       catch (BeanDefinitionValidationException ex) {</span></div><div class="token-line"><span class="token plain">          throw new BeanCreationException(</span></div><div class="token-line"><span class="token plain">                mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       return exposedObject;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>到这，我们就可以对 doCreateBean 方法做一个小小的总结了。可以说 <strong>doCreateBean 管理了Bean的整个生命周期中几乎所有的关键节点</strong>，直接负责了 Bean 对象的生老病死，其主要功能包括：</p><ul><li>Bean 实例的创建；</li><li>Bean 对象依赖的注入；</li><li>定制类初始化方法的回调；</li><li>Disposable 方法的注册。</li></ul><p>接着，继续查看 registerDisposableBean 方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public void registerDisposableBean(String beanName, DisposableBean bean) {</span></div><div class="token-line"><span class="token plain">       //省略其他非关键代码</span></div><div class="token-line"><span class="token plain">       synchronized (this.disposableBeans) {</span></div><div class="token-line"><span class="token plain">          this.disposableBeans.put(beanName, bean);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       //省略其他非关键代码</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在 registerDisposableBean 方法内，DisposableBeanAdapter 类（其属性destroyMethodName 记录了使用哪种 destory 方法）被实例化并添加到 DefaultSingletonBeanRegistry#disposableBeans 属性内，disposableBeans 将暂存这些 DisposableBeanAdapter 实例，直到 AnnotationConfigApplicationContext 的 close 方法被调用。</p><p>而当 AnnotationConfigApplicationContext 的 close 方法被调用时，即当 Spring 容器被销毁时，最终会调用到 DefaultSingletonBeanRegistry#destroySingleton。此方法将遍历 disposableBeans 属性逐一获取 DisposableBean，依次调用其中的 close 或者 shutdown 方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public void destroySingleton(String beanName) {</span></div><div class="token-line"><span class="token plain">       // Remove a registered singleton of the given name, if any.</span></div><div class="token-line"><span class="token plain">       removeSingleton(beanName);</span></div><div class="token-line"><span class="token plain">       // Destroy the corresponding DisposableBean instance.</span></div><div class="token-line"><span class="token plain">       DisposableBean disposableBean;</span></div><div class="token-line"><span class="token plain">       synchronized (this.disposableBeans) {</span></div><div class="token-line"><span class="token plain">          disposableBean = (DisposableBean) this.disposableBeans.remove(beanName);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       destroyBean(beanName, disposableBean);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>很明显，最终我们的案例调用了 LightService#shutdown 方法，将所有的灯关闭了。</p><h3 id="问题修正-1"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#问题修正-1"><span class="icon icon-link"></span></a>问题修正</h3><p>现在，我们已经知道了问题的根源，解决起来就非常简单了。</p><p>我们可以通过<strong>避免在Java类中定义一些带有特殊意义动词的方法来解决</strong>，当然如果一定要定义名为 close 或者 shutdown 方法，也可以通过将 Bean 注解内 destroyMethod 属性设置为空的方式来解决这个问题。</p><p>第一种修改方式比较简单，所以这里只展示第二种修改方式，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import org.springframework.context.annotation.Bean;</span></div><div class="token-line"><span class="token plain">    import org.springframework.context.annotation.Configuration;</span></div><div class="token-line"><span class="token plain">    @Configuration</span></div><div class="token-line"><span class="token plain">    public class BeanConfiguration {</span></div><div class="token-line"><span class="token plain">        @Bean(destroyMethod=&quot;&quot;)</span></div><div class="token-line"><span class="token plain">        public LightService getTransmission(){</span></div><div class="token-line"><span class="token plain">            return new LightService();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>另外，针对这个问题我想再多提示一点。如果我们能<strong>养成良好的编码习惯</strong>，在使用某个不熟悉的注解之前，认真研读一下该注解的注释，也可以大概率规避这个问题。</p><p>不过说到这里，你也可能还是会疑惑，为什么 @Service 注入的 LightService，其 shutdown 方法不能被执行？这里我想补充说明下。</p><p>想要执行，则必须要添加 DisposableBeanAdapter，而它的添加是有条件的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {</span></div><div class="token-line"><span class="token plain">       AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null);</span></div><div class="token-line"><span class="token plain">       if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) {</span></div><div class="token-line"><span class="token plain">          if (mbd.isSingleton()) {</span></div><div class="token-line"><span class="token plain">             // Register a DisposableBean implementation that performs all destruction</span></div><div class="token-line"><span class="token plain">             // work for the given bean: DestructionAwareBeanPostProcessors,</span></div><div class="token-line"><span class="token plain">             // DisposableBean interface, custom destroy method.</span></div><div class="token-line"><span class="token plain">             registerDisposableBean(beanName,</span></div><div class="token-line"><span class="token plain">                   new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          else {</span></div><div class="token-line"><span class="token plain">            //省略非关键代码</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>参考上述代码，关键的语句在于：</p><blockquote><p>!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)</p></blockquote><p>很明显，在案例代码修改前后，我们都是单例，所以区别仅在于是否满足requiresDestruction 条件。翻阅它的代码，最终的关键调用参考DisposableBeanAdapter#hasDestroyMethod：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public static boolean hasDestroyMethod(Object bean, RootBeanDefinition beanDefinition) {</span></div><div class="token-line"><span class="token plain">       if (bean instanceof DisposableBean || bean instanceof AutoCloseable) {</span></div><div class="token-line"><span class="token plain">          return true;</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       String destroyMethodName = beanDefinition.getDestroyMethodName();</span></div><div class="token-line"><span class="token plain">       if (AbstractBeanDefinition.INFER_METHOD.equals(destroyMethodName)) {</span></div><div class="token-line"><span class="token plain">          return (ClassUtils.hasMethod(bean.getClass(), CLOSE_METHOD_NAME) ||</span></div><div class="token-line"><span class="token plain">                ClassUtils.hasMethod(bean.getClass(), SHUTDOWN_METHOD_NAME));</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return StringUtils.hasLength(destroyMethodName);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果我们是使用 @Service 来产生 Bean 的，那么在上述代码中我们获取的destroyMethodName 其实是 null；而使用 @Bean 的方式，默认值为AbstractBeanDefinition.INFER_METHOD，参考 Bean 的定义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public @interface Bean {</span></div><div class="token-line"><span class="token plain">       //省略其他非关键代码</span></div><div class="token-line"><span class="token plain">       String destroyMethod() default AbstractBeanDefinition.INFER_METHOD;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>继续对照代码，你就会发现 @Service 标记的 LightService 也没有实现 AutoCloseable、DisposableBean，最终没有添加一个 DisposableBeanAdapter。所以最终我们定义的 shutdown 方法没有被调用。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>通过以上两个案例，相信你对 Spring 生命周期，尤其是对于 Bean 的初始化和销毁流程已经有了一定的了解。这里带你再次回顾下重点：</p><ol><li>DefaultListableBeanFactory 类是 Spring Bean 的灵魂，而核心就是其中的 doCreateBean 方法，它掌控了 Bean 实例的创建、Bean 对象依赖的注入、定制类初始化方法的回调以及 Disposable 方法的注册等全部关键节点。</li><li>后置处理器是 Spring 中最优雅的设计之一，对于很多功能注解的处理都是借助于后置处理器来完成的。虽然这节课对其没有过多介绍，但在第一个案例中，Bean 对象“补充”初始化动作却是在 CommonAnnotationBeanPostProcessor（继承自 InitDestroyAnnotationBeanPostProcessor）这个后置处理器中完成的。</li></ol><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-test/spring编程常见错误50例/02.spring-core篇/05#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>案例 2 中的类 LightService，当我们不在 Configuration 注解类中使用 Bean 方法将其注入 Spring 容器，而是坚持使用 @Service 将其自动注入到容器，同时实现 Closeable 接口，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import org.springframework.stereotype.Component;</span></div><div class="token-line"><span class="token plain">    import java.io.Closeable;</span></div><div class="token-line"><span class="token plain">    @Service</span></div><div class="token-line"><span class="token plain">    public class LightService implements Closeable {</span></div><div class="token-line"><span class="token plain">        public void close() {</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;turn off all lights);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //省略非关键代码</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接口方法 close() 也会在 Spring 容器被销毁的时候自动执行么？</p><p>我在留言区期待你的答案！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/spring编程常见错误50例/02.SpringCore篇/05.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 09:43:57</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-test/umi.3ded5539.js"></script>
  </body>
</html>
