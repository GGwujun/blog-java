<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-java/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-java";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>07｜Spring事件常见错误 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/spring编程常见错误50例/02.spring-core篇/08" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a aria-current="page" class="active" href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a aria-current="page" class="active" href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/spring编程常见错误50例/01.课前必读">01.课前必读</a><ul><li><a href="/blog-java/spring编程常见错误50例/01.课前必读/01"><span>开篇词｜贴心“保姆”Spring罢工了怎么办？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-java/spring编程常见错误50例/02.spring-core篇">02.SpringCore篇</a><ul><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/01"><span>导读｜5分钟轻松了解Spring基础知识</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/02"><span>01｜Spring Bean 定义常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/03"><span>02｜Spring Bean 依赖注入常见错误（上）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/04"><span>03｜Spring Bean 依赖注入常见错误（下）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/05"><span>04｜Spring Bean 生命周期常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/06"><span>05｜Spring AOP 常见错误（上）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/07"><span>06｜Spring AOP 常见错误（下）</span></a></li><li><a aria-current="page" class="active" href="/blog-java/spring编程常见错误50例/02.spring-core篇/08"><span>07｜Spring事件常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/09"><span>08｜答疑现场：Spring Core 篇思考题合集</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇">03.SpringWeb篇</a><ul><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/01"><span>导读｜5分钟轻松了解一个HTTP请求的处理过程</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/02"><span>09｜Spring Web URL 解析常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/03"><span>10 | Spring Web Header 解析常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/04"><span>11 | Spring Web Body 转化常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/05"><span>12｜Spring Web 参数验证常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/06"><span>13 | Spring Web 过滤器使用常见错误（上）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/07"><span>14 | Spring Web 过滤器使用常见错误（下）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/08"><span>15 | Spring Security 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/09"><span>16｜Spring Exception 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/10"><span>17｜答疑现场：Spring Web 篇思考题合集</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇">04.Spring补充篇</a><ul><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/01"><span>18 | Spring Data 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/02"><span>19 | Spring 事务常见错误（上）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/03"><span>20 | Spring 事务常见错误（下）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/04"><span>21 | Spring Rest Template 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/05"><span>22 | Spring Test 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/06"><span>23｜答疑现场：Spring 补充篇思考题合集</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/07"><span>知识回顾 | 系统梳理Spring编程错误根源</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/05.结束语">05.结束语</a><ul><li><a href="/blog-java/spring编程常见错误50例/05.结束语/01"><span>结束语｜问题总比解决办法多</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/06.期末测试">06.期末测试</a><ul><li><a href="/blog-java/spring编程常见错误50例/06.期末测试/01"><span>期末测试｜来赴一场100分之约！</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/summary">spring编程常见错误50例</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="案例1：试图处理并不会抛出的事件" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#案例1试图处理并不会抛出的事件"><span>案例1：试图处理并不会抛出的事件</span></a></li><li title="案例解析" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#案例解析"><span>案例解析</span></a></li><li title="问题修正" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#问题修正"><span>问题修正</span></a></li><li title="案例2：监听事件的体系不对" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#案例2监听事件的体系不对"><span>案例2：监听事件的体系不对</span></a></li><li title="案例解析" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#案例解析-1"><span>案例解析</span></a></li><li title="问题修正" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#问题修正-1"><span>问题修正</span></a></li><li title="案例3：部分事件监听器失效" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#案例3部分事件监听器失效"><span>案例3：部分事件监听器失效</span></a></li><li title="案例解析" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#案例解析-2"><span>案例解析</span></a></li><li title="问题修正" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#问题修正-2"><span>问题修正</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#重点回顾"><span>重点回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="07spring事件常见错误"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#07spring事件常见错误"><span class="icon icon-link"></span></a>07｜Spring事件常见错误</h1><p>你好，我是傅健，这节课我们聊聊Spring事件上的常见错误。</p><p>前面的几讲中，我们介绍了Spring依赖注入、AOP等核心功能点上的常见错误。而作为Spring 的关键功能支撑，Spring事件是一个相对独立的点。或许你从没有在自己的项目中使用过Spring事件，但是你一定见过它的相关日志。而且在未来的编程实践中，你会发现，一旦你用上了Spring事件，往往完成的都是一些有趣的、强大的功能，例如动态配置。那么接下来我就来讲讲Spring事件上都有哪些常见的错误。</p><h2 id="案例1试图处理并不会抛出的事件"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#案例1试图处理并不会抛出的事件"><span class="icon icon-link"></span></a>案例1：试图处理并不会抛出的事件</h2><p>Spring事件的设计比较简单。说白了，就是监听器设计模式在Spring中的一种实现，参考下图：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage34c6349f79e396276ab3744c04b0a29eccc6.7c2f729f.jpg" alt=""/></p><p>从图中我们可以看出，Spring事件包含以下三大组件。</p><ol><li>事件（Event）：用来区分和定义不同的事件，在Spring中，常见的如ApplicationEvent和AutoConfigurationImportEvent，它们都继承于java.util.EventObject。</li><li>事件广播器（Multicaster）：负责发布上述定义的事件。例如，负责发布ApplicationEvent 的ApplicationEventMulticaster就是Spring中一种常见的广播器。</li><li>事件监听器（Listener）：负责监听和处理广播器发出的事件，例如ApplicationListener就是用来处理ApplicationEventMulticaster发布的ApplicationEvent，它继承于JDK的 EventListener，我们可以看下它的定义来验证这个结论：</li></ol><blockquote><p>public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener <!-- -->{<br/>void onApplicationEvent(E event);<br/>}</p></blockquote><p>当然，虽然在上述组件中，任何一个都是缺一不可的，但是功能模块命名不见得完全贴合上述提及的关键字，例如发布AutoConfigurationImportEvent的广播器就不含有Multicaster字样。它的发布是由AutoConfigurationImportSelector来完成的。</p><p>对这些基本概念和实现有了一定的了解后，我们就可以开始解析那些常见的错误。闲话少说，我们先来看下面这段基于Spring Boot技术栈的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Slf4j</span></div><div class="token-line"><span class="token plain">    @Component</span></div><div class="token-line"><span class="token plain">    public class MyContextStartedEventListener implements ApplicationListener&lt;ContextStartedEvent&gt; {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      public void onApplicationEvent(final ContextStartedEvent event) {</span></div><div class="token-line"><span class="token plain">        log.info(&quot;{} received: {}&quot;, this.toString(), event);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>很明显，这段代码定义了一个监听器MyContextStartedEventListener，试图拦截ContextStartedEvent。因为在很多Spring初级开发者眼中，Spring运转的核心就是一个Context的维护，那么启动Spring自然会启动Context，于是他们是很期待出现类似下面的日志的：</p><blockquote><p>2021-03-07 07:08:21.197 INFO 2624 --- [nio-8080-exec-1] c.s.p.l.e.MyContextStartedEventListener : com.spring.puzzle.class7.example1.MyContextStartedEventListener@d33d5a <strong>received</strong>: org.springframework.context.event.<strong>ContextStartedEvent</strong>[source=org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@19b56c0, started on Sun Mar 07 07:07:57 CST 2021]</p></blockquote><p>但是当我们启动Spring Boot后，会发现并不会拦截到这个事件，如何理解这个错误呢？</p><h3 id="案例解析"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#案例解析"><span class="icon icon-link"></span></a>案例解析</h3><p>在Spring事件运用上，这是一个常见的错误，就是不假思索地认为一个框架只要定义了一个事件，那么一定会抛出来。例如，在本案例中，ContextStartedEvent就是Spring内置定义的事件，而Spring Boot本身会创建和运维Context，表面看起来这个事件的抛出是必然的，但是这个事件一定会在Spring Boot启动时抛出来么？</p><p>答案明显是否定的，我们首先看下要抛出这个事件需要调用的方法是什么？在Spring Boot中，这个事件的抛出只发生在一处，即位于方法AbstractApplicationContext#start中。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Override</span></div><div class="token-line"><span class="token plain">    public void start() {</span></div><div class="token-line"><span class="token plain">       getLifecycleProcessor().start();</span></div><div class="token-line"><span class="token plain">       publishEvent(new ContextStartedEvent(this));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>也就是说，只有上述方法被调用，才会抛出ContextStartedEvent，但是这个方法在Spring Boot启动时会被调用么？我们可以查看Spring启动方法中围绕Context的关键方法调用，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public ConfigurableApplicationContext run(String... args) {</span></div><div class="token-line"><span class="token plain">          //省略非关键代码</span></div><div class="token-line"><span class="token plain">          context = createApplicationContext();</span></div><div class="token-line"><span class="token plain">          //省略非关键代码</span></div><div class="token-line"><span class="token plain">          prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span></div><div class="token-line"><span class="token plain">          refreshContext(context);</span></div><div class="token-line"><span class="token plain">          //省略非关键代码 </span></div><div class="token-line"><span class="token plain">          return context;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们发现围绕Context、Spring Boot的启动只做了两个关键工作：创建Context和Refresh Context。其中Refresh的关键代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">protected void refresh(ApplicationContext applicationContext) {</span></div><div class="token-line"><span class="token plain">       Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</span></div><div class="token-line"><span class="token plain">       ((AbstractApplicationContext) applicationContext).refresh();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>很明显，Spring启动最终调用的是AbstractApplicationContext#refresh，并不是 AbstractApplicationContext#start。在这样的残酷现实下，ContextStartedEvent自然不会被抛出，不抛出，自然也不可能被捕获。所以这样的错误也就自然发生了。</p><h3 id="问题修正"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#问题修正"><span class="icon icon-link"></span></a>问题修正</h3><p>针对这个案例，有了源码的剖析，我们可以很快找到问题发生的原因，但是修正这个问题还要去追溯我们到底想要的是什么？我们可以分两种情况来考虑。</p><p><strong>1. 假设我们是误读了ContextStartedEvent。</strong></p><p>针对这种情况，往往是因为我们确实想在Spring Boot启动时拦截一个启动事件，但是我们粗略扫视相关事件后，误以为ContextStartedEvent就是我们想要的。针对这种情况，我们只需要把监听事件的类型修改成真正发生的事件即可，例如在本案例中，我们可以修正如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Component</span></div><div class="token-line"><span class="token plain">    public class MyContextRefreshedEventListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      public void onApplicationEvent(final ContextRefreshedEvent event) {</span></div><div class="token-line"><span class="token plain">        log.info(&quot;{} received: {}&quot;, this.toString(), event);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们监听ContextRefreshedEvent而非ContextStartedEvent。ContextRefreshedEvent的抛出可以参考方法AbstractApplicationContext#finishRefresh，它本身正好是Refresh操作中的一步。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">protected void finishRefresh() {</span></div><div class="token-line"><span class="token plain">       //省略非关键代码</span></div><div class="token-line"><span class="token plain">       initLifecycleProcessor();</span></div><div class="token-line"><span class="token plain">       // Propagate refresh to lifecycle processor first.</span></div><div class="token-line"><span class="token plain">       getLifecycleProcessor().onRefresh();</span></div><div class="token-line"><span class="token plain">       // Publish the final event.</span></div><div class="token-line"><span class="token plain">       publishEvent(new ContextRefreshedEvent(this));</span></div><div class="token-line"><span class="token plain">       //省略非关键代码</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><strong>2. 假设我们就是想要处理ContextStartedEvent。</strong></p><p>这种情况下，我们真的需要去调用AbstractApplicationContext#start方法。例如，我们可以使用下面的代码来让这个事件抛出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RestController</span></div><div class="token-line"><span class="token plain">    public class HelloWorldController {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private AbstractApplicationContext applicationContext;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @RequestMapping(path = &quot;publishEvent&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">        public String notifyEvent(){</span></div><div class="token-line"><span class="token plain">            applicationContext.start();       </span></div><div class="token-line"><span class="token plain">            return &quot;ok&quot;;</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们随便找一处来Autowired一个AbstractApplicationContext，然后直接调用其start()就能让事件抛出来。</p><p>很明显，这种抛出并不难，但是作为题外话，我们可以思考下为什么要去调用start()呢？start()本身在Spring Boot中有何作用？</p><p>如果我们去翻阅这个方法，我们会发现start()是org.springframework.context.Lifecycle定义的方法，而它在Spring Boot的默认实现中是去执行所有Lifecycle Bean的启动方法，这点可以参考DefaultLifecycleProcessor#startBeans方法来验证：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private void startBeans(boolean autoStartupOnly) {</span></div><div class="token-line"><span class="token plain">       Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();</span></div><div class="token-line"><span class="token plain">       Map&lt;Integer, LifecycleGroup&gt; phases = new HashMap&lt;&gt;();</span></div><div class="token-line"><span class="token plain">       lifecycleBeans.forEach((beanName, bean) -&gt; {</span></div><div class="token-line"><span class="token plain">          if (!autoStartupOnly || (bean instanceof SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) {</span></div><div class="token-line"><span class="token plain">             int phase = getPhase(bean);</span></div><div class="token-line"><span class="token plain">             LifecycleGroup group = phases.get(phase);</span></div><div class="token-line"><span class="token plain">             if (group == null) {</span></div><div class="token-line"><span class="token plain">                group = new LifecycleGroup(phase, this.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);</span></div><div class="token-line"><span class="token plain">                phases.put(phase, group);</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             group.add(beanName, bean);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       });</span></div><div class="token-line"><span class="token plain">       if (!phases.isEmpty()) {</span></div><div class="token-line"><span class="token plain">          List&lt;Integer&gt; keys = new ArrayList&lt;&gt;(phases.keySet());</span></div><div class="token-line"><span class="token plain">          Collections.sort(keys);</span></div><div class="token-line"><span class="token plain">          for (Integer key : keys) {</span></div><div class="token-line"><span class="token plain">             phases.get(key).start();</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>说起来比较抽象，我们可以去写一个Lifecycle Bean，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Component</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class MyLifeCycle implements Lifecycle {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        private volatile boolean running = false;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void start() {</span></div><div class="token-line"><span class="token plain">           log.info(&quot;lifecycle start&quot;);</span></div><div class="token-line"><span class="token plain">           running = true;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void stop() {</span></div><div class="token-line"><span class="token plain">           log.info(&quot;lifecycle stop&quot;);</span></div><div class="token-line"><span class="token plain">           running = false;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public boolean isRunning() {</span></div><div class="token-line"><span class="token plain">            return running;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>当我们再次运行Spring Boot时，只要执行了AbstractApplicationContext的start()，就会输出上述代码定义的行为：输出LifeCycle start日志。</p><p>通过这个Lifecycle Bean的使用，AbstractApplicationContext的start要做的事，我们就清楚多了。它和Refresh()不同，Refresh()是初始化和加载所有需要管理的Bean，而start只有在有Lifecycle Bean时才有被调用的价值。那么我们自定义Lifecycle Bean一般是用来做什么呢？例如，可以用它来实现运行中的启停。这里不再拓展，你可以自己做更深入的探索。</p><p>通过这个案例，我们搞定了第一类错误。而从这个错误中，我们也得出了一个启示：**当一个事件拦截不了时，我们第一个要查的是拦截的事件类型对不对，执行的代码能不能抛出它。**把握好这点，也就事半功倍了。</p><h2 id="案例2监听事件的体系不对"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#案例2监听事件的体系不对"><span class="icon icon-link"></span></a>案例2：监听事件的体系不对</h2><p>通过案例1的学习，我们可以保证事件的抛出，但是抛出的事件就一定能被我们监听到么？我们再来看这样一个案例，首先上代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Slf4j</span></div><div class="token-line"><span class="token plain">    @Component</span></div><div class="token-line"><span class="token plain">    public class MyApplicationEnvironmentPreparedEventListener implements ApplicationListener&lt;ApplicationEnvironmentPreparedEvent &gt; {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public void onApplicationEvent(final ApplicationEnvironmentPreparedEvent event) {</span></div><div class="token-line"><span class="token plain">            log.info(&quot;{} received: {}&quot;, this.toString(), event);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里我们试图处理ApplicationEnvironmentPreparedEvent。期待出现拦截事件的日志如下：</p><blockquote><p>2021-03-07 09:12:08.886 INFO 27064 --- [ restartedMain] licationEnvironmentPreparedEventListener : com.spring.puzzle.class7.example2.MyApplicationEnvironmentPreparedEventListener@2b093d received: org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent[source=org.springframework.boot.SpringApplication@122b9e6]</p></blockquote><p>有了案例1的经验，首先我们就可以查看下这个事件的抛出会不会存在问题。这个事件在Spring中是由EventPublishingRunListener#environmentPrepared方法抛出，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Override</span></div><div class="token-line"><span class="token plain">    public void environmentPrepared(ConfigurableEnvironment environment) {</span></div><div class="token-line"><span class="token plain">       this.initialMulticaster</span></div><div class="token-line"><span class="token plain">             .multicastEvent(new ApplicationEnvironmentPreparedEvent(this.application, this.args, environment));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>现在我们调试下代码，你会发现这个方法在Spring启动时一定经由SpringApplication#prepareEnvironment方法调用，调试截图如下：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimagef6fef6e5b92bd2db8a3db93f53ff2a7944fe.3ab63719.png" alt=""/></p><p>表面上看，既然代码会被调用，事件就会抛出，那么我们在最开始定义的监听器就能处理，但是我们真正去运行程序时会发现，效果和案例1是一样的，都是监听器的处理并不执行，即拦截不了。这又是为何？</p><h3 id="案例解析-1"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#案例解析-1"><span class="icon icon-link"></span></a>案例解析</h3><p>实际上，这是在Spring事件处理上非常容易犯的一个错误，即监听的体系不一致。通俗点说，就是“驴头不对马嘴”。我们首先来看下关于ApplicationEnvironmentPreparedEvent的处理，它相关的两大组件是什么？</p><ol><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">广播器：这个事件的广播器是EventPublishingRunListener的initialMulticaster，代码参考如下：</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered {</span></div><div class="token-line"><span class="token plain">       //省略非关键代码</span></div><div class="token-line"><span class="token plain">       private final SimpleApplicationEventMulticaster initialMulticaster;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       public EventPublishingRunListener(SpringApplication application, String[] args) {</span></div><div class="token-line"><span class="token plain">          //省略非关键代码</span></div><div class="token-line"><span class="token plain">          this.initialMulticaster = new SimpleApplicationEventMulticaster();</span></div><div class="token-line"><span class="token plain">          for (ApplicationListener&lt;?&gt; listener : application.getListeners()) {</span></div><div class="token-line"><span class="token plain">             this.initialMulticaster.addApplicationListener(listener);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">     }</span></div></pre></div><ol start="2"><li>监听器：这个事件的监听器同样位于EventPublishingRunListener中，获取方式参考关键代码行：</li></ol><blockquote><p>this.initialMulticaster.addApplicationListener(listener);</p></blockquote><p>如果继续查看代码，我们会发现这个事件的监听器就存储在SpringApplication#Listeners中，调试下就可以找出所有的监听器，截图如下：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage146b145f6d0a20a6f82fa8f6f08c7a08666b.0ded7076.png" alt=""/></p><p>从中我们可以发现并不存在我们定义的MyApplicationEnvironmentPreparedEventListener，这是为何？</p><p>还是查看代码，当Spring Boot被构建时，会使用下面的方法去寻找上述监听器：</p><blockquote><p>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</p></blockquote><p>而上述代码最终寻找Listeners的候选者，参考代码 SpringFactoriesLoader#loadSpringFactories中的关键行：</p><blockquote><p>//下面的FACTORIES_RESOURCE_LOCATION定义为 &quot;META-INF/spring.factories&quot;<br/>classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</p></blockquote><p>我们可以寻找下这样的文件（spring.factories），确实可以发现类似的定义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">org.springframework.context.ApplicationListener=\</span></div><div class="token-line"><span class="token plain">    org.springframework.boot.ClearCachesApplicationListener,\</span></div><div class="token-line"><span class="token plain">    org.springframework.boot.builder.ParentContextCloserApplicationListener,\</span></div><div class="token-line"><span class="token plain">    org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\</span></div><div class="token-line"><span class="token plain">    //省略其他监听器</span></div></pre></div><p>说到这里，相信你已经意识到本案例的问题所在。我们定义的监听器并没有被放置在META-INF/spring.factories中，实际上，我们的监听器监听的体系是另外一套，其关键组件如下：</p><ol><li>广播器：即AbstractApplicationContext#applicationEventMulticaster；</li><li>监听器：由上述提及的META-INF/spring.factories中加载的监听器以及扫描到的 ApplicationListener类型的Bean共同组成。</li></ol><p>这样比较后，我们可以得出一个结论：<strong>我们定义的监听器并不能监听到initialMulticaster广播出的ApplicationEnvironmentPreparedEvent。</strong></p><h3 id="问题修正-1"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#问题修正-1"><span class="icon icon-link"></span></a>问题修正</h3><p>现在就到了解决问题的时候了，我们可以把自定义监听器注册到initialMulticaster广播体系中，这里提供两种方法修正问题。</p><ol><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">在构建Spring Boot时，添加MyApplicationEnvironmentPreparedEventListener：</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@SpringBootApplication</span></div><div class="token-line"><span class="token plain">    public class Application {</span></div><div class="token-line"><span class="token plain">        public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">            MyApplicationEnvironmentPreparedEventListener myApplicationEnvironmentPreparedEventListener = new MyApplicationEnvironmentPreparedEventListener();</span></div><div class="token-line"><span class="token plain">            SpringApplication springApplication = new SpringApplicationBuilder(Application.class).listeners(myApplicationEnvironmentPreparedEventListener).build();</span></div><div class="token-line"><span class="token plain">            springApplication.run(args);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ol start="2"><li><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">使用META-INF/spring.factories，即在/src/main/resources下面新建目录META-INF，然后新建一个对应的spring.factories文件：</span></div></pre></div></li></ol><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">org.springframework.context.ApplicationListener=\</span></div><div class="token-line"><span class="token plain">    com.spring.puzzle.listener.example2.MyApplicationEnvironmentPreparedEventListener</span></div></pre></div><p>通过上述两种修改方式，即可完成事件的监听，很明显第二种方式要优于第一种，至少完全用原生的方式去解决，而不是手工实例化一个MyApplicationEnvironmentPreparedEventListener。这点还是挺重要的。</p><p>反思这个案例的错误，结论就是<strong>对于事件一定要注意“驴头”（监听器）对上“马嘴”（广播）</strong>。</p><h2 id="案例3部分事件监听器失效"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#案例3部分事件监听器失效"><span class="icon icon-link"></span></a>案例3：部分事件监听器失效</h2><p>通过前面案例的解析，我们可以确保事件在合适的时机被合适的监听器所捕获。但是理想总是与现实有差距，有些时候，我们可能还会发现部分事件监听器一直失效或偶尔失效。这里我们可以写一段代码来模拟偶尔失效的场景，首先我们完成一个自定义事件和两个监听器，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class MyEvent extends ApplicationEvent {</span></div><div class="token-line"><span class="token plain">        public MyEvent(Object source) {</span></div><div class="token-line"><span class="token plain">            super(source);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Component</span></div><div class="token-line"><span class="token plain">    @Order(1)</span></div><div class="token-line"><span class="token plain">    public class MyFirstEventListener implements ApplicationListener&lt;MyEvent&gt; {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        Random random = new Random();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void onApplicationEvent(MyEvent event) {</span></div><div class="token-line"><span class="token plain">            log.info(&quot;{} received: {}&quot;, this.toString(), event);</span></div><div class="token-line"><span class="token plain">            //模拟部分失效</span></div><div class="token-line"><span class="token plain">            if(random.nextInt(10) % 2 == 1)</span></div><div class="token-line"><span class="token plain">                throw new RuntimeException(&quot;exception happen on first listener&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Component</span></div><div class="token-line"><span class="token plain">    @Order(2)</span></div><div class="token-line"><span class="token plain">    public class MySecondEventListener implements ApplicationListener&lt;MyEvent&gt; {</span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void onApplicationEvent(MyEvent event) {</span></div><div class="token-line"><span class="token plain">            log.info(&quot;{} received: {}&quot;, this.toString(), event);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里监听器MyFirstEventListener的优先级稍高，且执行过程中会有50%的概率抛出异常。然后我们再写一个Controller来触发事件的发送：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RestController</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class HelloWorldController {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        private AbstractApplicationContext applicationContext;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @RequestMapping(path = &quot;publishEvent&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">        public String notifyEvent(){</span></div><div class="token-line"><span class="token plain">            log.info(&quot;start to publish event&quot;);</span></div><div class="token-line"><span class="token plain">            applicationContext.publishEvent(new MyEvent(UUID.randomUUID()));</span></div><div class="token-line"><span class="token plain">            return &quot;ok&quot;;</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>完成这些代码后，我们就可以使用<a target="_blank" rel="noopener noreferrer" href="http://localhost:8080/publishEvent">http://localhost:8080/publishEvent<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来测试监听器的接收和执行了。观察测试结果，我们会发现监听器MySecondEventListener有一半的概率并没有接收到任何事件。可以说，我们使用了最简化的代码模拟出了部分事件监听器偶尔失效的情况。当然在实际项目中，抛出异常这个根本原因肯定不会如此明显，但还是可以借机举一反三的。那么如何理解这个问题呢？</p><h3 id="案例解析-2"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#案例解析-2"><span class="icon icon-link"></span></a>案例解析</h3><p>这个案例非常简易，如果你稍微有些开发经验的话，大概也能推断出原因：处理器的执行是顺序执行的，在执行过程中，如果一个监听器执行抛出了异常，则后续监听器就得不到被执行的机会了。这里我们可以通过Spring源码看下事件是如何被执行的？</p><p>具体而言，当广播一个事件，执行的方法参考 SimpleApplicationEventMulticaster#multicastEvent(ApplicationEvent)：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Override</span></div><div class="token-line"><span class="token plain">    public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {</span></div><div class="token-line"><span class="token plain">       ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));</span></div><div class="token-line"><span class="token plain">       Executor executor = getTaskExecutor();</span></div><div class="token-line"><span class="token plain">       for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {</span></div><div class="token-line"><span class="token plain">          if (executor != null) {</span></div><div class="token-line"><span class="token plain">             executor.execute(() -&gt; invokeListener(listener, event));</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          else {</span></div><div class="token-line"><span class="token plain">             invokeListener(listener, event);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述方法通过Event类型等信息调用getApplicationListeners获取了具有执行资格的所有监听器（在本案例中，即为MyFirstEventListener和MySecondEventListener），然后按顺序去执行。最终每个监听器的执行是通过invokeListener()来触发的，调用的是接口方法 ApplicationListener#onApplicationEvent。执行逻辑可参考如下代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">protected void invokeListener(ApplicationListener&lt;?&gt; listener, ApplicationEvent event) {</span></div><div class="token-line"><span class="token plain">       ErrorHandler errorHandler = getErrorHandler();</span></div><div class="token-line"><span class="token plain">       if (errorHandler != null) {</span></div><div class="token-line"><span class="token plain">          try {</span></div><div class="token-line"><span class="token plain">             doInvokeListener(listener, event);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          catch (Throwable err) {</span></div><div class="token-line"><span class="token plain">             errorHandler.handleError(err);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       else {</span></div><div class="token-line"><span class="token plain">          doInvokeListener(listener, event);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {</span></div><div class="token-line"><span class="token plain">       try {</span></div><div class="token-line"><span class="token plain">          listener.onApplicationEvent(event);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       catch (ClassCastException ex) {</span></div><div class="token-line"><span class="token plain">            //省略非关键代码</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          else {</span></div><div class="token-line"><span class="token plain">             throw ex;</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里我们并没有去设置什么org.springframework.util.ErrorHandler，也没有绑定什么Executor 来执行任务，所以针对本案例的情况，我们可以看出：<strong>最终事件的执行是由同一个线程按顺序来完成的，任何一个报错，都会导致后续的监听器执行不了。</strong></p><h3 id="问题修正-2"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#问题修正-2"><span class="icon icon-link"></span></a>问题修正</h3><p>怎么解决呢？好办，我提供两种方案给你。</p><p><strong>1. 确保监听器的执行不会抛出异常。</strong></p><p>既然我们使用多个监听器，我们肯定是希望它们都能执行的，所以我们一定要保证每个监听器的执行不会被其他监听器影响。基于这个思路，我们修改案例代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Component</span></div><div class="token-line"><span class="token plain">    @Order(1)</span></div><div class="token-line"><span class="token plain">    public class MyFirstEventListener implements ApplicationListener&lt;MyEvent&gt; {</span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void onApplicationEvent(MyEvent event) {</span></div><div class="token-line"><span class="token plain">            try {</span></div><div class="token-line"><span class="token plain">              // 省略事件处理相关代码</span></div><div class="token-line"><span class="token plain">            }catch(Throwable throwable){</span></div><div class="token-line"><span class="token plain">                //write error/metric to alert</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><strong>2. 使用org.springframework.util.ErrorHandler。</strong></p><p>通过上面的案例解析，我们发现，假设我们设置了一个ErrorHandler，那么就可以用这个ErrorHandler去处理掉异常，从而保证后续事件监听器处理不受影响。我们可以使用下面的代码来修正问题：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">SimpleApplicationEventMulticaster simpleApplicationEventMulticaster = applicationContext.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, SimpleApplicationEventMulticaster.class);</span></div><div class="token-line"><span class="token plain">        simpleApplicationEventMulticaster.setErrorHandler(TaskUtils.LOG_AND_SUPPRESS_ERROR_HANDLER);</span></div></pre></div><p>其中LOG_AND_SUPPRESS_ERROR_HANDLER的实现如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public static final ErrorHandler LOG_AND_SUPPRESS_ERROR_HANDLER = new LoggingErrorHandler();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    private static class LoggingErrorHandler implements ErrorHandler {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       private final Log logger = LogFactory.getLog(LoggingErrorHandler.class);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       @Override</span></div><div class="token-line"><span class="token plain">       public void handleError(Throwable t) {</span></div><div class="token-line"><span class="token plain">          logger.error(&quot;Unexpected error occurred in scheduled task&quot;, t);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>对比下方案1，使用ErrorHandler有一个很大的优势，就是我们不需要在某个监听器中都重复类似下面的代码了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">try {</span></div><div class="token-line"><span class="token plain">        //省略事件处理过程</span></div><div class="token-line"><span class="token plain">        }catch(Throwable throwable){</span></div><div class="token-line"><span class="token plain">        //write error/metric to alert</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这么看的话，其实Spring的设计还是很全面的，它考虑了各种各样的情况。但是Spring使用者往往都不会去了解其内部实现，这样就会遇到各种各样的问题。相反，如果你对其实现有所了解的话，也对常见错误有一个感知，则大概率是可以快速避坑的，项目也可以运行得更加平稳顺畅。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>今天我们粗略地了解了Spring事件处理的基本流程。其实，抛开Spring框架，我们去设计一个通用的事件处理框架，常常也会犯这三种错误：</p><ol><li>误读事件本身含义；</li><li>监听错了事件的传播系统；</li><li>事件处理之间互相影响，导致部分事件处理无法完成。</li></ol><p>这三种错误正好对应了我们这节课讲解的三个案例。</p><p>此外，在Spring事件处理过程中，我们也学习到了监听器加载的特殊方式，即使用SPI的方式直接从配置文件META-INF/spring.factories中加载。这种方式或者说思想非常值得你去学习，因为它在许多Java应用框架中都有所使用，例如Dubbo，就是使用增强版的SPI来配置编解码器的。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/08#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>在案例3中，我们提到默认的事件执行是在同一个线程中执行的，即事件发布者使用的线程。参考如下日志佐证这个结论：</p><blockquote><p>2021-03-09 09:10:33.052 INFO 18104 --- [nio-8080-exec-1] c.s.p.listener.HelloWorldController : start to publish event<br/>2021-03-09 09:10:33.055 INFO 18104 --- [nio-8080-exec-1] c.s.p.l.example3.MyFirstEventListener : com.spring.puzzle.class7.example3.MyFirstEventListener@18faf0 received: com.spring.puzzle.class7.example3.MyEvent[source=df42b08f-8ee2-44df-a957-d8464ff50c88]</p></blockquote><p>通过日志可以看出，事件的发布和执行使用的都是nio-8080-exec-1线程，但是在事件比较多时，我们往往希望事件执行得更快些，或者希望事件的执行可以异步化不影响主线程。此时应该怎么做呢？</p><p>期待在留言区看到你的回复，我们下节课见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/spring编程常见错误50例/02.SpringCore篇/08.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:06:36</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-java/umi.fde43fdb.js"></script>
  </body>
</html>
