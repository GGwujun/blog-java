<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-java/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-java";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>06｜Spring AOP 常见错误（下） - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/spring编程常见错误50例/02.spring-core篇/07" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a aria-current="page" class="active" href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a aria-current="page" class="active" href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/spring编程常见错误50例/01.课前必读">01.课前必读</a><ul><li><a href="/blog-java/spring编程常见错误50例/01.课前必读/01"><span>开篇词｜贴心“保姆”Spring罢工了怎么办？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-java/spring编程常见错误50例/02.spring-core篇">02.SpringCore篇</a><ul><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/01"><span>导读｜5分钟轻松了解Spring基础知识</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/02"><span>01｜Spring Bean 定义常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/03"><span>02｜Spring Bean 依赖注入常见错误（上）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/04"><span>03｜Spring Bean 依赖注入常见错误（下）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/05"><span>04｜Spring Bean 生命周期常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/06"><span>05｜Spring AOP 常见错误（上）</span></a></li><li><a aria-current="page" class="active" href="/blog-java/spring编程常见错误50例/02.spring-core篇/07"><span>06｜Spring AOP 常见错误（下）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/08"><span>07｜Spring事件常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/09"><span>08｜答疑现场：Spring Core 篇思考题合集</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇">03.SpringWeb篇</a><ul><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/01"><span>导读｜5分钟轻松了解一个HTTP请求的处理过程</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/02"><span>09｜Spring Web URL 解析常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/03"><span>10 | Spring Web Header 解析常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/04"><span>11 | Spring Web Body 转化常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/05"><span>12｜Spring Web 参数验证常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/06"><span>13 | Spring Web 过滤器使用常见错误（上）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/07"><span>14 | Spring Web 过滤器使用常见错误（下）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/08"><span>15 | Spring Security 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/09"><span>16｜Spring Exception 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/10"><span>17｜答疑现场：Spring Web 篇思考题合集</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇">04.Spring补充篇</a><ul><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/01"><span>18 | Spring Data 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/02"><span>19 | Spring 事务常见错误（上）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/03"><span>20 | Spring 事务常见错误（下）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/04"><span>21 | Spring Rest Template 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/05"><span>22 | Spring Test 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/06"><span>23｜答疑现场：Spring 补充篇思考题合集</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/07"><span>知识回顾 | 系统梳理Spring编程错误根源</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/05.结束语">05.结束语</a><ul><li><a href="/blog-java/spring编程常见错误50例/05.结束语/01"><span>结束语｜问题总比解决办法多</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/06.期末测试">06.期末测试</a><ul><li><a href="/blog-java/spring编程常见错误50例/06.期末测试/01"><span>期末测试｜来赴一场100分之约！</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/summary">spring编程常见错误50例</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="案例1：错乱混合不同类型的增强" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#案例1错乱混合不同类型的增强"><span>案例1：错乱混合不同类型的增强</span></a></li><li title="案例解析" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#案例解析"><span>案例解析</span></a></li><li title="问题修正" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#问题修正"><span>问题修正</span></a></li><li title="案例 2：错乱混合同类型增强" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#案例-2错乱混合同类型增强"><span>案例 2：错乱混合同类型增强</span></a></li><li title="案例解析" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#案例解析-1"><span>案例解析</span></a></li><li title="问题修正" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#问题修正-1"><span>问题修正</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#重点回顾"><span>重点回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="06spring-aop-常见错误下"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#06spring-aop-常见错误下"><span class="icon icon-link"></span></a>06｜Spring AOP 常见错误（下）</h1><p>你好，我是傅健。</p><p>上一节课，我们介绍了 Spring AOP 常遇到的几个问题，通过具体的源码解析，相信你对 Spring AOP 的基本原理已经有所了解了。不过，AOP 毕竟是 Spring 的核心功能之一，不可能规避那零散的两三个问题就一劳永逸了。所以这节课，我们继续聊聊 Spring AOP 中还会有哪些易错点。实际上，当一个系统采用的切面越来越多时，因为执行顺序而导致的问题便会逐步暴露出来，下面我们就重点看一下。</p><h2 id="案例1错乱混合不同类型的增强"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#案例1错乱混合不同类型的增强"><span class="icon icon-link"></span></a>案例1：错乱混合不同类型的增强</h2><p>还是沿用上节课的宿舍管理系统开发场景。</p><p>这里我们先回顾下，你就不用去翻代码了。这个宿舍管理系统保护了一个电费充值模块，它包含了一个负责电费充值的类 ElectricService，还有一个充电方法 charge()：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Service</span></div><div class="token-line"><span class="token plain">    public class ElectricService {</span></div><div class="token-line"><span class="token plain">        public void charge() throws Exception {</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;Electric charging ...&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>为了在执行 charge() 之前，鉴定下调用者的权限，我们增加了针对于 Electric 的切面类 AopConfig，其中包含一个 @Before 增强。这里的增强没有做任何事情，仅仅是打印了一行日志，然后模拟执行权限校验功能（占用 1 秒钟）。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//省略 imports</span></div><div class="token-line"><span class="token plain">    @Aspect</span></div><div class="token-line"><span class="token plain">    @Service</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class AspectService {</span></div><div class="token-line"><span class="token plain">      @Before(&quot;execution(* com.spring.puzzle.class6.example1.ElectricService.charge()) &quot;)</span></div><div class="token-line"><span class="token plain">      public void checkAuthority(JoinPoint pjp) throws Throwable {</span></div><div class="token-line"><span class="token plain">          System.out.println(&quot;validating user authority&quot;);</span></div><div class="token-line"><span class="token plain">          Thread.sleep(1000);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>执行后，我们得到以下 log，接着一切按照预期继续执行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">validating user authority</span></div><div class="token-line"><span class="token plain">    Electric charging ...</span></div></pre></div><p>一段时间后，由于业务发展，ElectricService 中的 charge() 逻辑变得更加复杂了，我们需要仅仅针对 ElectricService 的 charge() 做性能统计。为了不影响原有的业务逻辑，我们在 AopConfig 中添加了另一个增强，代码更改后如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//省略 imports</span></div><div class="token-line"><span class="token plain">    @Aspect</span></div><div class="token-line"><span class="token plain">    @Service</span></div><div class="token-line"><span class="token plain">    public class AopConfig {</span></div><div class="token-line"><span class="token plain">        @Before(&quot;execution(* com.spring.puzzle.class6.example1.ElectricService.charge()) &quot;)</span></div><div class="token-line"><span class="token plain">        public void checkAuthority(JoinPoint pjp) throws Throwable {</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;validating user authority&quot;);</span></div><div class="token-line"><span class="token plain">            Thread.sleep(1000);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Around(&quot;execution(* com.spring.puzzle.class6.example1.ElectricService.charge()) &quot;)</span></div><div class="token-line"><span class="token plain">        public void recordPerformance(ProceedingJoinPoint pjp) throws Throwable {</span></div><div class="token-line"><span class="token plain">            long start = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">            pjp.proceed();</span></div><div class="token-line"><span class="token plain">            long end = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;charge method time cost: &quot; + (end - start));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>执行后得到日志如下：</p><blockquote><p>validating user authority<br/>Electric charging …<br/>charge method time cost 1022 (ms)</p></blockquote><p>通过性能统计打印出的日志，我们可以得知 charge() 执行时间超过了 1 秒钟。然而，该方法仅打印了一行日志，它的执行不可能需要这么长时间。</p><p>因此我们很容易看出问题所在：当前 ElectricService 中 charge() 的执行时间，包含了权限验证的时间，即包含了通过 @Around 增强的 checkAuthority() 执行的所有时间。这并不符合我们的初衷，我们需要统计的仅仅是 ElectricService.charge() 的性能统计，它并不包含鉴权过程。</p><p>当然，这些都是从日志直接观察出的现象。实际上，这个问题出现的根本原因和 AOP 的执行顺序有关。针对这个案例而言，当同一个切面（Aspect）中同时包含多个不同类型的增强时（Around、Before、After、AfterReturning、AfterThrowing 等），它们的执行是有顺序的。那么顺序如何？我们不妨来解析下。</p><h3 id="案例解析"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#案例解析"><span class="icon icon-link"></span></a>案例解析</h3><p>其实一切都可以从源码中得到真相！在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/367876">第04课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>我们曾经提到过，Spring 初始化单例类的一般过程，基本都是 getBean()-&gt;doGetBean()-&gt;getSingleton()，如果发现 Bean 不存在，则调用 createBean()-&gt;doCreateBean() 进行实例化。</p><p>而如果我们的代码里使用了 Spring AOP，doCreateBean() 最终会返回一个代理对象。至于代理对象如何创建，大体流程我们在上一讲已经概述过了。如果你记忆力比较好的话，应该记得在代理对象的创建过程中，我们贴出过这样一段代码（参考 AbstractAutoProxyCreator#createProxy）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></div><div class="token-line"><span class="token plain">          @Nullable Object[] specificInterceptors, TargetSource targetSource) {</span></div><div class="token-line"><span class="token plain">       //省略非关键代码</span></div><div class="token-line"><span class="token plain">       Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span></div><div class="token-line"><span class="token plain">       proxyFactory.addAdvisors(advisors);</span></div><div class="token-line"><span class="token plain">       proxyFactory.setTargetSource(targetSource);</span></div><div class="token-line"><span class="token plain">       //省略非关键代码</span></div><div class="token-line"><span class="token plain">       return proxyFactory.getProxy(getProxyClassLoader());</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其中 advisors 就是增强方法对象，它的顺序决定了面临多个增强时，到底先执行谁。而这个集合对象本身是由 specificInterceptors 构建出来的，而 specificInterceptors 又是由 AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean 方法构建：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Override</span></div><div class="token-line"><span class="token plain">    @Nullable</span></div><div class="token-line"><span class="token plain">    protected Object[] getAdvicesAndAdvisorsForBean(</span></div><div class="token-line"><span class="token plain">          Class&lt;?&gt; beanClass, String beanName, @Nullable TargetSource targetSource) {</span></div><div class="token-line"><span class="token plain">       List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span></div><div class="token-line"><span class="token plain">       if (advisors.isEmpty()) {</span></div><div class="token-line"><span class="token plain">          return DO_NOT_PROXY;</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return advisors.toArray();</span></div><div class="token-line"><span class="token plain">      }</span></div></pre></div><p>简单说，其实就是根据当前的 beanClass、beanName 等信息，结合所有候选的 advisors，最终找出匹配（Eligible）的 Advisor，为什么如此？毕竟 AOP 拦截点可能会配置多个，而我们执行的方法不见得会被所有的拦截配置拦截。寻找匹配 Advisor 的逻辑参考 AbstractAdvisorAutoProxyCreator#findEligibleAdvisors：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {</span></div><div class="token-line"><span class="token plain">       //寻找候选的 Advisor</span></div><div class="token-line"><span class="token plain">       List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span></div><div class="token-line"><span class="token plain">       //根据候选的 Advisor 和当前 bean 算出匹配的 Advisor</span></div><div class="token-line"><span class="token plain">       List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span></div><div class="token-line"><span class="token plain">       extendAdvisors(eligibleAdvisors);</span></div><div class="token-line"><span class="token plain">       if (!eligibleAdvisors.isEmpty()) {</span></div><div class="token-line"><span class="token plain">          //排序</span></div><div class="token-line"><span class="token plain">          eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return eligibleAdvisors;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>通过研读代码，最终 Advisors 的顺序是由两点决定：</p><ol><li>candidateAdvisors 的顺序；</li><li>sortAdvisors 进行的排序。</li></ol><p>这里我们可以重点看下对本案例起关键作用的 candidateAdvisors 排序。实际上，它的顺序是在 @Aspect 标记的 AopConfig Bean 构建时就决定了。具体而言，就是在初始化过程中会排序自己配置的 Advisors，并把排序结果存入了缓存（BeanFactoryAspectJAdvisorsBuilder#advisorsCache）。</p><p>后续 Bean 创建代理时，直接拿出这个排序好的候选 Advisors。候选 Advisors 排序发生在 Bean 构建这个结论时，我们也可以通过 AopConfig Bean 构建中的堆栈信息验证：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage61d1611f386b14b05c2d151340d31f34e3d1.c0a54de8.png" alt=""/></p><p>可以看到，排序是在 Bean 的构建中进行的，而最后排序执行的关键代码位于下面的方法中（参考 ReflectiveAspectJAdvisorFactory#getAdvisorMethods）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private List&lt;Method&gt; getAdvisorMethods(Class&lt;?&gt; aspectClass) {</span></div><div class="token-line"><span class="token plain">       final List&lt;Method&gt; methods = new ArrayList&lt;&gt;();</span></div><div class="token-line"><span class="token plain">       ReflectionUtils.doWithMethods(aspectClass, method -&gt; {</span></div><div class="token-line"><span class="token plain">          // Exclude pointcuts</span></div><div class="token-line"><span class="token plain">          if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) {</span></div><div class="token-line"><span class="token plain">             methods.add(method);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }, ReflectionUtils.USER_DECLARED_METHODS);</span></div><div class="token-line"><span class="token plain">       // 排序</span></div><div class="token-line"><span class="token plain">       methods.sort(METHOD_COMPARATOR);</span></div><div class="token-line"><span class="token plain">       return methods;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码的重点是第九行 methods.sort(METHOD_COMPARATOR)方法。</p><p>我们来查看 METHOD_COMPARATOR 的代码，会发现它是定义在 ReflectiveAspectJAdvisorFactory 类中的静态方法块，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static {</span></div><div class="token-line"><span class="token plain">       Comparator&lt;Method&gt; adviceKindComparator = new ConvertingComparator&lt;&gt;(</span></div><div class="token-line"><span class="token plain">             new InstanceComparator&lt;&gt;(</span></div><div class="token-line"><span class="token plain">                   Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class),</span></div><div class="token-line"><span class="token plain">             (Converter&lt;Method, Annotation&gt;) method -&gt; {</span></div><div class="token-line"><span class="token plain">                AspectJAnnotation&lt;?&gt; annotation =</span></div><div class="token-line"><span class="token plain">                   AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);</span></div><div class="token-line"><span class="token plain">                return (annotation != null ? annotation.getAnnotation() : null);</span></div><div class="token-line"><span class="token plain">             });</span></div><div class="token-line"><span class="token plain">       Comparator&lt;Method&gt; methodNameComparator = new ConvertingComparator&lt;&gt;(Method::getName);</span></div><div class="token-line"><span class="token plain">       //合并上面两者比较器</span></div><div class="token-line"><span class="token plain">       METHOD_COMPARATOR = adviceKindComparator.thenComparing(methodNameComparator);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>METHOD_COMPARATOR 本质上是一个连续比较器，由 adviceKindComparator 和 methodNameComparator 这两个比较器通过 thenComparing()连接而成。</p><p>通过这个案例，我们重点了解 adviceKindComparator 这个比较器，此对象通过实例化 ConvertingComparator 类而来，而 ConvertingComparator 类是 Spring 中较为经典的一个实现。顾名思义，先转化再比较，它构造参数接受以下这两个参数：</p><ul><li>第一个参数是基准比较器，即在 adviceKindComparator 中最终要调用的比较器，在构造函数中赋值于 this.comparator；</li><li>第二个参数是一个 lambda 回调函数，用来将传递的参数转化为基准比较器需要的参数类型，在构造函数中赋值于 this.converter。</li></ul><p>查看 ConvertingComparator 比较器核心方法 compare 如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public int compare(S o1, S o2) {</span></div><div class="token-line"><span class="token plain">       T c1 = this.converter.convert(o1);</span></div><div class="token-line"><span class="token plain">       T c2 = this.converter.convert(o2);</span></div><div class="token-line"><span class="token plain">       return this.comparator.compare(c1, c2);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可知，这里是先调用从构造函数中获取到的 lambda 回调函数 this.converter，将需要比较的参数进行转化。我们可以从之前的代码中找出这个转化工作：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">(Converter&lt;Method, Annotation&gt;) method -&gt; {</span></div><div class="token-line"><span class="token plain">       AspectJAnnotation&lt;?&gt; annotation =</span></div><div class="token-line"><span class="token plain">          AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);</span></div><div class="token-line"><span class="token plain">       return (annotation != null ? annotation.getAnnotation() : null);</span></div><div class="token-line"><span class="token plain">    });</span></div></pre></div><p>转化功能的代码逻辑较为简单，就是返回传入方法（method）上标记的增强注解（Pointcut,Around,Before,After,AfterReturning 以及 AfterThrowing）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private static final Class&lt;?&gt;[] ASPECTJ_ANNOTATION_CLASSES = new Class&lt;?&gt;[] {</span></div><div class="token-line"><span class="token plain">          Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class};</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    protected static AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) {</span></div><div class="token-line"><span class="token plain">       for (Class&lt;?&gt; clazz : ASPECTJ_ANNOTATION_CLASSES) {</span></div><div class="token-line"><span class="token plain">          AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) clazz);</span></div><div class="token-line"><span class="token plain">          if (foundAnnotation != null) {</span></div><div class="token-line"><span class="token plain">             return foundAnnotation;</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return null;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>经过转化后，我们获取到的待比较的数据其实就是注解了。而它们的排序依赖于 ConvertingComparator 的第一个参数，即最终会调用的基准比较器，以下是它的关键实现代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">new InstanceComparator&lt;&gt;(</span></div><div class="token-line"><span class="token plain">          Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class)</span></div></pre></div><p>最终我们要调用的基准比较器本质上就是一个 InstanceComparator 类，我们先重点注意下这几个增强注解的传递顺序。继续查看它的构造方法如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public InstanceComparator(Class&lt;?&gt;... instanceOrder) {</span></div><div class="token-line"><span class="token plain">       Assert.notNull(instanceOrder, &quot;&#x27;instanceOrder&#x27; array must not be null&quot;);</span></div><div class="token-line"><span class="token plain">       this.instanceOrder = instanceOrder;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>构造方法也是较为简单的，只是将传递进来的 instanceOrder 赋予了类成员变量，继续查看 InstanceComparator 比较器核心方法 compare 如下，也就是最终要调用的比较方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public int compare(T o1, T o2) {</span></div><div class="token-line"><span class="token plain">       int i1 = getOrder(o1);</span></div><div class="token-line"><span class="token plain">       int i2 = getOrder(o2);</span></div><div class="token-line"><span class="token plain">       return (i1 &lt; i2 ? -1 : (i1 == i2 ? 0 : 1));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>一个典型的 Comparator，代码逻辑按照 i1、i2 的升序排列，即 getOrder() 返回的值越小，排序越靠前。</p><p>查看 getOrder() 的逻辑如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private int getOrder(@Nullable T object) {</span></div><div class="token-line"><span class="token plain">       if (object != null) {</span></div><div class="token-line"><span class="token plain">          for (int i = 0; i &lt; this.instanceOrder.length; i++) {</span></div><div class="token-line"><span class="token plain">             //instance 在 instanceOrder 中的“排号”</span></div><div class="token-line"><span class="token plain">             if (this.instanceOrder[i].isInstance(object)) {</span></div><div class="token-line"><span class="token plain">                return i;</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return this.instanceOrder.length;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>返回当前传递的增强注解在 this.instanceOrder 中的序列值，序列值越小，则越靠前。而结合之前构造参数传递的顺序，我们很快就能判断出：最终的排序结果依次是 Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class。</p><p>到此为止，答案也呼之欲出：this.instanceOrder 的排序，即为不同类型增强的优先级，<strong>排序越靠前，优先级越高</strong>。</p><p>结合之前的讨论，我们可以得出一个结论：同一个切面中，不同类型的增强方法被调用的顺序依次为Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class。</p><h3 id="问题修正"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#问题修正"><span class="icon icon-link"></span></a>问题修正</h3><p>从上述案例解析中，我们知道 Around 类型的增强被调用的优先级高于 Before 类型的增强，所以上述案例中性能统计所花费的时间，包含权限验证的时间，也在情理之中。</p><p>知道了原理，修正起来也就简单了。假设不允许我们去拆分类，我们可以按照下面的思路来修改：</p><ol><li>将 ElectricService.charge() 的业务逻辑全部移动到 doCharge()，在 charge() 中调用 doCharge()；</li><li>性能统计只需要拦截 doCharge()；</li><li>权限统计增强保持不变，依然拦截 charge()。</li></ol><p>ElectricService 类代码更改如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Service</span></div><div class="token-line"><span class="token plain">    public class ElectricService {</span></div><div class="token-line"><span class="token plain">        @Autowired</span></div><div class="token-line"><span class="token plain">        ElectricService electricService;</span></div><div class="token-line"><span class="token plain">        public void charge() {</span></div><div class="token-line"><span class="token plain">            electricService.doCharge();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        public void doCharge() {</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;Electric charging ...&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>切面代码更改如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//省略 imports</span></div><div class="token-line"><span class="token plain">    @Aspect</span></div><div class="token-line"><span class="token plain">    @Service</span></div><div class="token-line"><span class="token plain">    public class AopConfig {</span></div><div class="token-line"><span class="token plain">        @Before(&quot;execution(* com.spring.puzzle.class6.example1.ElectricService.charge()) &quot;)</span></div><div class="token-line"><span class="token plain">        public void checkAuthority(JoinPoint pjp) throws Throwable {</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;validating user authority&quot;);</span></div><div class="token-line"><span class="token plain">            Thread.sleep(1000);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Around(&quot;execution(* com.spring.puzzle.class6.example1.ElectricService.doCharge()) &quot;)</span></div><div class="token-line"><span class="token plain">        public void recordPerformance(ProceedingJoinPoint pjp) throws Throwable {</span></div><div class="token-line"><span class="token plain">        long start = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">        pjp.proceed();</span></div><div class="token-line"><span class="token plain">        long end = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">        System.out.println(&quot;charge method time cost: &quot; + (end - start));</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="案例-2错乱混合同类型增强"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#案例-2错乱混合同类型增强"><span class="icon icon-link"></span></a>案例 2：错乱混合同类型增强</h2><p>那学到这里，你可能还有疑问，如果同一个切面里的多个增强方法其增强都一样，那调用顺序又如何呢？我们继续看下一个案例。</p><p>这里业务逻辑类 ElectricService 没有任何变化，仅包含一个 charge()：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import org.springframework.stereotype.Service;</span></div><div class="token-line"><span class="token plain">    @Service</span></div><div class="token-line"><span class="token plain">    public class ElectricService {</span></div><div class="token-line"><span class="token plain">        public void charge() {</span></div><div class="token-line"><span class="token plain">            System.out.println(&quot;Electric charging ...&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>切面类 AspectService 包含两个方法，都是 Before 类型增强。</p><p>第一个方法 logBeforeMethod()，目的是在 run() 执行之前希望能输入日志，表示当前方法被调用一次，方便后期统计。另一个方法 validateAuthority()，目的是做权限验证，其作用是在调用此方法之前做权限验证，如果不符合权限限制要求，则直接抛出异常。这里为了方便演示，此方法将直接抛出异常：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//省略 imports</span></div><div class="token-line"><span class="token plain">    @Aspect</span></div><div class="token-line"><span class="token plain">    @Service</span></div><div class="token-line"><span class="token plain">    public class AopConfig {</span></div><div class="token-line"><span class="token plain">      @Before(&quot;execution(* com.spring.puzzle.class5.example2.ElectricService.charge())&quot;)</span></div><div class="token-line"><span class="token plain">      public void logBeforeMethod(JoinPoint pjp) throws Throwable {</span></div><div class="token-line"><span class="token plain">          System.out.println(&quot;step into -&gt;&quot;+pjp.getSignature());</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      @Before(&quot;execution(* com.spring.puzzle.class5.example2.ElectricService.charge()) &quot;)</span></div><div class="token-line"><span class="token plain">      public void validateAuthority(JoinPoint pjp) throws Throwable {</span></div><div class="token-line"><span class="token plain">          throw new RuntimeException(&quot;authority check failed&quot;);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们对代码的执行预期为：当鉴权失败时，由于 ElectricService.charge() 没有被调用，那么 run() 的调用日志也不应该被输出，即 logBeforeMethod() 不应该被调用，但事实总是出乎意料，执行结果如下：</p><blockquote><p>step into -&gt;void com.spring.puzzle.class6.example2.Electric.charge()<br/>Exception in thread “main” java.lang.RuntimeException: authority check failed</p></blockquote><p>虽然鉴权失败，抛出了异常且 ElectricService.charge() 没有被调用，但是 logBeforeMethod() 的调用日志却被输出了，这将导致后期针对于 ElectricService.charge() 的调用数据统计严重失真。</p><p>这里我们就需要搞清楚一个问题：当同一个切面包含多个同一种类型的多个增强，且修饰的都是同一个方法时，这多个增强的执行顺序是怎样的？</p><h3 id="案例解析-1"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#案例解析-1"><span class="icon icon-link"></span></a>案例解析</h3><p>我们继续从源代码中寻找真相！你应该还记得上述代码中，定义 METHOD_COMPARATOR 的静态代码块吧。</p><p>METHOD_COMPARATOR 本质是一个连续比较器，而上个案例中我们仅仅只看了第一个比较器，细心的你肯定发现了这里还有第二个比较器 methodNameComparator，任意两个比较器都可以通过其内置的 thenComparing() 连接形成一个连续比较器，从而可以让我们按照比较器的连接顺序依次比较：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static {</span></div><div class="token-line"><span class="token plain">       //第一个比较器，用来按照增强类型排序</span></div><div class="token-line"><span class="token plain">       Comparator&lt;Method&gt; adviceKindComparator = new ConvertingComparator&lt;&gt;(</span></div><div class="token-line"><span class="token plain">             new InstanceComparator&lt;&gt;(</span></div><div class="token-line"><span class="token plain">                   Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class),</span></div><div class="token-line"><span class="token plain">             (Converter&lt;Method, Annotation&gt;) method -&gt; {</span></div><div class="token-line"><span class="token plain">                AspectJAnnotation&lt;?&gt; annotation =</span></div><div class="token-line"><span class="token plain">                   AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);</span></div><div class="token-line"><span class="token plain">                return (annotation != null ? annotation.getAnnotation() : null);</span></div><div class="token-line"><span class="token plain">             })</span></div><div class="token-line"><span class="token plain">       //第二个比较器，用来按照方法名排序</span></div><div class="token-line"><span class="token plain">       Comparator&lt;Method&gt; methodNameComparator = new ConvertingComparator&lt;&gt;(Method::getName);</span></div><div class="token-line"><span class="token plain">       METHOD_COMPARATOR = adviceKindComparator.thenComparing(methodNameComparator);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们可以看到，在第 12 行代码中，第 2 个比较器 methodNameComparator 依然使用的是 ConvertingComparator，传递了方法名作为参数。我们基本可以猜测出该比较器是按照方法名进行排序的，这里可以进一步查看构造器方法及构造器调用的内部 comparable()：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public ConvertingComparator(Converter&lt;S, T&gt; converter) {</span></div><div class="token-line"><span class="token plain">       this(Comparators.comparable(), converter);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 省略非关键代码</span></div><div class="token-line"><span class="token plain">    public static &lt;T&gt; Comparator&lt;T&gt; comparable() {</span></div><div class="token-line"><span class="token plain">       return ComparableComparator.INSTANCE;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中的 ComparableComparator 实例其实极其简单，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class ComparableComparator&lt;T extends Comparable&lt;T&gt;&gt; implements Comparator&lt;T&gt; {</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">       public static final ComparableComparator INSTANCE = new ComparableComparator();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       @Override</span></div><div class="token-line"><span class="token plain">       public int compare(T o1, T o2) {</span></div><div class="token-line"><span class="token plain">          return o1.compareTo(o2);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>答案和我们的猜测完全一致，methodNameComparator 最终调用了 String 类自身的 compareTo()，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public int compareTo(String anotherString) {</span></div><div class="token-line"><span class="token plain">        int len1 = value.length;</span></div><div class="token-line"><span class="token plain">        int len2 = anotherString.value.length;</span></div><div class="token-line"><span class="token plain">        int lim = Math.min(len1, len2);</span></div><div class="token-line"><span class="token plain">        char v1[] = value;</span></div><div class="token-line"><span class="token plain">        char v2[] = anotherString.value;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        int k = 0;</span></div><div class="token-line"><span class="token plain">        while (k &lt; lim) {</span></div><div class="token-line"><span class="token plain">            char c1 = v1[k];</span></div><div class="token-line"><span class="token plain">            char c2 = v2[k];</span></div><div class="token-line"><span class="token plain">            if (c1 != c2) {</span></div><div class="token-line"><span class="token plain">                return c1 - c2;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            k++;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return len1 - len2;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>到这，答案揭晓：如果两个方法名长度相同，则依次比较每一个字母的 ASCII 码，ASCII 码越小，排序越靠前；若长度不同，且短的方法名字符串是长的子集时，短的排序靠前。</p><h3 id="问题修正-1"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#问题修正-1"><span class="icon icon-link"></span></a>问题修正</h3><p>从上述分析我们得知，在同一个切面配置类中，针对同一个方法存在多个同类型增强时，其执行顺序仅和当前增强方法的名称有关，而不是由谁代码在先、谁代码在后来决定。了解了这点，我们就可以直接通过调整方法名的方式来修正程序：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//省略 imports</span></div><div class="token-line"><span class="token plain">    @Aspect</span></div><div class="token-line"><span class="token plain">    @Service</span></div><div class="token-line"><span class="token plain">    public class AopConfig {</span></div><div class="token-line"><span class="token plain">      @Before(&quot;execution(* com.spring.puzzle.class6.example2.ElectricService.charge())&quot;)</span></div><div class="token-line"><span class="token plain">      public void logBeforeMethod(JoinPoint pjp) throws Throwable {</span></div><div class="token-line"><span class="token plain">          System.out.println(&quot;step into -&gt;&quot;+pjp.getSignature());</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      @Before(&quot;execution(* com.spring.puzzle.class6.example2.ElectricService.charge()) &quot;)</span></div><div class="token-line"><span class="token plain">      public void checkAuthority(JoinPoint pjp) throws Throwable {</span></div><div class="token-line"><span class="token plain">          throw new RuntimeException(&quot;authority check failed&quot;);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们可以将原来的 validateAuthority() 改为 checkAuthority()，这种情况下，<strong>对增强（Advisor）的排序，其实最后就是在比较字符 l 和 字符 c</strong>。显然易见，checkAuthority()的排序会靠前，从而被优先执行，最终问题得以解决。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>通过学习这两个案例，相信你对 Spring AOP 增强方法的执行顺序已经有了较为深入的理解。这里我来总结下关键点：</p><ul><li>在同一个切面配置中，如果存在多个不同类型的增强，那么其执行优先级是按照增强类型的特定顺序排列，依次的增强类型为 Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class；</li><li>在同一个切面配置中，如果存在多个相同类型的增强，那么其执行优先级是按照该增强的方法名排序，排序方式依次为比较方法名的每一个字母，直到发现第一个不相同且 ASCII 码较小的字母。</li></ul><p>同时，这节课我们也拓展了一些比较器相关的知识：</p><ul><li>任意两个比较器（Comparator）可以通过 thenComparing() 连接合成一个新的连续比较器；</li><li>比较器的比较规则有一个简单的方法可以帮助你理解，就是最终一定需要对象两两比较，而比较的过程一定是比较这两个对象的同种属性。你只要抓住这两点：比较了什么属性以及比较的结果是什么就可以了，若比较结果为正数，则按照该属性的升序排列；若为负数，则按属性降序排列。</li></ul><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/07#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>实际上，审阅上面两个案例的修正方案，你会发现它们虽然改动很小，但是都还不够优美。那么有没有稍微优美点的替代方案呢？如果有，你知道背后的原理及关键源码吗？顺便你也可以想想，我为什么没有用更优美的方案呢？</p><p>期待在留言区看到你的思考，我们下节课再见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/spring编程常见错误50例/02.SpringCore篇/07.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:06:36</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-java/umi.fde43fdb.js"></script>
  </body>
</html>
