<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-java/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-java";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>03｜Spring Bean 依赖注入常见错误（下） - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/spring编程常见错误50例/02.spring-core篇/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a aria-current="page" class="active" href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a aria-current="page" class="active" href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/spring编程常见错误50例/01.课前必读">01.课前必读</a><ul><li><a href="/blog-java/spring编程常见错误50例/01.课前必读/01"><span>开篇词｜贴心“保姆”Spring罢工了怎么办？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-java/spring编程常见错误50例/02.spring-core篇">02.SpringCore篇</a><ul><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/01"><span>导读｜5分钟轻松了解Spring基础知识</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/02"><span>01｜Spring Bean 定义常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/03"><span>02｜Spring Bean 依赖注入常见错误（上）</span></a></li><li><a aria-current="page" class="active" href="/blog-java/spring编程常见错误50例/02.spring-core篇/04"><span>03｜Spring Bean 依赖注入常见错误（下）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/05"><span>04｜Spring Bean 生命周期常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/06"><span>05｜Spring AOP 常见错误（上）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/07"><span>06｜Spring AOP 常见错误（下）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/08"><span>07｜Spring事件常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/09"><span>08｜答疑现场：Spring Core 篇思考题合集</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇">03.SpringWeb篇</a><ul><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/01"><span>导读｜5分钟轻松了解一个HTTP请求的处理过程</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/02"><span>09｜Spring Web URL 解析常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/03"><span>10 | Spring Web Header 解析常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/04"><span>11 | Spring Web Body 转化常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/05"><span>12｜Spring Web 参数验证常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/06"><span>13 | Spring Web 过滤器使用常见错误（上）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/07"><span>14 | Spring Web 过滤器使用常见错误（下）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/08"><span>15 | Spring Security 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/09"><span>16｜Spring Exception 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/03.spring-web篇/10"><span>17｜答疑现场：Spring Web 篇思考题合集</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇">04.Spring补充篇</a><ul><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/01"><span>18 | Spring Data 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/02"><span>19 | Spring 事务常见错误（上）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/03"><span>20 | Spring 事务常见错误（下）</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/04"><span>21 | Spring Rest Template 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/05"><span>22 | Spring Test 常见错误</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/06"><span>23｜答疑现场：Spring 补充篇思考题合集</span></a></li><li><a href="/blog-java/spring编程常见错误50例/04.spring补充篇/07"><span>知识回顾 | 系统梳理Spring编程错误根源</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/05.结束语">05.结束语</a><ul><li><a href="/blog-java/spring编程常见错误50例/05.结束语/01"><span>结束语｜问题总比解决办法多</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/06.期末测试">06.期末测试</a><ul><li><a href="/blog-java/spring编程常见错误50例/06.期末测试/01"><span>期末测试｜来赴一场100分之约！</span></a></li></ul></li><li><a href="/blog-java/spring编程常见错误50例/summary">spring编程常见错误50例</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="案例1：@Value没有注入预期的值" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#案例1value没有注入预期的值"><span>案例1：@Value没有注入预期的值</span></a></li><li title="案例解析" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#案例解析"><span>案例解析</span></a></li><li title="问题修正" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#问题修正"><span>问题修正</span></a></li><li title="案例2：错乱的注入集合" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#案例2错乱的注入集合"><span>案例2：错乱的注入集合</span></a></li><li title="案例解析" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#案例解析-1"><span>案例解析</span></a></li><li title="问题修正" data-depth="3"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#问题修正-1"><span>问题修正</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#重点回顾"><span>重点回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="03spring-bean-依赖注入常见错误下"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#03spring-bean-依赖注入常见错误下"><span class="icon icon-link"></span></a>03｜Spring Bean 依赖注入常见错误（下）</h1><p>你好，我是傅健，这节课我们接着聊Spring的自动注入。</p><p>上一讲我们介绍了3个Spring编程中关于依赖注入的错误案例，这些错误都是比较常见的。如果你仔细分析的话，你会发现它们大多都是围绕着@Autowired、@Qualifier的使用而发生，而且自动注入的类型也都是普通对象类型。</p><p>那在实际应用中，我们也会使用@Value等不太常见的注解来完成自动注入，同时也存在注入到集合、数组等复杂类型的场景。这些情况下，我们也会遇到一些问题。所以这一讲我们不妨来梳理下。</p><h2 id="案例1value没有注入预期的值"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#案例1value没有注入预期的值"><span class="icon icon-link"></span></a>案例1：@Value没有注入预期的值</h2><p>在装配对象成员属性时，我们常常会使用@Autowired来装配。但是，有时候我们也使用@Value进行装配。不过这两种注解使用风格不同，使用@Autowired一般都不会设置属性值，而@Value必须指定一个字符串值，因为其定义做了要求，定义代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public @interface Value {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       /**</span></div><div class="token-line"><span class="token plain">        * The actual value expression &amp;mdash; for example, &lt;code&gt;#{systemProperties.myProp}&lt;/code&gt;.</span></div><div class="token-line"><span class="token plain">        */</span></div><div class="token-line"><span class="token plain">       String value();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>另外在比较这两者的区别时，<strong>我们一般都会因为@Value常用于String类型的装配而误以为@Value不能用于非内置对象的装配，实际上这是一个常见的误区</strong>。例如，我们可以使用下面这种方式来Autowired一个属性成员：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Value(&quot;#{student}&quot;)</span></div><div class="token-line"><span class="token plain">    private Student student;</span></div></pre></div><p>其中student这个Bean定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Bean</span></div><div class="token-line"><span class="token plain">    public Student student(){</span></div><div class="token-line"><span class="token plain">        Student student = createStudent(1, &quot;xie&quot;);</span></div><div class="token-line"><span class="token plain">        return student;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>当然，正如前面提及，我们使用@Value更多是用来装配String，而且它支持多种强大的装配方式，典型的方式参考下面的示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//注册正常字符串</span></div><div class="token-line"><span class="token plain">    @Value(&quot;我是字符串&quot;)</span></div><div class="token-line"><span class="token plain">    private String text; </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    //注入系统参数、环境变量或者配置文件中的值</span></div><div class="token-line"><span class="token plain">    @Value(&quot;${ip}&quot;)</span></div><div class="token-line"><span class="token plain">    private String ip</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    //注入其他Bean属性，其中student为bean的ID，name为其属性</span></div><div class="token-line"><span class="token plain">    @Value(&quot;#{student.name}&quot;)</span></div><div class="token-line"><span class="token plain">    private String name;</span></div></pre></div><p>上面我给你简单介绍了@Value的强大功能，以及它和@Autowired的区别。那么在使用@Value时可能会遇到那些错误呢？这里分享一个最为典型的错误，即使用@Value可能会注入一个不是预期的值。</p><p>我们可以模拟一个场景，我们在配置文件application.properties配置了这样一个属性：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">username=admin</span></div><div class="token-line"><span class="token plain">    password=pass</span></div></pre></div><p>然后我们在一个Bean中，分别定义两个属性来引用它们：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RestController</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class ValueTestController {</span></div><div class="token-line"><span class="token plain">        @Value(&quot;${username}&quot;)</span></div><div class="token-line"><span class="token plain">        private String username;</span></div><div class="token-line"><span class="token plain">        @Value(&quot;${password}&quot;)</span></div><div class="token-line"><span class="token plain">        private String password;</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">        @RequestMapping(path = &quot;user&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">        public String getUser(){</span></div><div class="token-line"><span class="token plain">           return username + &quot;:&quot; + password;</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>当我们去打印上述代码中的username和password时，我们会发现password正确返回了，但是username返回的并不是配置文件中指明的admin，而是运行这段程序的计算机用户名。很明显，使用@Value装配的值没有完全符合我们的预期。</p><h3 id="案例解析"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#案例解析"><span class="icon icon-link"></span></a>案例解析</h3><p>通过分析运行结果，我们可以知道@Value的使用方式应该是没有错的，毕竟password这个字段装配上了，但是为什么username没有生效成正确的值？接下来我们就来具体解析下。</p><p>我们首先了解下对于@Value，Spring是如何根据@Value来查询“值”的。我们可以先通过方法DefaultListableBeanFactory#doResolveDependency来了解@Value的核心工作流程，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Nullable</span></div><div class="token-line"><span class="token plain">    public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,</span></div><div class="token-line"><span class="token plain">          @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {</span></div><div class="token-line"><span class="token plain">        //省略其他非关键代码</span></div><div class="token-line"><span class="token plain">        Class&lt;?&gt; type = descriptor.getDependencyType();</span></div><div class="token-line"><span class="token plain">          //寻找@Value</span></div><div class="token-line"><span class="token plain">          Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</span></div><div class="token-line"><span class="token plain">          if (value != null) {</span></div><div class="token-line"><span class="token plain">             if (value instanceof String) {</span></div><div class="token-line"><span class="token plain">                //解析Value值</span></div><div class="token-line"><span class="token plain">                String strVal = resolveEmbeddedValue((String) value);</span></div><div class="token-line"><span class="token plain">                BeanDefinition bd = (beanName != null &amp;&amp; containsBean(beanName) ?</span></div><div class="token-line"><span class="token plain">                      getMergedBeanDefinition(beanName) : null);</span></div><div class="token-line"><span class="token plain">                value = evaluateBeanDefinitionString(strVal, bd);</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             </span></div><div class="token-line"><span class="token plain">             //转化Value解析的结果到装配的类型</span></div><div class="token-line"><span class="token plain">             TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());</span></div><div class="token-line"><span class="token plain">             try {</span></div><div class="token-line"><span class="token plain">                return converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">             catch (UnsupportedOperationException ex) {</span></div><div class="token-line"><span class="token plain">                //异常处理</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        //省略其他非关键代码</span></div><div class="token-line"><span class="token plain">      }</span></div></pre></div><p>​可以看到，@Value的工作大体分为以下三个核心步骤。</p><p><strong>1. 寻找@Value</strong></p><p>在这步中，主要是判断这个属性字段是否标记为@Value，依据的方法参考QualifierAnnotationAutowireCandidateResolver#findValue：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Nullable</span></div><div class="token-line"><span class="token plain">    protected Object findValue(Annotation[] annotationsToSearch) {</span></div><div class="token-line"><span class="token plain">       if (annotationsToSearch.length &gt; 0) {  </span></div><div class="token-line"><span class="token plain">          AnnotationAttributes attr = AnnotatedElementUtils.getMergedAnnotationAttributes(</span></div><div class="token-line"><span class="token plain">                AnnotatedElementUtils.forAnnotations(annotationsToSearch), this.valueAnnotationType);</span></div><div class="token-line"><span class="token plain">          //valueAnnotationType即为@Value</span></div><div class="token-line"><span class="token plain">          if (attr != null) {</span></div><div class="token-line"><span class="token plain">             return extractValue(attr);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       return null;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><strong>2. 解析@Value的字符串值</strong></p><p>如果一个字段标记了@Value，则可以拿到对应的字符串值，然后就可以根据字符串值去做解析，最终解析的结果可能是一个字符串，也可能是一个对象，这取决于字符串怎么写。</p><p><strong>3. 将解析结果转化为要装配的对象的类型</strong></p><p>当拿到第二步生成的结果后，我们会发现可能和我们要装配的类型不匹配。假设我们定义的是UUID，而我们获取的结果是一个字符串，那么这个时候就会根据目标类型来寻找转化器执行转化，字符串到UUID的转化实际上发生在UUIDEditor中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class UUIDEditor extends PropertyEditorSupport {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       @Override</span></div><div class="token-line"><span class="token plain">       public void setAsText(String text) throws IllegalArgumentException          {</span></div><div class="token-line"><span class="token plain">          if (StringUtils.hasText(text)) {</span></div><div class="token-line"><span class="token plain">             //转化操作</span></div><div class="token-line"><span class="token plain">             setValue(UUID.fromString(text.trim()));</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          else {</span></div><div class="token-line"><span class="token plain">             setValue(null);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       //省略其他非关代码</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>通过对上面几个关键步骤的解析，我们大体了解了@Value的工作流程。结合我们的案例，很明显问题应该发生在第二步，即解析Value指定字符串过程，执行过程参考下面的关键代码行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">String strVal = resolveEmbeddedValue((String) value);</span></div></pre></div><p>这里其实是在解析嵌入的值，实际上就是“替换占位符”工作。具体而言，它采用的是PropertySourcesPlaceholderConfigurer根据PropertySources来替换。不过当使用 $<!-- -->{<!-- -->username<!-- -->}<!-- --> 来获取替换值时，其最终执行的查找并不是局限在application.property文件中的。通过调试，我们可以看到下面的这些“源”都是替换依据：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage254025d4242bc0dae8fa730663b9122b7840.03a3fcd9.png" alt=""/></p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">[ConfigurationPropertySourcesPropertySource {name=&#x27;configurationProperties&#x27;}, </span></div><div class="token-line"><span class="token plain">    StubPropertySource {name=&#x27;servletConfigInitParams&#x27;}, ServletContextPropertySource {name=&#x27;servletContextInitParams&#x27;}, PropertiesPropertySource {name=&#x27;systemProperties&#x27;}, OriginAwareSystemEnvironmentPropertySource {name=&#x27;systemEnvironment&#x27;}, RandomValuePropertySource {name=&#x27;random&#x27;},</span></div><div class="token-line"><span class="token plain">    OriginTrackedMapPropertySource {name=&#x27;applicationConfig: classpath:/application.properties]&#x27;},</span></div><div class="token-line"><span class="token plain">    MapPropertySource {name=&#x27;devtools&#x27;}]</span></div></pre></div><p>而具体的查找执行，我们可以通过下面的代码（PropertySourcesPropertyResolver#getProperty）来获取它的执行方式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Nullable</span></div><div class="token-line"><span class="token plain">    protected &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetValueType, boolean resolveNestedPlaceholders) {</span></div><div class="token-line"><span class="token plain">       if (this.propertySources != null) {</span></div><div class="token-line"><span class="token plain">          for (PropertySource&lt;?&gt; propertySource : this.propertySources) {</span></div><div class="token-line"><span class="token plain">             Object value = propertySource.getProperty(key);</span></div><div class="token-line"><span class="token plain">             if (value != null) {</span></div><div class="token-line"><span class="token plain">             //查到value即退出  </span></div><div class="token-line"><span class="token plain">             return convertValueIfNecessary(value, targetValueType);</span></div><div class="token-line"><span class="token plain">             }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">       return null;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从这可以看出，在解析Value字符串时，其实是有顺序的（查找的源是存在CopyOnWriteArrayList中，在启动时就被有序固定下来），一个一个“源”执行查找，在其中一个源找到后，就可以直接返回了。</p><p>如果我们查看systemEnvironment这个源，会发现刚好有一个username和我们是重合的，且值不是pass。</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimageeb28eb48b0d27dc7d0dyy32a548934edc728.b7a91eb5.png" alt=""/></p><p>所以，讲到这里，你应该知道问题所在了吧？这是一个误打误撞的例子，刚好系统环境变量（systemEnvironment）中含有同名的配置。实际上，对于系统参数（systemProperties）也是一样的，这些参数或者变量都有很多，如果我们没有意识到它的存在，起了一个同名的字符串作为@Value的值，则很容易引发这类问题。</p><h3 id="问题修正"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#问题修正"><span class="icon icon-link"></span></a>问题修正</h3><p>针对这个案例，有了源码的剖析，我们就可以很快地找到解决方案了。例如我们可以避免使用同一个名称，具体修改如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">user.name=admin</span></div><div class="token-line"><span class="token plain">    user.password=pass</span></div></pre></div><p>但是如果我们这么改的话，其实还是不行的。实际上，通过之前的调试方法，我们可以找到类似的原因，在systemProperties这个PropertiesPropertySource源中刚好存在user.name，真是无巧不成书。所以命名时，我们一定要注意<strong>不仅要避免和环境变量冲突，也要注意避免和系统变量等其他变量冲突</strong>，这样才能从根本上解决这个问题。</p><p>通过这个案例，我们可以知道：Spring给我们提供了很多好用的功能，但是这些功能交织到一起后，就有可能让我们误入一些坑，只有了解它的运行方式，我们才能迅速定位问题、解决问题。</p><h2 id="案例2错乱的注入集合"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#案例2错乱的注入集合"><span class="icon icon-link"></span></a>案例2：错乱的注入集合</h2><p>前面我们介绍了很多自动注入的错误案例，但是这些案例都局限在单个类型的注入，对于集合类型的注入并无提及。实际上，<strong>集合类型的自动注入是Spring提供的另外一个强大功能。</strong></p><p>假设我们存在这样一个需求：存在多个学生Bean，我们需要找出来，并存储到一个List里面去。多个学生Bean的定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Bean</span></div><div class="token-line"><span class="token plain">    public Student student1(){</span></div><div class="token-line"><span class="token plain">        return createStudent(1, &quot;xie&quot;);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    @Bean</span></div><div class="token-line"><span class="token plain">    public Student student2(){</span></div><div class="token-line"><span class="token plain">        return createStudent(2, &quot;fang&quot;);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    private Student createStudent(int id, String name) {</span></div><div class="token-line"><span class="token plain">        Student student = new Student();</span></div><div class="token-line"><span class="token plain">        student.setId(id);</span></div><div class="token-line"><span class="token plain">        student.setName(name);</span></div><div class="token-line"><span class="token plain">        return student;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>有了集合类型的自动注入后，我们就可以把零散的学生Bean收集起来了，代码示例如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@RestController</span></div><div class="token-line"><span class="token plain">    @Slf4j</span></div><div class="token-line"><span class="token plain">    public class StudentController {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        private List&lt;Student&gt; students;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public StudentController(List&lt;Student&gt; students){</span></div><div class="token-line"><span class="token plain">            this.students = students;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @RequestMapping(path = &quot;students&quot;, method = RequestMethod.GET)</span></div><div class="token-line"><span class="token plain">        public String listStudents(){</span></div><div class="token-line"><span class="token plain">           return students.toString();</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>通过上述代码，我们就可以完成集合类型的注入工作，输出结果如下：</p><blockquote><p>[Student(id=1, name=xie), Student(id=2, name=fang)]</p></blockquote><p>然而，业务总是复杂的，需求也是一直变动的。当我们持续增加一些student时，可能就不喜欢用这种方式来注入集合类型了，而是倾向于用下面的方式去完成注入工作：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Bean</span></div><div class="token-line"><span class="token plain">    public List&lt;Student&gt; students(){</span></div><div class="token-line"><span class="token plain">        Student student3 = createStudent(3, &quot;liu&quot;);</span></div><div class="token-line"><span class="token plain">        Student student4 = createStudent(4, &quot;fu&quot;);</span></div><div class="token-line"><span class="token plain">        return Arrays.asList(student3, student4);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>为了好记，这里我们不妨将上面这种方式命名为“直接装配方式”，而将之前的那种命名为“收集方式”。</p><p>实际上，如果这两种方式是非此即彼的存在，自然没有任何问题，都能玩转。但是如果我们不小心让这2种方式同时存在了，结果会怎样？</p><p>这时候很多人都会觉得Spring很强大，肯定会合并上面的结果，或者认为肯定是以直接装配结果为准。然而，当我们运行起程序，就会发现后面的注入方式根本没有生效。即依然返回的是前面定义的2个学生。为什么会出现这样的错误呢？</p><h3 id="案例解析-1"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#案例解析-1"><span class="icon icon-link"></span></a>案例解析</h3><p>要了解这个错误的根本原因，你就得先清楚这两种注入风格在Spring中是如何实现的。对于收集装配风格，Spring使用的是DefaultListableBeanFactory#resolveMultipleBeans来完成装配工作，针对本案例关键的核心代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private Object resolveMultipleBeans(DependencyDescriptor descriptor, @Nullable String beanName,</span></div><div class="token-line"><span class="token plain">          @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) {</span></div><div class="token-line"><span class="token plain">       final Class&lt;?&gt; type = descriptor.getDependencyType();</span></div><div class="token-line"><span class="token plain">       if (descriptor instanceof StreamDependencyDescriptor) {</span></div><div class="token-line"><span class="token plain">          //装配stream</span></div><div class="token-line"><span class="token plain">          return stream;</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       else if (type.isArray()) {</span></div><div class="token-line"><span class="token plain">          //装配数组</span></div><div class="token-line"><span class="token plain">          return result;</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       else if (Collection.class.isAssignableFrom(type) &amp;&amp; type.isInterface()) {</span></div><div class="token-line"><span class="token plain">          //装配集合</span></div><div class="token-line"><span class="token plain">          //获取集合的元素类型</span></div><div class="token-line"><span class="token plain">          Class&lt;?&gt; elementType = descriptor.getResolvableType().asCollection().resolveGeneric();</span></div><div class="token-line"><span class="token plain">          if (elementType == null) {</span></div><div class="token-line"><span class="token plain">             return null;</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          //根据元素类型查找所有的bean</span></div><div class="token-line"><span class="token plain">          Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, elementType,</span></div><div class="token-line"><span class="token plain">                new MultiElementDescriptor(descriptor));</span></div><div class="token-line"><span class="token plain">          if (matchingBeans.isEmpty()) {</span></div><div class="token-line"><span class="token plain">             return null;</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          if (autowiredBeanNames != null) {</span></div><div class="token-line"><span class="token plain">             autowiredBeanNames.addAll(matchingBeans.keySet());</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">          //转化查到的所有bean放置到集合并返回</span></div><div class="token-line"><span class="token plain">          TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());</span></div><div class="token-line"><span class="token plain">          Object result = converter.convertIfNecessary(matchingBeans.values(), type);</span></div><div class="token-line"><span class="token plain">          //省略非关键代码</span></div><div class="token-line"><span class="token plain">          return result;</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       else if (Map.class == type) {</span></div><div class="token-line"><span class="token plain">          //解析map</span></div><div class="token-line"><span class="token plain">          return matchingBeans;</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">       else {</span></div><div class="token-line"><span class="token plain">          return null;</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>到这，我们就不难概括出这种收集式集合装配方式的大体过程了。</p><p><strong>1. 获取集合类型的元素类型</strong></p><p>针对本案例，目标类型定义为List&lt;Student&gt; students，所以元素类型为Student，获取的具体方法参考代码行：</p><blockquote><p>Class&lt;?&gt; elementType = descriptor.getResolvableType().asCollection().resolveGeneric();</p></blockquote><p><strong>2. 根据元素类型，找出所有的Bean</strong></p><p>有了上面的元素类型，即可根据元素类型来找出所有的Bean，关键代码行如下：</p><blockquote><p>Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, elementType, new MultiElementDescriptor(descriptor));</p></blockquote><p><strong>3. 将匹配的所有的Bean按目标类型进行转化</strong></p><p>经过步骤2，我们获取的所有的Bean都是以java.util.LinkedHashMap.LinkedValues形式存储的，和我们的目标类型大概率不同，所以最后一步需要做的是<strong>按需转化</strong>。在本案例中，我们就需要把它转化为List，转化的关键代码如下：</p><blockquote><p>Object result = converter.convertIfNecessary(matchingBeans.values(), type);</p></blockquote><p>如果我们继续深究执行细节，就可以知道最终是转化器CollectionToCollectionConverter来完成这个转化过程。</p><p>学习完收集方式的装配原理，我们再来看下直接装配方式的执行过程，实际上这步在前面的课程中我们就提到过（即DefaultListableBeanFactory#findAutowireCandidates方法执行），具体的执行过程这里就不多说了。</p><p>知道了执行过程，接下来无非就是根据目标类型直接寻找匹配的Bean。在本案例中，就是将Bean名称为students的List&lt;Student&gt;装配给StudentController#students属性。</p><p>了解了这两种方式，我们再来思考这两种方式的关系：当同时满足这两种装配方式时，Spring是如何处理的？这里我们可以参考方法DefaultListableBeanFactory#doResolveDependency的几行关键代码，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span></div><div class="token-line"><span class="token plain">    if (multipleBeans != null) {</span></div><div class="token-line"><span class="token plain">       return multipleBeans;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span></div></pre></div><p>很明显，这两种装配集合的方式是<strong>不能同存</strong>的，结合本案例，当使用收集装配方式来装配时，能找到任何一个对应的Bean，则返回，如果一个都没有找到，才会采用直接装配的方式。说到这里，你大概能理解为什么后期以List方式直接添加的Student Bean都不生效了吧。</p><h3 id="问题修正-1"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#问题修正-1"><span class="icon icon-link"></span></a>问题修正</h3><p>现在如何纠正这个问题就变得简单多了，就是你一定要下意识地避免这2种方式共存去装配集合，只用一个这个问题就迎刃而解了。例如，在这里，我们可以使用直接装配的方式去修正问题，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Bean</span></div><div class="token-line"><span class="token plain">    public List&lt;Student&gt; students(){</span></div><div class="token-line"><span class="token plain">        Student student1 = createStudent(1, &quot;xie&quot;);</span></div><div class="token-line"><span class="token plain">        Student student2 = createStudent(2, &quot;fang&quot;);</span></div><div class="token-line"><span class="token plain">        Student student3 = createStudent(3, &quot;liu&quot;);</span></div><div class="token-line"><span class="token plain">        Student student4 = createStudent(4, &quot;fu&quot;);</span></div><div class="token-line"><span class="token plain">        return Arrays.asList(student1，student2，student3, student4);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>也可以使用收集方式来修正问题时，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Bean</span></div><div class="token-line"><span class="token plain">        public Student student1(){</span></div><div class="token-line"><span class="token plain">            return createStudent(1, &quot;xie&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public Student student2(){</span></div><div class="token-line"><span class="token plain">            return createStudent(2, &quot;fang&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public Student student3(){</span></div><div class="token-line"><span class="token plain">            return createStudent(3, &quot;liu&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        @Bean</span></div><div class="token-line"><span class="token plain">        public Student student4(){</span></div><div class="token-line"><span class="token plain">            return createStudent(4, &quot;fu&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div></pre></div><p>总之，都是可以的。还有一点要注意：<strong>在对于同一个集合对象的注入上，混合多种注入方式是不可取的，这样除了错乱，别无所得。</strong></p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>今天我们又学习了关于Spring自动注入的两个典型案例。</p><p>通过案例1的学习，我们了解到@Value不仅可以用来注入String类型，也可以注入自定义对象类型。同时在注入String时，你一定要意识到它不仅仅可以用来引用配置文件里配置的值，也可能引用到环境变量、系统参数等。</p><p>而通过案例2的学习，我们了解到集合类型的注入支持两种常见的方式，即上文中我们命名的收集装配式和直接装配式。这两种方式共同装配一个属性时，后者就会失效。</p><p>综合上一讲的内容，我们一共分析了5个问题以及背后的原理，通过这些案例的分析，我们不难看出Spring的自动注入非常强大，围绕@Autowired、@Qualifier、@Value等内置注解，我们可以完成不同的注入目标和需求。不过这种强大，正如我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/364661">开篇词<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中提及的，它建立在很多隐性的规则之上。只有你把这些规则都烂熟于心了，才能很好地去规避问题。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-java/spring编程常见错误50例/02.spring-core篇/04#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>在案例2中，我们初次运行程序获取的结果如下：</p><blockquote><p>[Student(id=1, name=xie), Student(id=2, name=fang)]</p></blockquote><p>那么如何做到让学生2优先输出呢？</p><p>我们留言区见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/spring编程常见错误50例/02.SpringCore篇/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:06:36</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-java/umi.fde43fdb.js"></script>
  </body>
</html>
