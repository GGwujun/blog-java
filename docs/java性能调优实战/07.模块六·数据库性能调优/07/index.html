<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-java/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-java";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>39 | 数据库参数设置优化，失之毫厘差之千里 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/java性能调优实战/07.模块六·数据库性能调优/07" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a aria-current="page" class="active" href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-java/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a href="/blog-java/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-java/java并发编程实战">java并发编程实战</a></li><li><a aria-current="page" class="active" href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-java/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-java/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-java/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-java/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-java/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-java/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-java/java性能调优实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-java/java性能调优实战/01.开篇词/01"><span>开篇词 | 怎样才能做好性能调优？</span></a></li></ul></li><li><a href="/blog-java/java性能调优实战/02.模块一·概述">02.模块一·概述</a><ul><li><a href="/blog-java/java性能调优实战/02.模块一·概述/01"><span>01 | 如何制定性能调优标准？</span></a></li><li><a href="/blog-java/java性能调优实战/02.模块一·概述/02"><span>02 | 如何制定性能调优策略？</span></a></li></ul></li><li><a href="/blog-java/java性能调优实战/03.模块二·java编程性能调优">03.模块二·Java编程性能调优</a><ul><li><a href="/blog-java/java性能调优实战/03.模块二·java编程性能调优/01"><span>03 | 字符串性能优化不容小觑，百M内存轻松存储几十G数据</span></a></li><li><a href="/blog-java/java性能调优实战/03.模块二·java编程性能调优/02"><span>04 | 慎重使用正则表达式</span></a></li><li><a href="/blog-java/java性能调优实战/03.模块二·java编程性能调优/03"><span>05 | ArrayList还是LinkedList？使用不当性能差千倍</span></a></li><li><a href="/blog-java/java性能调优实战/03.模块二·java编程性能调优/04"><span>加餐 | 推荐几款常用的性能测试工具</span></a></li><li><a href="/blog-java/java性能调优实战/03.模块二·java编程性能调优/05"><span>06 | Stream如何提高遍历集合效率？</span></a></li><li><a href="/blog-java/java性能调优实战/03.模块二·java编程性能调优/06"><span>07 | 深入浅出HashMap的设计与优化</span></a></li><li><a href="/blog-java/java性能调优实战/03.模块二·java编程性能调优/07"><span>08 | 网络通信优化之I/O模型：如何解决高并发下I/O瓶颈？</span></a></li><li><a href="/blog-java/java性能调优实战/03.模块二·java编程性能调优/08"><span>09 | 网络通信优化之序列化：避免使用Java序列化</span></a></li><li><a href="/blog-java/java性能调优实战/03.模块二·java编程性能调优/09"><span>10 | 网络通信优化之通信协议：如何优化RPC网络通信？</span></a></li><li><a href="/blog-java/java性能调优实战/03.模块二·java编程性能调优/10"><span>11 | 答疑课堂：深入了解NIO的优化实现原理</span></a></li></ul></li><li><a href="/blog-java/java性能调优实战/04.模块三·多线程性能调优">04.模块三·多线程性能调优</a><ul><li><a href="/blog-java/java性能调优实战/04.模块三·多线程性能调优/01"><span>12 | 多线程之锁优化（上）：深入了解Synchronized同步锁的优化方法</span></a></li><li><a href="/blog-java/java性能调优实战/04.模块三·多线程性能调优/02"><span>13 | 多线程之锁优化（中）：深入了解Lock同步锁的优化方法</span></a></li><li><a href="/blog-java/java性能调优实战/04.模块三·多线程性能调优/03"><span>14 | 多线程之锁优化（下）：使用乐观锁优化并行操作</span></a></li><li><a href="/blog-java/java性能调优实战/04.模块三·多线程性能调优/04"><span>15 | 多线程调优（上）：哪些操作导致了上下文切换？</span></a></li><li><a href="/blog-java/java性能调优实战/04.模块三·多线程性能调优/05"><span>16 | 多线程调优（下）：如何优化多线程上下文切换？</span></a></li><li><a href="/blog-java/java性能调优实战/04.模块三·多线程性能调优/06"><span>17 | 并发容器的使用：识别不同场景下最优容器</span></a></li><li><a href="/blog-java/java性能调优实战/04.模块三·多线程性能调优/07"><span>18 | 如何设置线程池大小？</span></a></li><li><a href="/blog-java/java性能调优实战/04.模块三·多线程性能调优/08"><span>19 | 如何用协程来优化多线程业务？</span></a></li><li><a href="/blog-java/java性能调优实战/04.模块三·多线程性能调优/09"><span>20 | 答疑课堂：模块三热点问题解答</span></a></li><li><a href="/blog-java/java性能调优实战/04.模块三·多线程性能调优/10"><span>加餐 | 什么是数据的强、弱一致性？</span></a></li></ul></li><li><a href="/blog-java/java性能调优实战/05.模块四·jvm性能监测及调优">05.模块四·JVM性能监测及调优</a><ul><li><a href="/blog-java/java性能调优实战/05.模块四·jvm性能监测及调优/01"><span>21 | 磨刀不误砍柴工：欲知JVM调优先了解JVM内存模型</span></a></li><li><a href="/blog-java/java性能调优实战/05.模块四·jvm性能监测及调优/02"><span>22 | 深入JVM即时编译器JIT，优化Java编译</span></a></li><li><a href="/blog-java/java性能调优实战/05.模块四·jvm性能监测及调优/03"><span>23 | 如何优化垃圾回收机制？</span></a></li><li><a href="/blog-java/java性能调优实战/05.模块四·jvm性能监测及调优/04"><span>24 | 如何优化JVM内存分配？</span></a></li><li><a href="/blog-java/java性能调优实战/05.模块四·jvm性能监测及调优/05"><span>25 | 内存持续上升，我该如何排查问题？</span></a></li><li><a href="/blog-java/java性能调优实战/05.模块四·jvm性能监测及调优/06"><span>26 | 答疑课堂：模块四热点问题解答</span></a></li></ul></li><li><a href="/blog-java/java性能调优实战/06.模块五·设计模式调优">06.模块五·设计模式调优</a><ul><li><a href="/blog-java/java性能调优实战/06.模块五·设计模式调优/01"><span>27 | 单例模式：如何创建单一对象优化系统性能？</span></a></li><li><a href="/blog-java/java性能调优实战/06.模块五·设计模式调优/02"><span>28 | 原型模式与享元模式：提升系统性能的利器</span></a></li><li><a href="/blog-java/java性能调优实战/06.模块五·设计模式调优/03"><span>29 | 如何使用设计模式优化并发编程？</span></a></li><li><a href="/blog-java/java性能调优实战/06.模块五·设计模式调优/04"><span>30 | 生产者消费者模式：电商库存设计优化</span></a></li><li><a href="/blog-java/java性能调优实战/06.模块五·设计模式调优/05"><span>31 | 装饰器模式：如何优化电商系统中复杂的商品价格策略？</span></a></li><li><a href="/blog-java/java性能调优实战/06.模块五·设计模式调优/06"><span>32 | 答疑课堂：模块五思考题集锦</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-java/java性能调优实战/07.模块六·数据库性能调优">07.模块六·数据库性能调优</a><ul><li><a href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/01"><span>33 | MySQL调优之SQL语句：如何写出高性能SQL语句？</span></a></li><li><a href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/02"><span>34 | MySQL调优之事务：高并发场景下的数据库事务调优</span></a></li><li><a href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/03"><span>35 | MySQL调优之索引：索引的失效与优化</span></a></li><li><a href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/04"><span>36 | 记一次线上SQL死锁事故：如何避免死锁？</span></a></li><li><a href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/05"><span>37 | 什么时候需要分表分库？</span></a></li><li><a href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/06"><span>38 | 电商系统表设计优化案例分析</span></a></li><li><a aria-current="page" class="active" href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07"><span>39 | 数据库参数设置优化，失之毫厘差之千里</span></a></li><li><a href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/08"><span>40 | 答疑课堂：MySQL中InnoDB的知识点串讲</span></a></li></ul></li><li><a href="/blog-java/java性能调优实战/08.模块七·实战演练场">08.模块七·实战演练场</a><ul><li><a href="/blog-java/java性能调优实战/08.模块七·实战演练场/01"><span>41 | 如何设计更优的分布式锁？</span></a></li><li><a href="/blog-java/java性能调优实战/08.模块七·实战演练场/02"><span>42 | 电商系统的分布式事务调优</span></a></li><li><a href="/blog-java/java性能调优实战/08.模块七·实战演练场/03"><span>43 | 如何使用缓存优化系统性能？</span></a></li><li><a href="/blog-java/java性能调优实战/08.模块七·实战演练场/04"><span>44 | 记一次双十一抢购性能瓶颈调优</span></a></li></ul></li><li><a href="/blog-java/java性能调优实战/09.结束语">09.结束语</a><ul><li><a href="/blog-java/java性能调优实战/09.结束语/01"><span>结束语 | 栉风沐雨，砥砺前行！</span></a></li></ul></li><li><a href="/blog-java/java性能调优实战/10.期末测试">10.期末测试</a><ul><li><a href="/blog-java/java性能调优实战/10.期末测试/01"><span>期末测试 | 有关Java性能调优，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog-java/java性能调优实战/summary">java性能调优实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="MySQL体系结构" data-depth="2"><a href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#mysql体系结构"><span>MySQL体系结构</span></a></li><li title="1. 查询语句" data-depth="3"><a href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#1-查询语句"><span>1. 查询语句</span></a></li><li title="2. 更新语句" data-depth="3"><a href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#2-更新语句"><span>2. 更新语句</span></a></li><li title="内存调优" data-depth="2"><a href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#内存调优"><span>内存调优</span></a></li><li title="1. MyISAM存储引擎参数设置调优" data-depth="3"><a href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#1-myisam存储引擎参数设置调优"><span>1. MyISAM存储引擎参数设置调优</span></a></li><li title="2. InnoDB存储引擎参数设置调优" data-depth="3"><a href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#2-innodb存储引擎参数设置调优"><span>2. InnoDB存储引擎参数设置调优</span></a></li><li title="总结" data-depth="2"><a href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="39--数据库参数设置优化失之毫厘差之千里"><a aria-hidden="true" tabindex="-1" href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#39--数据库参数设置优化失之毫厘差之千里"><span class="icon icon-link"></span></a>39 | 数据库参数设置优化，失之毫厘差之千里</h1><p>你好，我是刘超。</p><p>MySQL是一个灵活性比较强的数据库系统，提供了很多可配置参数，便于我们根据应用和服务器硬件来做定制化数据库服务。如果现在让你回想，你可能觉得在开发的过程中很少去调整MySQL的配置参数，但我今天想说的是我们很有必要去深入了解它们。</p><p>我们知道，数据库主要是用来存取数据的，而存取数据涉及到了磁盘I/O的读写操作，所以数据库系统主要的性能瓶颈就是I/O读写的瓶颈了。MySQL数据库为了减少磁盘I/O的读写操作，应用了大量内存管理来优化数据库操作，包括内存优化查询、排序以及写入操作。</p><p>也许你会想，我们把内存设置得越大越好，数据刷新到磁盘越快越好，不就对了吗？其实不然，内存设置过大，同样会带来新的问题。例如，InnoDB中的数据和索引缓存，如果设置过大，就会引发SWAP页交换。还有数据写入到磁盘也不是越快越好，我们期望的是在高并发时，数据能均匀地写入到磁盘中，从而避免I/O性能瓶颈。</p><blockquote><p>SWAP页交换：SWAP分区在系统的物理内存不够用的时候，就会把物理内存中的一部分空间释放出来，以供当前运行的程序使用。被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间的数据被临时保存到SWAP分区中，等到那些程序要运行时，再从SWAP分区中恢复保存的数据到内存中。</p></blockquote><p>所以，这些参数的设置跟我们的应用服务特性以及服务器硬件有很大的关系。MySQL是一个高定制化的数据库，我们可以根据需求来调整参数，定制性能最优的数据库。</p><p>不过想要了解这些参数的具体作用，我们先得了解数据库的结构以及不同存储引擎的工作原理。</p><h2 id="mysql体系结构"><a aria-hidden="true" tabindex="-1" href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#mysql体系结构"><span class="icon icon-link"></span></a>MySQL体系结构</h2><p>我们一般可以将MySQL的结构分为四层，最上层为客户端连接器，主要包括了数据库连接、授权认证、安全管理等，该层引用了线程池，为接入的连接请求提高线程处理效率。</p><p>第二层是Server层，主要实现SQL的一些基础功能，包括SQL解析、优化、执行以及缓存等，其中与我们这一讲主要相关的就是缓存。</p><p>第三层包括了各种存储引擎，主要负责数据的存取，这一层涉及到的Buffer缓存，也和这一讲密切相关。</p><p>最下面一层是数据存储层，主要负责将数据存储在文件系统中，并完成与存储引擎的交互。</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimage52a55297b9556d527dec788b5298d4810fa5.6b2d190e.jpg" alt=""/></p><p>接下来我们再来了解下，当数据接收到一个SQL语句时，是如何处理的。</p><h3 id="1-查询语句"><a aria-hidden="true" tabindex="-1" href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#1-查询语句"><span class="icon icon-link"></span></a>1. 查询语句</h3><p>一个应用服务需要通过第一层的连接和授权认证，再将SQL请求发送至SQL接口。SQL接口接收到请求之后，会先检查查询SQL是否命中Cache缓存中的数据，如果命中，则直接返回缓存中的结果；否则，需要进入解析器。</p><p>解析器主要对SQL进行语法以及词法分析，之后，便会进入到优化器中，优化器会生成多种执行计划方案，并选择最优方案执行。</p><p>确定了最优执行计划方案之后，执行器会检查连接用户是否有该表的执行权限，有则查看Buffer中是否存在该缓存，存在则获取锁，查询表数据；否则重新打开表文件，通过接口调用相应的存储引擎处理，这时存储引擎就会进入到存储文件系统中获取相应的数据，并返回结果集。</p><h3 id="2-更新语句"><a aria-hidden="true" tabindex="-1" href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#2-更新语句"><span class="icon icon-link"></span></a>2. 更新语句</h3><p>数据库更新SQL的执行流程其实跟查询SQL差不多，只不过执行更新操作的时候多了记录日志的步骤。在执行更新操作时MySQL会将操作的日志记录到 binlog（归档日志）中，这个步骤所有的存储引擎都有。而InnoDB除了要记录 binlog 之外，还需要多记录一个 redo log（重做日志）。</p><p>redo log 主要是为了解决 crash-safe 问题而引入的。我们知道，当数据库在存储数据时发生异常重启，我们需要保证存储的数据要么存储成功，要么存储失败，也就是不会出现数据丢失的情况，这就是crash-safe了。</p><p>我们在执行更新操作时，首先会查询相关的数据，之后通过执行器执行更新操作，并将执行结果写入到内存中，同时记录更新操作到redo log的缓存中，此时redo log中的记录状态为prepare，并通知执行器更新完成，随时可以提交事务。执行器收到通知后会执行binlog的写入操作，此时的binlog是记录在缓存中的，写入成功后会调用引擎的提交事务接口，更新记录状态为commit。之后，内存中的redo log以及binlog都会刷新到磁盘文件中。</p><h2 id="内存调优"><a aria-hidden="true" tabindex="-1" href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#内存调优"><span class="icon icon-link"></span></a>内存调优</h2><p>基于以上两个SQL执行过程，我们可以发现，在执行查询SQL语句时，会涉及到两个缓存。第一个缓存是刚进来时的Query Cache，它缓存的是SQL语句和对应的结果集。这里的缓存是以查询SQL的Hash值为key，返回结果集为value的键值对，判断一条SQL是否命中缓存，是通过匹配查询SQL的Hash值来实现的。</p><p>很明显，Query Cache可以优化查询SQL语句，减少大量工作，特别是减少了I/O读取操作。我们可以通过以下几个主要的设置参数来优化查询操作：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimagedbdddb97c34b74f0903673badc256ba46cdd.2d4d702d.jpg" alt=""/></p><p>我们可以通过设置合适的 query_cache_min_res_unit 来减少碎片，这个参数最合适的大小和应用程序查询结果的平均大小直接相关，可以通过以下公式计算所得：</p><p>（query_cache_size - Qcache_free_memory）/ Qcache_queries_in_cache</p><p>Qcache_free_memory 和 Qcache_queries_in_cache 的值可以通过以下命令查询：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">show status like &#x27;Qcache%&#x27;</span></div></pre></div><p>Query Cache虽然可以优化查询操作，但也仅限于不常修改的数据，如果一张表数据经常进行新增、更新和删除操作，则会造成Query Cache的失效率非常高，从而导致频繁地清除Cache中的数据，给系统增加额外的性能开销。</p><p>这也会导致缓存命中率非常低，我们可以通过以上查询状态的命令查看 Qcache_hits，该值表示缓存命中率。如果缓存命中率特别低的话，我们还可以通过query_cache_size = 0或者query_cache_type来关闭查询缓存。</p><p>经过了Query Cache缓存之后，还会使用到存储引擎中的Buffer缓存。不同的存储引擎，使用的Buffer也是不一样的。这里我们主要讲解两种常用的存储引擎。</p><h3 id="1-myisam存储引擎参数设置调优"><a aria-hidden="true" tabindex="-1" href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#1-myisam存储引擎参数设置调优"><span class="icon icon-link"></span></a>1. MyISAM存储引擎参数设置调优</h3><p>MyISAM存储引擎使用key buffer缓存索引块，MyISAM表的数据块则没有缓存，它是直接存储在磁盘文件中的。</p><p>我们可以通过key_buffer_size设置key buffer缓存的大小，而它的大小并不是越大越好。正如我前面所讲的，key buffer缓存设置过大，实际应用却不大的话，就容易造成内存浪费，而且系统也容易发生SWAP页交换，一般我是建议将服务器内存中可用内存的1/4分配给key buffer。</p><p>如果要更准确地评估key buffer的设置是否合理，我们还可以通过缓存使用率公式来计算：</p><p>1-((key_blocks_unused*key_cache_block_size)/key_buffer_size)</p><blockquote><p>key_blocks_unused表示未使用的缓存簇（blocks）数<br/>key_cache_block_size表示key_buffer_size被分割的区域大小key_blocks_unused*key_cache_block_size则表示剩余的可用缓存空间（一般来说，缓存使用率在80%作用比较合适）。</p></blockquote><h3 id="2-innodb存储引擎参数设置调优"><a aria-hidden="true" tabindex="-1" href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#2-innodb存储引擎参数设置调优"><span class="icon icon-link"></span></a>2. InnoDB存储引擎参数设置调优</h3><p>InnoDB Buffer Pool（简称IBP）是InnoDB存储引擎的一个缓冲池，与MyISAM存储引擎使用key buffer缓存不同，它不仅存储了表索引块，还存储了表数据。查询数据时，IBP允许快速返回频繁访问的数据，而无需访问磁盘文件。InnoDB表空间缓存越多，MySQL访问物理磁盘的频率就越低，这表示查询响应时间更快，系统的整体性能也有所提高。</p><p>我们一般可以通过多个设置参数来调整IBP，优化InnoDB表性能。</p><ul><li><strong>innodb_buffer_pool_size</strong></li></ul><p>IBP默认的内存大小是128M，我们可以通过参数innodb_buffer_pool_size来设置IBP的大小，IBP设置得越大，InnoDB表性能就越好。但是，将IBP大小设置得过大也不好，可能会导致系统发生SWAP页交换。所以我们需要在IBP大小和其它系统服务所需内存大小之间取得平衡。MySQL推荐配置IBP的大小为服务器物理内存的80%。</p><p>我们也可以通过计算InnoDB缓冲池的命中率来调整IBP大小：</p><p>(1-innodb_buffer_pool_reads/innodb_buffer_pool_read_request)*100</p><p>但如果我们将IBP的大小设置为物理内存的80%以后，发现命中率还是很低，此时我们就应该考虑扩充内存来增加IBP的大小。</p><ul><li><strong>innodb_buffer_pool_instances</strong></li></ul><p>InnoDB中的IBP缓冲池被划分为了多个实例，对于具有数千兆字节的缓冲池的系统来说，将缓冲池划分为单独的实例可以减少不同线程读取和写入缓存页面时的争用，从而提高系统的并发性。该参数项仅在将innodb_buffer_pool_size设置为1GB或更大时才会生效。</p><p>在windows 32位操作系统中，如果innodb_buffer_pool_size的大小超过1.3GB，innodb_buffer_pool_instances默认大小就为innodb_buffer_pool_size/128MB；否则，默认为1。</p><p>而在其它操作系统中，如果innodb_buffer_pool_size大小超过1GB，innodb_buffer_pool_instances值就默认为8；否则，默认为1。</p><p>为了获取最佳效率，建议指定innodb_buffer_pool_instances的大小，并保证每个缓冲池实例至少有1GB内存。通常，建议innodb_buffer_pool_instances的大小不超过innodb_read_io_threads + innodb_write_io_threads之和，建议实例和线程数量比例为1:1。</p><ul><li><strong>innodb_read_io_threads</strong> / <strong>innodb_write_io_threads</strong></li></ul><p>在默认情况下，MySQL后台线程包括了主线程、IO线程、锁线程以及监控线程等，其中读写线程属于IO线程，主要负责数据库的读取和写入操作，这些线程分别读取和写入innodb_buffer_pool_instances创建的各个内存页面。MySQL支持配置多个读写线程，即通过innodb_read_io_threads和innodb_write_io_threads设置读写线程数量。</p><p>读写线程数量值默认为4，也就是总共有8个线程同时在后台运行。innodb_read_io_threads和innodb_write_io_threads设置的读写线程数量，与innodb_buffer_pool_instances的大小有关，两者的协同优化是提高系统性能的一个关键因素。</p><p>在一些内存以及CPU内核超大型的数据库服务器上，我们可以在保证足够大的IBP内存的前提下，通过以下公式，协同增加缓存实例数量以及读写线程。</p><p>( innodb_read_io_threads + innodb_write_io_threads ) = innodb_buffe_pool_instances</p><p>如果我们仅仅是将读写线程根据缓存实例数量对半来分，即读线程和写线程各为实例大小的一半，肯定是不合理的。例如我们的应用服务读取数据库的数据多于写入数据库的数据，那么增加写入线程反而没有优化效果。我们一般可以通过MySQL服务器保存的全局统计信息，来确定系统的读取和写入比率。</p><p>我们可以通过以下查询来确定读写比率：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">SHOW GLOBAL STATUS LIKE &#x27;Com_select&#x27;;//读取数量</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    SHOW GLOBAL STATUS WHERE Variable_name IN (&#x27;Com_insert&#x27;, &#x27;Com_update&#x27;, &#x27;Com_replace&#x27;, &#x27;Com_delete&#x27;);//写入数量</span></div></pre></div><p>如果读大于写，我们应该考虑将读线程的数量设置得大一些，写线程数量小一些；否则，反之。</p><ul><li><strong>innodb_log_file_size</strong></li></ul><p>除了以上InnoDB缓存等因素之外，InnoDB的日志缓存大小、日志文件大小以及日志文件持久化到磁盘的策略都影响着InnnoDB的性能。 InnoDB中有一个redo log文件，InnoDB用它来存储服务器处理的每个写请求的重做活动。执行的每个写入查询都会在日志文件中获得重做条目，以便在发生崩溃时可以恢复更改。</p><p>当日志文件大小已经超过我们参数设置的日志文件大小时，InnoDB会自动切换到另外一个日志文件，由于重做日志是一个循环使用的环，在切换时，就需要将新的日志文件脏页的缓存数据刷新到磁盘中（触发检查点）。</p><p>理论上来说，innodb_log_file_size设置得越大，缓冲池中需要的检查点刷新活动就越少，从而节省磁盘I/O。那是不是将这个日志文件设置得越大越好呢？如果日志文件设置得太大，恢复时间就会变长，这样不便于DBA管理。在大多数情况下，我们将日志文件大小设置为1GB就足够了。</p><ul><li><strong>innodb_log_buffer_size</strong></li></ul><p>这个参数决定了InnoDB重做日志缓冲池的大小，默认值为8MB。如果高并发中存在大量的事务，该值设置得太小，就会增加写入磁盘的I/O操作。我们可以通过增大该参数来减少写入磁盘操作，从而提高并发时的事务性能。</p><ul><li><strong>innodb_flush_log_at_trx_commit</strong></li></ul><p>这个参数可以控制重做日志从缓存写入文件刷新到磁盘中的策略，默认值为1。</p><p>当设置该参数为0时，InnoDB每秒种就会触发一次缓存日志写入到文件中并刷新到磁盘的操作，这有可能在数据库崩溃后，丢失1s的数据。</p><p>当设置该参数为 1 时，则表示每次事务的 redo log 都会直接持久化到磁盘中，这样可以保证 MySQL 异常重启之后数据不会丢失。</p><p>当设置该参数为 2 时，每次事务的 redo log 都会直接写入到文件中，再将文件刷新到磁盘。</p><p>在一些对数据安全性要求比较高的场景中，显然该值需要设置为1；而在一些可以容忍数据库崩溃时丢失1s数据的场景中，我们可以将该值设置为0或2，这样可以明显地减少日志同步到磁盘的I/O操作。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#总结"><span class="icon icon-link"></span></a>总结</h2><p>MySQL数据库的参数设置非常多，今天我们仅仅是了解了与内存优化相关的参数设置。除了这些参数设置，我们还有一些常用的提高MySQL并发的相关参数设置，总结如下：</p><p><img src="/blog-java/static/httpsstatic001geekbangorgresourceimagebe4cbe83083a261bf1302aca81c122b0ac4c.312a910b.jpg" alt=""/></p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-java/java性能调优实战/07.模块六·数据库性能调优/07#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>我们知道，InnoDB的IBP的内存大小是有限的，你知道InnoDB是如何将热点数据留在内存中，淘汰非热点数据的吗？</p><p>期待在留言区看到你的答案。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/java性能调优实战/07.模块六·数据库性能调优/07.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 11:06:36</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-java/umi.fde43fdb.js"></script>
  </body>
</html>
