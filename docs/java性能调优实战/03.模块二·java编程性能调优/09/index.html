<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-test/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-test";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>10 | 网络通信优化之通信协议：如何优化RPC网络通信？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/java性能调优实战/03.模块二·java编程性能调优/09" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>java开发<ul><li><a href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java并发编程实战">java并发编程实战</a></li><li><a aria-current="page" class="active" href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></span><span>架构师<ul><li><a href="/blog-test/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-test/从0开始学微服务">从0开始学微服务</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>java开发<ul><li><a href="/blog-test/java业务开发常见错误100例">java业务开发常见错误100例</a></li><li><a href="/blog-test/java并发编程实战">java并发编程实战</a></li><li><a aria-current="page" class="active" href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-test/java核心技术面试精讲">java核心技术面试精讲</a></li><li><a href="/blog-test/spring编程常见错误50例">spring编程常见错误50例</a></li><li><a href="/blog-test/深入剖析java新特性">深入剖析java新特性</a></li><li><a href="/blog-test/深入拆解java虚拟机">深入拆解java虚拟机</a></li></ul></li><li>架构师<ul><li><a href="/blog-test/rpc实战与核心原理">rpc实战与核心原理</a></li><li><a href="/blog-test/从0开始学微服务">从0开始学微服务</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-test/java性能调优实战">java性能调优实战</a></li><li><a href="/blog-test/java性能调优实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-test/java性能调优实战/01.开篇词/01"><span>开篇词 | 怎样才能做好性能调优？</span></a></li></ul></li><li><a href="/blog-test/java性能调优实战/02.模块一·概述">02.模块一·概述</a><ul><li><a href="/blog-test/java性能调优实战/02.模块一·概述/01"><span>01 | 如何制定性能调优标准？</span></a></li><li><a href="/blog-test/java性能调优实战/02.模块一·概述/02"><span>02 | 如何制定性能调优策略？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优">03.模块二·Java编程性能调优</a><ul><li><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/01"><span>03 | 字符串性能优化不容小觑，百M内存轻松存储几十G数据</span></a></li><li><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/02"><span>04 | 慎重使用正则表达式</span></a></li><li><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/03"><span>05 | ArrayList还是LinkedList？使用不当性能差千倍</span></a></li><li><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/04"><span>加餐 | 推荐几款常用的性能测试工具</span></a></li><li><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/05"><span>06 | Stream如何提高遍历集合效率？</span></a></li><li><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/06"><span>07 | 深入浅出HashMap的设计与优化</span></a></li><li><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/07"><span>08 | 网络通信优化之I/O模型：如何解决高并发下I/O瓶颈？</span></a></li><li><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/08"><span>09 | 网络通信优化之序列化：避免使用Java序列化</span></a></li><li><a aria-current="page" class="active" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09"><span>10 | 网络通信优化之通信协议：如何优化RPC网络通信？</span></a></li><li><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/10"><span>11 | 答疑课堂：深入了解NIO的优化实现原理</span></a></li></ul></li><li><a href="/blog-test/java性能调优实战/04.模块三·多线程性能调优">04.模块三·多线程性能调优</a><ul><li><a href="/blog-test/java性能调优实战/04.模块三·多线程性能调优/01"><span>12 | 多线程之锁优化（上）：深入了解Synchronized同步锁的优化方法</span></a></li><li><a href="/blog-test/java性能调优实战/04.模块三·多线程性能调优/02"><span>13 | 多线程之锁优化（中）：深入了解Lock同步锁的优化方法</span></a></li><li><a href="/blog-test/java性能调优实战/04.模块三·多线程性能调优/03"><span>14 | 多线程之锁优化（下）：使用乐观锁优化并行操作</span></a></li><li><a href="/blog-test/java性能调优实战/04.模块三·多线程性能调优/04"><span>15 | 多线程调优（上）：哪些操作导致了上下文切换？</span></a></li><li><a href="/blog-test/java性能调优实战/04.模块三·多线程性能调优/05"><span>16 | 多线程调优（下）：如何优化多线程上下文切换？</span></a></li><li><a href="/blog-test/java性能调优实战/04.模块三·多线程性能调优/06"><span>17 | 并发容器的使用：识别不同场景下最优容器</span></a></li><li><a href="/blog-test/java性能调优实战/04.模块三·多线程性能调优/07"><span>18 | 如何设置线程池大小？</span></a></li><li><a href="/blog-test/java性能调优实战/04.模块三·多线程性能调优/08"><span>19 | 如何用协程来优化多线程业务？</span></a></li><li><a href="/blog-test/java性能调优实战/04.模块三·多线程性能调优/09"><span>20 | 答疑课堂：模块三热点问题解答</span></a></li><li><a href="/blog-test/java性能调优实战/04.模块三·多线程性能调优/10"><span>加餐 | 什么是数据的强、弱一致性？</span></a></li></ul></li><li><a href="/blog-test/java性能调优实战/05.模块四·jvm性能监测及调优">05.模块四·JVM性能监测及调优</a><ul><li><a href="/blog-test/java性能调优实战/05.模块四·jvm性能监测及调优/01"><span>21 | 磨刀不误砍柴工：欲知JVM调优先了解JVM内存模型</span></a></li><li><a href="/blog-test/java性能调优实战/05.模块四·jvm性能监测及调优/02"><span>22 | 深入JVM即时编译器JIT，优化Java编译</span></a></li><li><a href="/blog-test/java性能调优实战/05.模块四·jvm性能监测及调优/03"><span>23 | 如何优化垃圾回收机制？</span></a></li><li><a href="/blog-test/java性能调优实战/05.模块四·jvm性能监测及调优/04"><span>24 | 如何优化JVM内存分配？</span></a></li><li><a href="/blog-test/java性能调优实战/05.模块四·jvm性能监测及调优/05"><span>25 | 内存持续上升，我该如何排查问题？</span></a></li><li><a href="/blog-test/java性能调优实战/05.模块四·jvm性能监测及调优/06"><span>26 | 答疑课堂：模块四热点问题解答</span></a></li></ul></li><li><a href="/blog-test/java性能调优实战/06.模块五·设计模式调优">06.模块五·设计模式调优</a><ul><li><a href="/blog-test/java性能调优实战/06.模块五·设计模式调优/01"><span>27 | 单例模式：如何创建单一对象优化系统性能？</span></a></li><li><a href="/blog-test/java性能调优实战/06.模块五·设计模式调优/02"><span>28 | 原型模式与享元模式：提升系统性能的利器</span></a></li><li><a href="/blog-test/java性能调优实战/06.模块五·设计模式调优/03"><span>29 | 如何使用设计模式优化并发编程？</span></a></li><li><a href="/blog-test/java性能调优实战/06.模块五·设计模式调优/04"><span>30 | 生产者消费者模式：电商库存设计优化</span></a></li><li><a href="/blog-test/java性能调优实战/06.模块五·设计模式调优/05"><span>31 | 装饰器模式：如何优化电商系统中复杂的商品价格策略？</span></a></li><li><a href="/blog-test/java性能调优实战/06.模块五·设计模式调优/06"><span>32 | 答疑课堂：模块五思考题集锦</span></a></li></ul></li><li><a href="/blog-test/java性能调优实战/07.模块六·数据库性能调优">07.模块六·数据库性能调优</a><ul><li><a href="/blog-test/java性能调优实战/07.模块六·数据库性能调优/01"><span>33 | MySQL调优之SQL语句：如何写出高性能SQL语句？</span></a></li><li><a href="/blog-test/java性能调优实战/07.模块六·数据库性能调优/02"><span>34 | MySQL调优之事务：高并发场景下的数据库事务调优</span></a></li><li><a href="/blog-test/java性能调优实战/07.模块六·数据库性能调优/03"><span>35 | MySQL调优之索引：索引的失效与优化</span></a></li><li><a href="/blog-test/java性能调优实战/07.模块六·数据库性能调优/04"><span>36 | 记一次线上SQL死锁事故：如何避免死锁？</span></a></li><li><a href="/blog-test/java性能调优实战/07.模块六·数据库性能调优/05"><span>37 | 什么时候需要分表分库？</span></a></li><li><a href="/blog-test/java性能调优实战/07.模块六·数据库性能调优/06"><span>38 | 电商系统表设计优化案例分析</span></a></li><li><a href="/blog-test/java性能调优实战/07.模块六·数据库性能调优/07"><span>39 | 数据库参数设置优化，失之毫厘差之千里</span></a></li><li><a href="/blog-test/java性能调优实战/07.模块六·数据库性能调优/08"><span>40 | 答疑课堂：MySQL中InnoDB的知识点串讲</span></a></li></ul></li><li><a href="/blog-test/java性能调优实战/08.模块七·实战演练场">08.模块七·实战演练场</a><ul><li><a href="/blog-test/java性能调优实战/08.模块七·实战演练场/01"><span>41 | 如何设计更优的分布式锁？</span></a></li><li><a href="/blog-test/java性能调优实战/08.模块七·实战演练场/02"><span>42 | 电商系统的分布式事务调优</span></a></li><li><a href="/blog-test/java性能调优实战/08.模块七·实战演练场/03"><span>43 | 如何使用缓存优化系统性能？</span></a></li><li><a href="/blog-test/java性能调优实战/08.模块七·实战演练场/04"><span>44 | 记一次双十一抢购性能瓶颈调优</span></a></li></ul></li><li><a href="/blog-test/java性能调优实战/09.结束语">09.结束语</a><ul><li><a href="/blog-test/java性能调优实战/09.结束语/01"><span>结束语 | 栉风沐雨，砥砺前行！</span></a></li></ul></li><li><a href="/blog-test/java性能调优实战/10.期末测试">10.期末测试</a><ul><li><a href="/blog-test/java性能调优实战/10.期末测试/01"><span>期末测试 | 有关Java性能调优，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog-test/java性能调优实战/summary">java性能调优实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="RPC通信是大型服务框架的核心" data-depth="2"><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#rpc通信是大型服务框架的核心"><span>RPC通信是大型服务框架的核心</span></a></li><li title="什么是RPC通信" data-depth="2"><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#什么是rpc通信"><span>什么是RPC通信</span></a></li><li title="RMI：JDK自带的RPC通信框架" data-depth="2"><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#rmijdk自带的rpc通信框架"><span>RMI：JDK自带的RPC通信框架</span></a></li><li title="RMI的实现原理" data-depth="3"><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#rmi的实现原理"><span>RMI的实现原理</span></a></li><li title="RMI在高并发场景下的性能瓶颈" data-depth="3"><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#rmi在高并发场景下的性能瓶颈"><span>RMI在高并发场景下的性能瓶颈</span></a></li><li title="一个高并发场景下的RPC通信优化路径" data-depth="2"><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#一个高并发场景下的rpc通信优化路径"><span>一个高并发场景下的RPC通信优化路径</span></a></li><li title="1.选择合适的通信协议" data-depth="3"><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#1选择合适的通信协议"><span>1.选择合适的通信协议</span></a></li><li title="2.使用单一长连接" data-depth="3"><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#2使用单一长连接"><span>2.使用单一长连接</span></a></li><li title="3.优化Socket通信" data-depth="3"><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#3优化socket通信"><span>3.优化Socket通信</span></a></li><li title="4.量身定做报文格式" data-depth="3"><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#4量身定做报文格式"><span>4.量身定做报文格式</span></a></li><li title="5.编码、解码" data-depth="3"><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#5编码解码"><span>5.编码、解码</span></a></li><li title="6.调整Linux的TCP参数设置选项" data-depth="3"><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#6调整linux的tcp参数设置选项"><span>6.调整Linux的TCP参数设置选项</span></a></li><li title="总结" data-depth="2"><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="10--网络通信优化之通信协议如何优化rpc网络通信"><a aria-hidden="true" tabindex="-1" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#10--网络通信优化之通信协议如何优化rpc网络通信"><span class="icon icon-link"></span></a>10 | 网络通信优化之通信协议：如何优化RPC网络通信？</h1><p>你好，我是刘超。今天我将带你了解下服务间的网络通信优化。</p><p>上一讲中，我提到了微服务框架，其中SpringCloud和Dubbo的使用最为广泛，行业内也一直存在着对两者的比较，很多技术人会为这两个框架哪个更好而争辩。</p><p>我记得我们部门在搭建微服务框架时，也在技术选型上纠结良久，还曾一度有过激烈的讨论。当前SpringCloud炙手可热，具备完整的微服务生态，得到了很多同事的票选，但我们最终的选择却是Dubbo，这是为什么呢？</p><h2 id="rpc通信是大型服务框架的核心"><a aria-hidden="true" tabindex="-1" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#rpc通信是大型服务框架的核心"><span class="icon icon-link"></span></a>RPC通信是大型服务框架的核心</h2><p>我们经常讨论微服务，首要应该了解的就是微服务的核心到底是什么，这样我们在做技术选型时，才能更准确地把握需求。</p><p>就我个人理解，我认为微服务的核心是远程通信和服务治理。远程通信提供了服务之间通信的桥梁，服务治理则提供了服务的后勤保障。所以，我们在做技术选型时，更多要考虑的是这两个核心的需求。</p><p>我们知道服务的拆分增加了通信的成本，特别是在一些抢购或者促销的业务场景中，如果服务之间存在方法调用，比如，抢购成功之后需要调用订单系统、支付系统、券包系统等，这种远程通信就很容易成为系统的瓶颈。所以，在满足一定的服务治理需求的前提下，对远程通信的性能需求就是技术选型的主要影响因素。</p><p>目前，很多微服务框架中的服务通信是基于RPC通信实现的，在没有进行组件扩展的前提下，SpringCloud是基于Feign组件实现的RPC通信（基于Http+Json序列化实现），Dubbo是基于SPI扩展了很多RPC通信框架，包括RMI、Dubbo、Hessian等RPC通信框架（默认是Dubbo+Hessian序列化）。不同的业务场景下，RPC通信的选择和优化标准也不同。</p><p>例如，开头我提到的我们部门在选择微服务框架时，选择了Dubbo。当时的选择标准就是RPC通信可以支持抢购类的高并发，在这个业务场景中，请求的特点是瞬时高峰、请求量大和传入、传出参数数据包较小。而Dubbo中的Dubbo协议就很好地支持了这个请求。</p><p>**以下是基于Dubbo:2.6.4版本进行的简单的性能测试。**分别测试Dubbo+Protobuf序列化以及Http+Json序列化的通信性能（这里主要模拟单一TCP长连接+Protobuf序列化和短连接的Http+Json序列化的性能对比）。为了验证在数据量不同的情况下二者的性能表现，我分别准备了小对象和大对象的性能压测，通过这样的方式我们也可以间接地了解下二者在RPC通信方面的水平。</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimagedc54dc950f3a5ff15253e101fac90c192f54.90954c67.jpg" alt=""/></p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage20b120814a2a87057fdc03af699454f703b1.c17fec81.jpg" alt=""/></p><p>这个测试是我之前的积累，基于测试环境比较复杂，这里我就直接给出结果了，如果你感兴趣的话，可以留言和我讨论。</p><p>通过以上测试结果可以发现：<strong>无论从响应时间还是吞吐量上来看，单一TCP长连接+Protobuf序列化实现的RPC通信框架都有着非常明显的优势。</strong></p><p>在高并发场景下，我们选择后端服务框架或者中间件部门自行设计服务框架时，RPC通信是重点优化的对象。</p><p>其实，目前成熟的RPC通信框架非常多，如果你们公司没有自己的中间件团队，也可以基于开源的RPC通信框架做扩展。在正式进行优化之前，我们不妨简单回顾下RPC。</p><h2 id="什么是rpc通信"><a aria-hidden="true" tabindex="-1" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#什么是rpc通信"><span class="icon icon-link"></span></a>什么是RPC通信</h2><p>一提到RPC，你是否还想到MVC、SOA这些概念呢？如果你没有经历过这些架构的演变，这些概念就很容易混淆。<strong>你可以通过下面这张图来了解下这些架构的演变史。</strong></p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimagee4a5e43a8f81d76927948a73a9977643daa5.ec5003a4.jpg" alt=""/></p><p>无论是微服务、SOA、还是RPC架构，它们都是分布式服务架构，都需要实现服务之间的互相通信，我们通常把这种通信统称为RPC通信。</p><p>RPC（Remote Process Call），即远程服务调用，是通过网络请求远程计算机程序服务的通信技术。RPC框架封装好了底层网络通信、序列化等技术，我们只需要在项目中引入各个服务的接口包，就可以实现在代码中调用RPC服务同调用本地方法一样。正因为这种方便、透明的远程调用，RPC被广泛应用于当下企业级以及互联网项目中，是实现分布式系统的核心。</p><p>RMI（Remote Method Invocation）是JDK中最先实现了RPC通信的框架之一，RMI的实现对建立分布式Java应用程序至关重要，是Java体系非常重要的底层技术，很多开源的RPC通信框架也是基于RMI实现原理设计出来的，包括Dubbo框架中也接入了RMI框架。接下来我们就一起了解下RMI的实现原理，看看它存在哪些性能瓶颈有待优化。</p><h2 id="rmijdk自带的rpc通信框架"><a aria-hidden="true" tabindex="-1" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#rmijdk自带的rpc通信框架"><span class="icon icon-link"></span></a>RMI：JDK自带的RPC通信框架</h2><p>目前RMI已经很成熟地应用在了EJB以及Spring框架中，是纯Java网络分布式应用系统的核心解决方案。RMI实现了一台虚拟机应用对远程方法的调用可以同对本地方法的调用一样，RMI帮我们封装好了其中关于远程通信的内容。</p><h3 id="rmi的实现原理"><a aria-hidden="true" tabindex="-1" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#rmi的实现原理"><span class="icon icon-link"></span></a>RMI的实现原理</h3><p>RMI远程代理对象是RMI中最核心的组件，除了对象本身所在的虚拟机，其它虚拟机也可以调用此对象的方法。而且这些虚拟机可以不在同一个主机上，通过远程代理对象，远程应用可以用网络协议与服务进行通信。</p><p>我们可以通过一张图来详细地了解下整个RMI的通信过程：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage114f1113e44dd62591ce68961e017c11ed4f.03aeb6bd.jpg" alt=""/></p><h3 id="rmi在高并发场景下的性能瓶颈"><a aria-hidden="true" tabindex="-1" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#rmi在高并发场景下的性能瓶颈"><span class="icon icon-link"></span></a>RMI在高并发场景下的性能瓶颈</h3><ul><li>Java默认序列化</li></ul><p>RMI的序列化采用的是Java默认的序列化方式，我在09讲中详细地介绍过Java序列化，我们深知它的性能并不是很好，而且其它语言框架也暂时不支持Java序列化。</p><ul><li>TCP短连接</li></ul><p>由于RMI是基于TCP短连接实现，在高并发情况下，大量请求会带来大量连接的创建和销毁，这对于系统来说无疑是非常消耗性能的。</p><ul><li>阻塞式网络I/O</li></ul><p>在08讲中，我提到了网络通信存在I/O瓶颈，如果在Socket编程中使用传统的I/O模型，在高并发场景下基于短连接实现的网络通信就很容易产生I/O阻塞，性能将会大打折扣。</p><h2 id="一个高并发场景下的rpc通信优化路径"><a aria-hidden="true" tabindex="-1" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#一个高并发场景下的rpc通信优化路径"><span class="icon icon-link"></span></a>一个高并发场景下的RPC通信优化路径</h2><p>SpringCloud的RPC通信和RMI通信的性能瓶颈就非常相似。SpringCloud是基于Http通信协议（短连接）和Json序列化实现的，在高并发场景下并没有优势。 那么，在瞬时高并发的场景下，我们又该如何去优化一个RPC通信呢？</p><p>RPC通信包括了建立通信、实现报文、传输协议以及传输数据编解码等操作，接下来我们就从每一层的优化出发，逐步实现整体的性能优化。</p><h3 id="1选择合适的通信协议"><a aria-hidden="true" tabindex="-1" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#1选择合适的通信协议"><span class="icon icon-link"></span></a>1.选择合适的通信协议</h3><p>要实现不同机器间的网络通信，我们先要了解计算机系统网络通信的基本原理。网络通信是两台设备之间实现数据流交换的过程，是基于网络传输协议和传输数据的编解码来实现的。其中网络传输协议有TCP、UDP协议，这两个协议都是基于Socket编程接口之上，为某类应用场景而扩展出的传输协议。通过以下两张图，我们可以大概了解到基于TCP和UDP协议实现的Socket网络通信是怎样的一个流程。</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage2c0b2c7c373963196a30e9d4fdc524a92d0b.5132c627.jpg" alt=""/></p><p>基于TCP协议实现的Socket通信是有连接的，而传输数据是要通过三次握手来实现数据传输的可靠性，且传输数据是没有边界的，采用的是字节流模式。</p><p>基于UDP协议实现的Socket通信，客户端不需要建立连接，只需要创建一个套接字发送数据报给服务端，这样就不能保证数据报一定会达到服务端，所以在传输数据方面，基于UDP协议实现的Socket通信具有不可靠性。UDP发送的数据采用的是数据报模式，每个UDP的数据报都有一个长度，该长度将与数据一起发送到服务端。</p><p>通过对比，我们可以得出优化方法：为了保证数据传输的可靠性，通常情况下我们会采用TCP协议。如果在局域网且对数据传输的可靠性没有要求的情况下，我们也可以考虑使用UDP协议，毕竟这种协议的效率要比TCP协议高。</p><h3 id="2使用单一长连接"><a aria-hidden="true" tabindex="-1" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#2使用单一长连接"><span class="icon icon-link"></span></a>2.使用单一长连接</h3><p>如果是基于TCP协议实现Socket通信，我们还能做哪些优化呢？</p><p>服务之间的通信不同于客户端与服务端之间的通信。客户端与服务端由于客户端数量多，基于短连接实现请求可以避免长时间地占用连接，导致系统资源浪费。</p><p>但服务之间的通信，连接的消费端不会像客户端那么多，但消费端向服务端请求的数量却一样多，我们基于长连接实现，就可以省去大量的TCP建立和关闭连接的操作，从而减少系统的性能消耗，节省时间。</p><h3 id="3优化socket通信"><a aria-hidden="true" tabindex="-1" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#3优化socket通信"><span class="icon icon-link"></span></a>3.优化Socket通信</h3><p>建立两台机器的网络通信，我们一般使用Java的Socket编程实现一个TCP连接。传统的Socket通信主要存在I/O阻塞、线程模型缺陷以及内存拷贝等问题。我们可以使用比较成熟的通信框架，比如Netty。Netty4对Socket通信编程做了很多方面的优化，具体见下方。</p><p>**实现非阻塞I/O：**在08讲中，我们提到了多路复用器Selector实现了非阻塞I/O通信。</p><p>**高效的Reactor线程模型：**Netty使用了主从Reactor多线程模型，服务端接收客户端请求连接是用了一个主线程，这个主线程用于客户端的连接请求操作，一旦连接建立成功，将会监听I/O事件，监听到事件后会创建一个链路请求。</p><p>链路请求将会注册到负责I/O操作的I/O工作线程上，由I/O工作线程负责后续的I/O操作。利用这种线程模型，可以解决在高负载、高并发的情况下，由于单个NIO线程无法监听海量客户端和满足大量I/O操作造成的问题。</p><p>**串行设计：**服务端在接收消息之后，存在着编码、解码、读取和发送等链路操作。如果这些操作都是基于并行去实现，无疑会导致严重的锁竞争，进而导致系统的性能下降。为了提升性能，Netty采用了串行无锁化完成链路操作，Netty提供了Pipeline实现链路的各个操作在运行期间不进行线程切换。</p><p>**零拷贝：**在08讲中，我们提到了一个数据从内存发送到网络中，存在着两次拷贝动作，先是从用户空间拷贝到内核空间，再是从内核空间拷贝到网络I/O中。而NIO提供的ByteBuffer可以使用Direct Buffers模式，直接开辟一个非堆物理内存，不需要进行字节缓冲区的二次拷贝，可以直接将数据写入到内核空间。</p><p><strong>除了以上这些优化，我们还可以针对套接字编程提供的一些TCP参数配置项，提高网络吞吐量，Netty可以基于ChannelOption来设置这些参数。</strong></p><p>**TCP_NODELAY：**TCP_NODELAY选项是用来控制是否开启Nagle算法。Nagle算法通过缓存的方式将小的数据包组成一个大的数据包，从而避免大量的小数据包发送阻塞网络，提高网络传输的效率。我们可以关闭该算法，优化对于时延敏感的应用场景。</p><p>**SO_RCVBUF和SO_SNDBUF：**可以根据场景调整套接字发送缓冲区和接收缓冲区的大小。</p><p>**SO_BACKLOG：**backlog参数指定了客户端连接请求缓冲队列的大小。服务端处理客户端连接请求是按顺序处理的，所以同一时间只能处理一个客户端连接，当有多个客户端进来的时候，服务端就会将不能处理的客户端连接请求放在队列中等待处理。</p><p>**SO_KEEPALIVE：**当设置该选项以后，连接会检查长时间没有发送数据的客户端的连接状态，检测到客户端断开连接后，服务端将回收该连接。我们可以将该时间设置得短一些，来提高回收连接的效率。</p><h3 id="4量身定做报文格式"><a aria-hidden="true" tabindex="-1" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#4量身定做报文格式"><span class="icon icon-link"></span></a>4.量身定做报文格式</h3><p>接下来就是实现报文，我们需要设计一套报文，用于描述具体的校验、操作、传输数据等内容。为了提高传输的效率，我们可以根据自己的业务和架构来考虑设计，尽量实现报体小、满足功能、易解析等特性。我们可以参考下面的数据格式：</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage6dc16dc21193a6ffbf94a7dd8e5a0d2302c1.1c5f112a.jpg" alt=""/><br/><img src="/blog-test/static/httpsstatic001geekbangorgresourceimagef3aef3bb46ed6ece4a8a9bcc3d9e9df84cae.3b32ae4a.jpg" alt=""/></p><h3 id="5编码解码"><a aria-hidden="true" tabindex="-1" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#5编码解码"><span class="icon icon-link"></span></a>5.编码、解码</h3><p>在09讲中，我们分析过序列化编码和解码的过程，对于实现一个好的网络通信协议来说，兼容优秀的序列化框架是非常重要的。如果只是单纯的数据对象传输，我们可以选择性能相对较好的Protobuf序列化，有利于提高网络通信的性能。</p><h3 id="6调整linux的tcp参数设置选项"><a aria-hidden="true" tabindex="-1" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#6调整linux的tcp参数设置选项"><span class="icon icon-link"></span></a>6.调整Linux的TCP参数设置选项</h3><p>如果RPC是基于TCP短连接实现的，我们可以通过修改Linux TCP配置项来优化网络通信。开始TCP配置项的优化之前，我们先来了解下建立TCP连接的三次握手和关闭TCP连接的四次握手，这样有助后面内容的理解。</p><ul><li>三次握手</li></ul><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage32de32381d3314bd982544f69e4d3faba1de.fcc51a82.jpg" alt=""/></p><ul><li>四次握手</li></ul><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimagedf91df9f4e3f3598a7e160c899f552a59391.9db72e52.jpg" alt=""/></p><p>我们可以通过sysctl -a | grep net.xxx命令运行查看Linux系统默认的的TCP参数设置，如果需要修改某项配置，可以通过编辑 vim/etc/sysctl.conf，加入需要修改的配置项， 并通过sysctl -p命令运行生效修改后的配置项设置。通常我们会通过修改以下几个配置项来提高网络吞吐量和降低延时。</p><p><img src="/blog-test/static/httpsstatic001geekbangorgresourceimage9ebc9eb01fe017b267367b11170a864bd0bc.1af4276f.jpg" alt=""/></p><p>以上就是我们从不同层次对RPC优化的详解，除了最后的Linux系统中TCP的配置项设置调优，其它的调优更多是从代码编程优化的角度出发，最终实现了一套RPC通信框架的优化路径。</p><p>弄懂了这些，你就可以根据自己的业务场景去做技术选型了，还能很好地解决过程中出现的一些性能问题。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#总结"><span class="icon icon-link"></span></a>总结</h2><p>在现在的分布式系统中，特别是系统走向微服务化的今天，服务间的通信就显得尤为频繁，掌握服务间的通信原理和通信协议优化，是你的一项的必备技能。</p><p>在一些并发场景比较多的系统中，我更偏向使用Dubbo实现的这一套RPC通信协议。Dubbo协议是建立的单一长连接通信，网络I/O为NIO非阻塞读写操作，更兼容了Kryo、FST、Protobuf等性能出众的序列化框架，在高并发、小对象传输的业务场景中非常实用。</p><p>在企业级系统中，业务往往要比普通的互联网产品复杂，服务与服务之间可能不仅仅是数据传输，还有图片以及文件的传输，所以RPC的通信协议设计考虑更多是功能性需求，在性能方面不追求极致。其它通信框架在功能性、生态以及易用、易入门等方面更具有优势。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-test/java性能调优实战/03.模块二·java编程性能调优/09#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>目前实现Java RPC通信的框架有很多，实现RPC通信的协议也有很多，除了Dubbo协议以外，你还使用过其它RPC通信协议吗？通过这讲的学习，你能对比谈谈各自的优缺点了吗？</p><p>期待在留言区看到你的见解。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起学习。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/java性能调优实战/03.模块二·Java编程性能调优/09.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/27 09:43:57</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-test/umi.3ded5539.js"></script>
  </body>
</html>
